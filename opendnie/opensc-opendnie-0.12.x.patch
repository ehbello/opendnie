Index: m4/libassuan.m4
===================================================================
--- m4/libassuan.m4	(revisión: 0)
+++ m4/libassuan.m4	(revisión: 0)
@@ -0,0 +1,160 @@
+dnl Autoconf macros for libassuan
+dnl       Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+dnl
+dnl This file is free software; as a special exception the author gives
+dnl unlimited permission to copy and/or distribute it, with or without
+dnl modifications, as long as this notice is preserved.
+dnl
+dnl This file is distributed in the hope that it will be useful, but
+dnl WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+dnl implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+dnl
+dnl Common code used for libassuan detection [internal]
+dnl Returns ok set to yes or no.
+dnl
+AC_DEFUN([_AM_PATH_LIBASSUAN_COMMON],
+[ AC_ARG_WITH(libassuan-prefix,
+              AC_HELP_STRING([--with-libassuan-prefix=PFX],
+                             [prefix where LIBASSUAN is installed (optional)]),
+     libassuan_config_prefix="$withval", libassuan_config_prefix="")
+  if test x$libassuan_config_prefix != x ; then
+    libassuan_config_args="$libassuan_config_args --prefix=$libassuan_config_prefix"
+    if test x${LIBASSUAN_CONFIG+set} != xset ; then
+      LIBASSUAN_CONFIG=$libassuan_config_prefix/bin/libassuan-config
+    fi
+  fi
+  AC_PATH_PROG(LIBASSUAN_CONFIG, libassuan-config, no)
+
+  tmp=ifelse([$1], ,1:0.9.2,$1)
+  if echo "$tmp" | grep ':' >/dev/null 2>/dev/null ; then
+    req_libassuan_api=`echo "$tmp"     | sed 's/\(.*\):\(.*\)/\1/'`
+    min_libassuan_version=`echo "$tmp" | sed 's/\(.*\):\(.*\)/\2/'`
+  else
+    req_libassuan_api=0
+    min_libassuan_version="$tmp"
+  fi
+
+  if test "$LIBASSUAN_CONFIG" != "no" ; then
+    libassuan_version=`$LIBASSUAN_CONFIG --version`
+  fi
+  libassuan_version_major=`echo $libassuan_version | \
+               sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\).*/\1/'`
+  libassuan_version_minor=`echo $libassuan_version | \
+               sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\).*/\2/'`
+  libassuan_version_micro=`echo $libassuan_version | \
+               sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\).*/\3/'`
+
+  AC_MSG_CHECKING(for LIBASSUAN ifelse([$2], ,,[$2 ])- version >= $min_libassuan_version)
+  ok=no
+  if test "$LIBASSUAN_CONFIG" != "no" ; then
+    ifelse([$2], ,,[if `$LIBASSUAN_CONFIG --thread=$2 2> /dev/null` ; then])
+    req_major=`echo $min_libassuan_version | \
+               sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\1/'`
+    req_minor=`echo $min_libassuan_version | \
+               sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\2/'`
+    req_micro=`echo $min_libassuan_version | \
+               sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\3/'`
+    if test "$libassuan_version_major" -gt "$req_major"; then
+        ok=yes
+    else 
+        if test "$libassuan_version_major" -eq "$req_major"; then
+            if test "$libassuan_version_minor" -gt "$req_minor"; then
+               ok=yes
+            else
+               if test "$libassuan_version_minor" -eq "$req_minor"; then
+                   if test "$libassuan_version_micro" -ge "$req_micro"; then
+                     ok=yes
+                   fi
+               fi
+            fi
+        fi
+    fi
+    ifelse([$2], ,,[fi])
+  fi
+
+  if test $ok = yes; then
+    AC_MSG_RESULT(yes)
+  else
+    AC_MSG_RESULT(no)
+  fi
+
+  if test $ok = yes; then
+    if test "$req_libassuan_api" -gt 0 ; then
+      tmp=`$LIBASSUAN_CONFIG --api-version 2>/dev/null || echo 0`
+      if test "$tmp" -gt 0 ; then
+        AC_MSG_CHECKING([LIBASSUAN ifelse([$2], ,,[$2 ])API version])
+        if test "$req_libassuan_api" -eq "$tmp" ; then
+          AC_MSG_RESULT(okay)
+        else
+          ok=no
+          AC_MSG_RESULT([does not match.  want=$req_libassuan_api got=$tmp.])
+        fi
+      fi
+    fi
+  fi
+
+])
+
+
+
+dnl AM_PATH_LIBASSUAN([MINIMUM-VERSION,
+dnl                   [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND ]]])
+dnl Test for libassuan and define LIBASSUAN_CFLAGS and LIBASSUAN_LIBS
+dnl
+AC_DEFUN([AM_PATH_LIBASSUAN],
+[ _AM_PATH_LIBASSUAN_COMMON($1)
+  if test $ok = yes; then
+    LIBASSUAN_CFLAGS=`$LIBASSUAN_CONFIG $libassuan_config_args --cflags`
+    LIBASSUAN_LIBS=`$LIBASSUAN_CONFIG $libassuan_config_args --libs`
+    ifelse([$2], , :, [$2])
+  else
+    LIBASSUAN_CFLAGS=""
+    LIBASSUAN_LIBS=""
+    ifelse([$3], , :, [$3])
+  fi
+  AC_SUBST(LIBASSUAN_CFLAGS)
+  AC_SUBST(LIBASSUAN_LIBS)
+])
+
+
+dnl AM_PATH_LIBASSUAN_PTH([MINIMUM-VERSION,
+dnl                      [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND ]]])
+dnl Test for libassuan and define LIBASSUAN_PTH_CFLAGS and LIBASSUAN_PTH_LIBS
+dnl
+AC_DEFUN([AM_PATH_LIBASSUAN_PTH],
+[ _AM_PATH_LIBASSUAN_COMMON($1,pth)
+  if test $ok = yes; then
+    LIBASSUAN_PTH_CFLAGS=`$LIBASSUAN_CONFIG $libassuan_config_args --thread=pth --cflags`
+    LIBASSUAN_PTH_LIBS=`$LIBASSUAN_CONFIG $libassuan_config_args --thread=pth --libs`
+    ifelse([$2], , :, [$2])
+  else
+    LIBASSUAN_PTH_CFLAGS=""
+    LIBASSUAN_PTH_LIBS=""
+    ifelse([$3], , :, [$3])
+  fi
+  AC_SUBST(LIBASSUAN_PTH_CFLAGS)
+  AC_SUBST(LIBASSUAN_PTH_LIBS)
+])
+
+
+dnl AM_PATH_LIBASSUAN_PTHREAD([MINIMUM-VERSION,
+dnl                           [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND ]]])
+dnl Test for libassuan and define LIBASSUAN_PTHREAD_CFLAGS 
+dnl                           and LIBASSUAN_PTHREAD_LIBS
+dnl
+AC_DEFUN([AM_PATH_LIBASSUAN_PTHREAD],
+[ _AM_PATH_LIBASSUAN_COMMON($1,pthread)
+  if test $ok = yes; then
+    LIBASSUAN_PTHREAD_CFLAGS=`$LIBASSUAN_CONFIG $libassuan_config_args --thread=pthread --cflags`
+    LIBASSUAN_PTHREAD_LIBS=`$LIBASSUAN_CONFIG $libassuan_config_args --thread=pthread --libs`
+    ifelse([$2], , :, [$2])
+  else
+    LIBASSUAN_PTHREAD_CFLAGS=""
+    LIBASSUAN_PTHREAD_LIBS=""
+    ifelse([$3], , :, [$3])
+  fi
+  AC_SUBST(LIBASSUAN_PTHREAD_CFLAGS)
+  AC_SUBST(LIBASSUAN_PTHREAD_LIBS)
+])
+
Index: src/libopensc/cards.h
===================================================================
--- src/libopensc/cards.h	(revisión: 4874)
+++ src/libopensc/cards.h	(copia de trabajo)
@@ -175,6 +175,11 @@
 	SC_CARD_TYPE_JAVACARD_BASE = 24000,
 	SC_CARD_TYPE_JAVACARD,
 
+        /* Spanish DNIe card */
+        SC_CARD_TYPE_DNIE_BASE = 25000,
+        SC_CARD_TYPE_DNIE_ADMIN,
+        SC_CARD_TYPE_DNIE_USER,
+        SC_CARD_TYPE_DNIE_TERMINATED,
 };
 
 extern sc_card_driver_t *sc_get_default_driver(void);
@@ -207,6 +212,7 @@
 extern sc_card_driver_t *sc_get_ias_driver(void);
 extern sc_card_driver_t *sc_get_javacard_driver(void);
 extern sc_card_driver_t *sc_get_itacns_driver(void);
+extern sc_card_driver_t *sc_get_dnie_driver(void);
 
 #ifdef __cplusplus
 }
Index: src/libopensc/iso7816.c
===================================================================
--- src/libopensc/iso7816.c	(revisión: 4874)
+++ src/libopensc/iso7816.c	(copia de trabajo)
@@ -992,6 +992,7 @@
 	no_match,
 	NULL,			/* init   */
 	NULL,			/* finish */
+	NULL,			/* wrap   */
 	iso7816_read_binary,
 	iso7816_write_binary,
 	iso7816_update_binary,
Index: src/libopensc/cardctl.h
===================================================================
--- src/libopensc/cardctl.h	(revisión: 4874)
+++ src/libopensc/cardctl.h	(copia de trabajo)
@@ -204,6 +204,12 @@
 	SC_CARDCTL_PIV_GENERATE_KEY,
 	SC_CARDCTL_PIV_PIN_PREFERENCE,
 	SC_CARDCTL_PIV_OBJECT_PRESENT,
+
+	/*
+	 * DNIe specific calls
+	 */
+	SC_CARDCTL_DNIE_BASE = _CTL_PREFIX('D', 'N', 'I'),
+	SC_CARDCTL_DNIE_GENERATE_KEY
 };
 
 enum {
Index: src/libopensc/dnie.h
===================================================================
--- src/libopensc/dnie.h	(revisión: 0)
+++ src/libopensc/dnie.h	(revisión: 0)
@@ -0,0 +1,84 @@
+/*
+ * dnie.h: Defines, Typedefs and prototype functions 
+ * for Spanish DNI electronico (DNIe card)
+ *
+ * Copyright (C) 2010 Juan Antonio Martinez <jonsito@terra.es>
+ *
+ * This work is derived from many sources at OpenSC Project site,
+ * (see references) and the information made public for Spanish 
+ * Direccion General de la Policia y de la Guardia Civil
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __CARD_DNIE_H__
+#define __CARD_DNIE_H__
+
+/* Secure Messaging state indicator */
+#define DNIE_SM_NONE            0x00 /* no channel defined */
+#define DNIE_SM_INPROGRESS      0x01 /* chanel is being created: dont use */
+#define DNIE_SM_INTERNAL        0x02 /* using local keys */
+#define DNIE_SM_EXTERNAL        0x03 /* using SSL connection to handle keys */
+
+/************************** data structures for DNIe **********************/
+typedef struct dnie_file_cache {
+    sc_file_t *file;
+    u8 *data;
+    size_t datalen;
+    struct dnie_file_cache *next;
+} dnie_file_cache_t;
+
+typedef struct dnie_sm_handler {
+    int state;
+    int (*deinit)(struct sc_card *card);
+    int (*encode)(sc_card_t *card,sc_apdu_t *from, sc_apdu_t *to);
+    int (*decode)(sc_card_t *card,sc_apdu_t *from, sc_apdu_t *to);
+} dnie_sm_handler_t;
+
+typedef struct dnie_private_data {
+    char *user_consent_app;
+    int user_consent_enabled;
+    sc_serial_number_t *serialnumber;
+    dnie_sm_handler_t *sm_handler;
+    dnie_file_cache_t *cache_top;
+    dnie_file_cache_t *cache_pt;
+    int rsa_key_ref;   /* key id being used in sec operation */
+} dnie_private_data_t;
+
+/************************** external function prototypes ******************/
+
+extern int dnie_sm_init(
+        struct sc_card *card,           /* card data */
+        dnie_sm_handler_t **sm_handler, /* pointer to dnie_priv.sm_handler */
+        int state);                     /* requested SM state */
+
+extern int dnie_sm_wrap_apdu(
+        struct sc_card *card,           /* card data */
+        dnie_sm_handler_t *sm_handler,  /* pointer to dnie_priv.sm_handler */
+        struct sc_apdu *from,           /* apdu to be parsed */
+        struct sc_apdu *to,             /* apdu to store result */
+        int flag                        /* 0:SM encode 1:SM decode */
+);
+
+extern int dnie_read_file(
+        sc_card_t *card,      /* card data */
+        const sc_path_t *path,/* path file to search for */
+        sc_file_t **file,     /* path file to search for */
+        u8 **buffer,          /* where to store data */
+        size_t *length        /* data length */
+);
+
+#endif
+
Index: src/libopensc/ctx.c
===================================================================
--- src/libopensc/ctx.c	(revisión: 4874)
+++ src/libopensc/ctx.c	(copia de trabajo)
@@ -79,6 +79,7 @@
 	{ "rutoken_ecp",(void *(*)(void)) sc_get_rtecp_driver },
 	{ "westcos",	(void *(*)(void)) sc_get_westcos_driver },
 	{ "myeid",      (void *(*)(void)) sc_get_myeid_driver },
+	{ "dnie",       (void *(*)(void)) sc_get_dnie_driver },
 
 /* Here should be placed drivers that need some APDU transactions to
  * recognise its cards. */
Index: src/libopensc/sm-dnie.c
===================================================================
--- src/libopensc/sm-dnie.c	(revisión: 0)
+++ src/libopensc/sm-dnie.c	(revisión: 0)
@@ -0,0 +1,269 @@
+/*
+ * sm-dnie.c: Virtual channel for transparent sending of
+ * APDU's throught secure messaging for Spanish DNIe card
+ * 
+ * Copyright (C) 2010 Juan Antonio Martinez <jonsito@terra.es>
+ *
+ * This work is derived from many sources at OpenSC Project site,
+ * (see references) and the information made public by Spanish 
+ * Direccion General de la Policia y de la Guardia Civil
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define __SM_DNIE_C__
+
+#include <stdlib.h>
+
+#include "opensc.h"
+#include "cardctl.h"
+#include "internal.h"
+
+#include "dnie.h"
+
+/********************* Keys and certificates as published by DGP ********/
+
+static const u8 ifd_modulus [] = {
+   0xdb, 0x2c, 0xb4, 0x1e, 0x11, 0x2b, 0xac, 0xfa, 0x2b, 0xd7, 0xc3, 0xd3,
+   0xd7, 0x96, 0x7e, 0x84, 0xfb, 0x94, 0x34, 0xfc, 0x26, 0x1f, 0x9d, 0x09,
+   0x0a, 0x89, 0x83, 0x94, 0x7d, 0xaf, 0x84, 0x88, 0xd3, 0xdf, 0x8f, 0xbd,
+   0xcc, 0x1f, 0x92, 0x49, 0x35, 0x85, 0xe1, 0x34, 0xa1, 0xb4, 0x2d, 0xe5,
+   0x19, 0xf4, 0x63, 0x24, 0x4d, 0x7e, 0xd3, 0x84, 0xe2, 0x6d, 0x51, 0x6c,
+   0xc7, 0xa4, 0xff, 0x78, 0x95, 0xb1, 0x99, 0x21, 0x40, 0x04, 0x3a, 0xac,
+   0xad, 0xfc, 0x12, 0xe8, 0x56, 0xb2, 0x02, 0x34, 0x6a, 0xf8, 0x22, 0x6b,
+   0x1a, 0x88, 0x21, 0x37, 0xdc, 0x3c, 0x5a, 0x57, 0xf0, 0xd2, 0x81, 0x5c,
+   0x1f, 0xcd, 0x4b, 0xb4, 0x6f, 0xa9, 0x15, 0x7f, 0xdf, 0xfd, 0x79, 0xec,
+   0x3a, 0x10, 0xa8, 0x24, 0xcc, 0xc1, 0xeb, 0x3c, 0xe0, 0xb6, 0xb4, 0x39,
+   0x6a, 0xe2, 0x36, 0x59, 0x00, 0x16, 0xba, 0x69
+};
+
+static const u8 ifd_public_exponent [] = {
+   0x01, 0x00, 0x01
+};
+
+static const u8 ifd_private_exponent [] = {
+   0x18, 0xb4, 0x4a, 0x3d, 0x15, 0x5c, 0x61, 0xeb, 0xf4, 0xe3, 0x26, 0x1c,
+   0x8b, 0xb1, 0x57, 0xe3, 0x6f, 0x63, 0xfe, 0x30, 0xe9, 0xaf, 0x28, 0x89,
+   0x2b, 0x59, 0xe2, 0xad, 0xeb, 0x18, 0xcc, 0x8c, 0x8b, 0xad, 0x28, 0x4b,
+   0x91, 0x65, 0x81, 0x9c, 0xa4, 0xde, 0xc9, 0x4a, 0xa0, 0x6b, 0x69, 0xbc,
+   0xe8, 0x17, 0x06, 0xd1, 0xc1, 0xb6, 0x68, 0xeb, 0x12, 0x86, 0x95, 0xe5,
+   0xf7, 0xfe, 0xde, 0x18, 0xa9, 0x08, 0xa3, 0x01, 0x1a, 0x64, 0x6a, 0x48,
+   0x1d, 0x3e, 0xa7, 0x1d, 0x8a, 0x38, 0x7d, 0x47, 0x46, 0x09, 0xbd, 0x57,
+   0xa8, 0x82, 0xb1, 0x82, 0xe0, 0x47, 0xde, 0x80, 0xe0, 0x4b, 0x42, 0x21,
+   0x41, 0x6b, 0xd3, 0x9d, 0xfa, 0x1f, 0xac, 0x03, 0x00, 0x64, 0x19, 0x62,
+   0xad, 0xb1, 0x09, 0xe2, 0x8c, 0xaf, 0x50, 0x06, 0x1b, 0x68, 0xc9, 0xca,
+   0xbd, 0x9b, 0x00, 0x31, 0x3c, 0x0f, 0x46, 0xed
+};
+
+// Intermediate CA certificate in CVC format (Card verifiable certificate)
+static const u8 C_CV_CA_CS_AUT_cert [] = {
+  0x7f, 0x21, 0x81, 0xce, 0x5f, 0x37, 0x81, 0x80, 0x3c, 0xba, 0xdc, 0x36,
+  0x84, 0xbe, 0xf3, 0x20, 0x41, 0xad, 0x15, 0x50, 0x89, 0x25, 0x8d, 0xfd,
+  0x20, 0xc6, 0x91, 0x15, 0xd7, 0x2f, 0x9c, 0x38, 0xaa, 0x99, 0xad, 0x6c,
+  0x1a, 0xed, 0xfa, 0xb2, 0xbf, 0xac, 0x90, 0x92, 0xfc, 0x70, 0xcc, 0xc0,
+  0x0c, 0xaf, 0x48, 0x2a, 0x4b, 0xe3, 0x1a, 0xfd, 0xbd, 0x3c, 0xbc, 0x8c,
+  0x83, 0x82, 0xcf, 0x06, 0xbc, 0x07, 0x19, 0xba, 0xab, 0xb5, 0x6b, 0x6e,
+  0xc8, 0x07, 0x60, 0xa4, 0xa9, 0x3f, 0xa2, 0xd7, 0xc3, 0x47, 0xf3, 0x44,
+  0x27, 0xf9, 0xff, 0x5c, 0x8d, 0xe6, 0xd6, 0x5d, 0xac, 0x95, 0xf2, 0xf1,
+  0x9d, 0xac, 0x00, 0x53, 0xdf, 0x11, 0xa5, 0x07, 0xfb, 0x62, 0x5e, 0xeb,
+  0x8d, 0xa4, 0xc0, 0x29, 0x9e, 0x4a, 0x21, 0x12, 0xab, 0x70, 0x47, 0x58,
+  0x8b, 0x8d, 0x6d, 0xa7, 0x59, 0x22, 0x14, 0xf2, 0xdb, 0xa1, 0x40, 0xc7,
+  0xd1, 0x22, 0x57, 0x9b, 0x5f, 0x38, 0x3d, 0x22, 0x53, 0xc8, 0xb9, 0xcb,
+  0x5b, 0xc3, 0x54, 0x3a, 0x55, 0x66, 0x0b, 0xda, 0x80, 0x94, 0x6a, 0xfb,
+  0x05, 0x25, 0xe8, 0xe5, 0x58, 0x6b, 0x4e, 0x63, 0xe8, 0x92, 0x41, 0x49,
+  0x78, 0x36, 0xd8, 0xd3, 0xab, 0x08, 0x8c, 0xd4, 0x4c, 0x21, 0x4d, 0x6a,
+  0xc8, 0x56, 0xe2, 0xa0, 0x07, 0xf4, 0x4f, 0x83, 0x74, 0x33, 0x37, 0x37,
+  0x1a, 0xdd, 0x8e, 0x03, 0x00, 0x01, 0x00, 0x01, 0x42, 0x08, 0x65, 0x73,
+  0x52, 0x44, 0x49, 0x60, 0x00, 0x06
+};
+
+/* Intermediate CA Certificate id */
+/* Hey! Data on Annex III of manual differs here from traces at Annex IV
+ * On doubth, I'll trust my own traces and "understanding the DNIe manual"
+ * (that matches Annex IV)... Need to ask DGP to solve this error
+ */
+static const u8 select_key_verification_data[] = {
+  /* 8 bytes */
+  0x08, 0x65, 0x73, 0x53, 0x44, 0x49, 0x60, 0x00, 0x06
+};
+
+// Terminal (IFD) certificate in CVC format (PK.IFD.AUT)
+static const u8 C_CV_IFDuser_AUT_cert [] = {
+  0x7f, 0x21, 0x81, 0xcd, 0x5f, 0x37, 0x81, 0x80, 0x82, 0x5b, 0x69, 0xc6,
+  0x45, 0x1e, 0x5f, 0x51, 0x70, 0x74, 0x38, 0x5f, 0x2f, 0x17, 0xd6, 0x4d,
+  0xfe, 0x2e, 0x68, 0x56, 0x75, 0x67, 0x09, 0x4b, 0x57, 0xf3, 0xc5, 0x78,
+  0xe8, 0x30, 0xe4, 0x25, 0x57, 0x2d, 0xe8, 0x28, 0xfa, 0xf4, 0xde, 0x1b,
+  0x01, 0xc3, 0x94, 0xe3, 0x45, 0xc2, 0xfb, 0x06, 0x29, 0xa3, 0x93, 0x49,
+  0x2f, 0x94, 0xf5, 0x70, 0xb0, 0x0b, 0x1d, 0x67, 0x77, 0x29, 0xf7, 0x55,
+  0xd1, 0x07, 0x02, 0x2b, 0xb0, 0xa1, 0x16, 0xe1, 0xd7, 0xd7, 0x65, 0x9d,
+  0xb5, 0xc4, 0xac, 0x0d, 0xde, 0xab, 0x07, 0xff, 0x04, 0x5f, 0x37, 0xb5,
+  0xda, 0xf1, 0x73, 0x2b, 0x54, 0xea, 0xb2, 0x38, 0xa2, 0xce, 0x17, 0xc9,
+  0x79, 0x41, 0x87, 0x75, 0x9c, 0xea, 0x9f, 0x92, 0xa1, 0x78, 0x05, 0xa2,
+  0x7c, 0x10, 0x15, 0xec, 0x56, 0xcc, 0x7e, 0x47, 0x1a, 0x48, 0x8e, 0x6f,
+  0x1b, 0x91, 0xf7, 0xaa, 0x5f, 0x38, 0x3c, 0xad, 0xfc, 0x12, 0xe8, 0x56,
+  0xb2, 0x02, 0x34, 0x6a, 0xf8, 0x22, 0x6b, 0x1a, 0x88, 0x21, 0x37, 0xdc,
+  0x3c, 0x5a, 0x57, 0xf0, 0xd2, 0x81, 0x5c, 0x1f, 0xcd, 0x4b, 0xb4, 0x6f,
+  0xa9, 0x15, 0x7f, 0xdf, 0xfd, 0x79, 0xec, 0x3a, 0x10, 0xa8, 0x24, 0xcc,
+  0xc1, 0xeb, 0x3c, 0xe0, 0xb6, 0xb4, 0x39, 0x6a, 0xe2, 0x36, 0x59, 0x00,
+  0x16, 0xba, 0x69, 0x00, 0x01, 0x00, 0x01, 0x42, 0x08, 0x65, 0x73, 0x53,
+  0x44, 0x49, 0x60, 0x00, 0x06
+};
+
+/* IFD Certificate ID */
+static const u8 ifd_serial_data[] = {
+  /* 12 bytes */
+  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
+};
+
+/*********************** Internal authentication routines *******************/
+
+/**
+ * Create Secure channel
+ * Based on Several documents:
+ * "Understanding the DNIe"
+ * "Manual de comandos del DNIe"
+ * ISO7816-4 and CWA14890-{1,2}
+ */
+static int dnie_sm_create_secure_channel(
+                sc_card_t *card, 
+                dnie_sm_handler_t *handler) {
+    int res=SC_SUCCESS;
+    sc_serial_number_t serial;
+    sc_path_t path;
+    int *buffer=NULL;
+    size_t bufferlen=0;
+
+    assert( (card!=NULL) && (card->ctx!=NULL) && (handler!=NULL) );
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    /* ensure that our card is a DNIe */
+    if (card->type!=SC_CARD_TYPE_DNIE_USER)
+        SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_VERBOSE,SC_ERROR_INVALID_CARD);
+    /* reset card */
+    sc_reset(card);
+    /* Retrieve Card serial Number */
+    res=sc_card_ctl(card,SC_CARDCTL_GET_SERIALNR, &serial);
+    SC_TEST_RET(card->ctx,SC_LOG_DEBUG_NORMAL,res,"Cannot get DNIe serialnr");
+/* TODO: dni_sm_create_secure_channel() write */
+    /* Read Intermediate CA from card File:3F006020 */
+    sc_format_path("3F006020",&path);
+    /* Read Card certificate File:3F00601F */
+    /* Verify Card certificate chain */
+    /* Send IFD intermediate CA in CVC format C_CV_CA */
+    /* Send IFD certiticate in CVC format C_CV_IFD */
+    /* Internal (Card) authentication (let the card verify sent ifd certs) */
+    /* External (IFD)  authentication */
+    /* Session key generation */
+
+    /* Mark channel as created and setup wrapper pointers */
+    /* Cleanup */
+    SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_VERBOSE,res);
+}
+
+/************************* public functions ***************/
+int dnie_sm_init(
+        struct sc_card *card,
+        dnie_sm_handler_t **sm_handler,
+        int final_state) {
+    dnie_sm_handler_t *handler;
+    int result;
+    assert( (card!=NULL) && (card->ctx!=NULL) && (sm_handler!=NULL));
+    sc_context_t *ctx=card->ctx;
+    SC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);
+    if (*sm_handler==NULL) {
+        /* not initialized yet: time to do */
+        handler=(dnie_sm_handler_t *) calloc(1,sizeof( dnie_sm_handler_t ));
+        if (handler==NULL) return SC_ERROR_OUT_OF_MEMORY;
+        handler->state=DNIE_SM_NONE;
+        handler->deinit=NULL;
+        handler->encode=NULL;
+        handler->decode=NULL;
+        *sm_handler=(void *) &handler; /* mark pointer as initialized */
+    } else {
+        /* already initialized: take pointer from parameters */
+        handler=(dnie_sm_handler_t *) *sm_handler;
+    }
+    if (handler->state==final_state) {
+        /* already done */
+        SC_FUNC_RETURN(ctx,SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+    }
+    /* call de-init if required*/
+    if ( handler->deinit!=NULL) {
+        result=handler->deinit(card);
+        SC_TEST_RET(ctx,SC_LOG_DEBUG_NORMAL,result,"SM Deinit() failed");
+    }
+    /* now initialize to requested state */
+    switch(final_state) {
+        case DNIE_SM_NONE: 
+            handler->deinit = NULL;
+            handler->encode = NULL;
+            handler->encode = NULL;
+            break;
+        case DNIE_SM_INPROGRESS: /* work in progress; (what about locks?) */
+            SC_FUNC_RETURN(ctx,SC_LOG_DEBUG_NORMAL,SC_ERROR_NOT_ALLOWED);
+        case DNIE_SM_INTERNAL:
+            handler->state=DNIE_SM_INPROGRESS;
+            result = dnie_sm_create_secure_channel(card,handler);
+            if (result!=SC_SUCCESS) goto sm_init_error;
+            break;
+        case DNIE_SM_EXTERNAL:
+            /* TODO: support for remote (SSL) APDU handling */ 
+            SC_FUNC_RETURN(ctx,SC_LOG_DEBUG_NORMAL,SC_ERROR_NOT_SUPPORTED);
+        default:
+            SC_FUNC_RETURN(ctx,SC_LOG_DEBUG_NORMAL,SC_ERROR_INVALID_ARGUMENTS);
+    }
+    /* arriving here means success */
+    handler->state=final_state;
+    SC_FUNC_RETURN(ctx,SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+
+sm_init_error:
+    /* error in init: back into non-sm mode */
+    handler->state=DNIE_SM_NONE;
+    handler->deinit = NULL;
+    handler->encode = NULL;
+    handler->encode = NULL;
+    SC_FUNC_RETURN(ctx,SC_LOG_DEBUG_NORMAL,result);
+}
+
+int dnie_sm_wrap_apdu(struct sc_card *card,/* card data */
+                      dnie_sm_handler_t *sm_handler, /* sm_handler */
+                      struct sc_apdu *from,/* apdu to be parsed */
+                      struct sc_apdu *to,  /* apdu to store result */
+                      int flag             /* 0:SM encode 1:SM decode */
+                      ) {
+    int result=SC_SUCCESS;
+    dnie_sm_handler_t *handler=(dnie_sm_handler_t *) sm_handler;
+    if ( (card==NULL) || (handler==NULL) ) return SC_ERROR_INVALID_ARGUMENTS;
+    if ( (from==NULL) || (to==NULL) ) return SC_ERROR_INVALID_ARGUMENTS;
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    switch (handler->state) {
+      case DNIE_SM_NONE:
+      case DNIE_SM_INPROGRESS:
+         /* just copy structure data */
+         *to=*from; /* implicit memcpy() */
+         SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+      case DNIE_SM_INTERNAL:
+      case DNIE_SM_EXTERNAL:
+         if (flag==0) result = handler->encode(card,from,to);
+         else         result = handler->encode(card,from,to);
+         SC_TEST_RET(card->ctx,SC_LOG_DEBUG_NORMAL,result,"APDU wrap failed");
+         break;
+      default:
+         SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_NORMAL,SC_ERROR_INTERNAL);
+    }
+    SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+}
+
+/* end of secure_messaging.c */
+#undef __SM_DNIE_C__
Index: src/libopensc/apdu.c
===================================================================
--- src/libopensc/apdu.c	(revisión: 4874)
+++ src/libopensc/apdu.c	(copia de trabajo)
@@ -367,6 +367,37 @@
 	}
 }
 
+/*
+ * Wrap/Unwrap APDU when requested before sending to reader driver
+ * Needed (un)wrapping apdu is noticed by a non-null
+ * card->ops->wrap_apdu() function pointer
+ * (eg: for Secure Messaging)
+ *  @param  card  sc_card_t object for the smartcard
+ *  @param  apdu  APDU to be sent
+ *  @return SC_SUCCESS on success and an error value otherwise
+ */
+static int do_wrap_and_transmit(sc_card_t *card, sc_apdu_t *apdu) {
+        int r;
+        sc_context_t *ctx=card->ctx;
+        if (card->ops->wrap_apdu==NULL) {
+                /* no wrap needed, just call reader driver */
+                r=card->reader->ops->transmit(card->reader,apdu);
+        } else {
+                sc_apdu_t wrapped_apdu;
+                /* wrap apdu */
+                r= card->ops->wrap_apdu(card,apdu,&wrapped_apdu,0);
+                SC_TEST_RET(ctx,SC_LOG_DEBUG_NORMAL,r,"wrap() apdu error");
+                /* check wrapped apdu */
+                r= sc_check_apdu(card,&wrapped_apdu);
+                SC_TEST_RET(ctx,SC_LOG_DEBUG_NORMAL,r,"Wrapped apdu is invalid");
+                /* transmit wrapped apdu */
+                r = card->reader->ops->transmit(card->reader, &wrapped_apdu);
+                SC_TEST_RET(ctx,SC_LOG_DEBUG_NORMAL,r,"Unable to transmit wrapped apdu");
+                /* unwrap apdu */
+                r= card->ops->wrap_apdu(card,&wrapped_apdu,apdu,1);
+        }
+        return r;
+}
 
 /** Sends a single APDU to the card reader and calls 
  *  GET RESPONSE to get the return data if necessary.
@@ -380,21 +411,10 @@
 	size_t       olen  = apdu->resplen;
 	sc_context_t *ctx  = card->ctx;
 
-	/* XXX: insert secure messaging here (?), i.e. something like
-	if (card->sm_ctx->use_sm != 0) {
-		r = card->ops->sm_transform(...);
-		if (r != SC_SUCCESS)
-			...
-		r = sc_check_apdu(...);
-		if (r != SC_SUCCESS)
-			...
-	}
-	*/
-
 	/* send APDU to the reader driver */
 	if (card->reader->ops->transmit == NULL)
 		return SC_ERROR_NOT_SUPPORTED;
-	r = card->reader->ops->transmit(card->reader, apdu);
+        r = do_wrap_and_transmit(card,apdu);
 	if (r != 0) {
 		sc_debug(ctx, SC_LOG_DEBUG_NORMAL, "unable to transmit APDU");
 		return r;
@@ -419,7 +439,7 @@
 			if (card->wait_resend_apdu != 0)
 				msleep(card->wait_resend_apdu);
 			/* re-transmit the APDU with new Le length */
-			r = card->reader->ops->transmit(card->reader, apdu);
+                        r = do_wrap_and_transmit(card,apdu);
 			if (r != SC_SUCCESS) {
 				sc_debug(ctx, SC_LOG_DEBUG_NORMAL, "unable to transmit APDU");
 				return r;
Index: src/libopensc/card-dnie.c
===================================================================
--- src/libopensc/card-dnie.c	(revisión: 0)
+++ src/libopensc/card-dnie.c	(revisión: 0)
@@ -0,0 +1,908 @@
+/*
+ * card-dnie.c: Support for Spanish DNI electronico (DNIe card)
+ *
+ * Copyright (C) 2010 Juan Antonio Martinez <jonsito@terra.es>
+ *
+ * This work is derived from many sources at OpenSC Project site,
+ * (see references) and the information made public for Spanish 
+ * Direccion General de la Policia y de la Guardia Civil
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define __CARD_DNIE_C__
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+
+#include "opensc.h"
+#include "cardctl.h"
+#include "internal.h"
+#include "config.h"
+#include "dnie.h"
+
+#ifdef HAVE_LIBASSUAN
+# include <assuan.h>
+/* check for libassuan version */
+# ifndef ASSUAN_No_Error
+#  define HAVE_LIBASSUAN_2
+#  define _gpg_error(t) gpg_error((t))
+# else
+#  define HAVE_LIBASSUAN_1
+#  define _gpg_error(t) assuan_strerror( (AssuanError) (t) )
+# endif
+#endif
+
+#define DNIE_CHIP_NAME "DNIe: Spanish eID card"
+#define DNIE_CHIP_SHORTNAME "dnie"
+
+/* default user consent program (if required) */
+#define USER_CONSENT_CMD "/usr/bin/pinentry"
+
+/* Undeclared dnie APDU responses in iso7816.c */
+static struct sc_card_error dnie_errors[] = {
+    { 0x6688, SC_ERROR_UNKNOWN, "Secure Message value is incorrect" },
+    { 0x6A89, SC_ERROR_FILE_ALREADY_EXISTS, "File/Key already exists" },
+    { 0,0,NULL }
+};
+
+/* ATR Table list */
+static struct sc_atr_table dnie_atrs[] = {
+    /* TODO: get ATR for uninitalized DNIe */
+    {   /* card activated; normal operation state */
+        "3B:7F:00:00:00:00:6A:44:4E:49:65:00:00:00:00:00:00:03:90:00",
+        "FF:FF:00:FF:FF:FF:FF:FF:FF:FF:FF:00:00:00:00:00:00:FF:FF:FF",
+        DNIE_CHIP_SHORTNAME, 
+        SC_CARD_TYPE_DNIE_USER,
+        0,
+        NULL
+    },
+    { /* card finalized, unusable */
+        "3B:7F:00:00:00:00:6A:44:4E:49:65:00:00:00:00:00:00:0F:65:81",
+        "FF:FF:00:FF:FF:FF:FF:FF:FF:FF:FF:00:00:00:00:00:00:FF:FF:FF",
+        DNIE_CHIP_SHORTNAME, 
+        SC_CARD_TYPE_DNIE_TERMINATED,
+        0,
+        NULL
+    },
+    { NULL, NULL, NULL, 0, 0, NULL }
+};
+
+static struct dnie_private_data dnie_priv;
+static struct sc_card_operations dnie_ops;
+static struct sc_card_operations *iso_ops=NULL; 
+
+static sc_card_driver_t dnie_driver  = {
+    DNIE_CHIP_NAME,
+    DNIE_CHIP_SHORTNAME,
+    &dnie_ops,
+    dnie_atrs,
+    0, /* nattrs */
+    NULL /* dll */
+};
+
+/************************** card-dnie.c internal functions ****************/
+
+/**
+ * Parse configuration file for dnie parameters
+ * See opensc.conf for details
+ *@param ctx card context
+ *@param priv pointer to dnie private data
+ *@return SC_SUCCESS (should return no errors)
+ */
+static int dnie_get_environment(sc_context_t *ctx,dnie_private_data_t *priv) {
+    int i;
+    scconf_block **blocks, *blk;
+    for (i = 0; ctx->conf_blocks[i]; i++) {
+        blocks = scconf_find_blocks(ctx->conf, ctx->conf_blocks[i],"card_driver","dnie");
+        if (!blocks) continue;
+        blk=blocks[0];
+        free(blocks);
+        if (blk==NULL) continue;
+        /* fill private data with configuration parameters */
+        priv->user_consent_app = /* def user consent app is "pinentry" */
+            scconf_get_str(blk,"user_consent_app",USER_CONSENT_CMD); 
+        priv->user_consent_enabled = /* user consent is enabled by default */
+            scconf_get_bool(blk,"user_consent_enabled",1);
+    }
+    return SC_SUCCESS;
+}
+
+#ifndef HAVE_LIBASSUAN
+
+/**
+ * Stripped down function for user consent
+ * Will be called instead of real if opensc is compiled without libassuan
+ *@param card pointer to sc_card structure
+ *@return SC_SUCCESS if ok, error code if bad parameters
+ */
+static int ask_user_consent(sc_card_t *card) {
+   if ( (card==NULL) || (card->ctx==NULL)) return SC_ERROR_INVALID_ARGUMENTS;
+   sc_debug(card->ctx,SC_LOG_DEBUG_NORMAL,"Libassuan support is off. User Consent disabled");
+   return SC_SUCCESS;
+}
+
+#else
+
+/**
+ * Ask for user consent on signature operation
+ * Requires libassuan to compile
+ *@param card pointer to sc_card structure
+ *@return SC_SUCCESS if ok, else error code
+ */
+static int ask_user_consent(sc_card_t *card) {
+    int res;
+    const char *argv[3];
+    assuan_fd_t noclosefds[2];
+    assuan_context_t ctx; 
+    if ( (card==NULL) || (card->ctx==NULL)) return SC_ERROR_INVALID_ARGUMENTS;
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    if (dnie_priv.user_consent_enabled==0) {
+        sc_debug(card->ctx,SC_LOG_DEBUG_NORMAL,"User Consent is disabled in configuration file");
+        return SC_SUCCESS;
+    }
+    argv[0]=dnie_priv.user_consent_app;
+    argv[1]=NULL;
+    argv[2]=NULL;
+    noclosefds[0]= fileno(stderr);
+    noclosefds[1]= ASSUAN_INVALID_FD;
+#ifdef HAVE_LIBASSUAN_2
+    res = assuan_new(&ctx);
+    if (res!=0) {
+      sc_debug(card->ctx,SC_LOG_DEBUG_NORMAL,"Can't create the User Consent environment: %s\n",_gpg_error(res));
+      SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_NORMAL,SC_ERROR_INTERNAL);
+    }
+    res = assuan_pipe_connect(ctx,dnie_priv.user_consent_app,argv,noclosefds,NULL,NULL,0);
+#else 
+    res = assuan_pipe_connect(&ctx,dnie_priv.user_consent_app,argv,0);
+#endif
+    if (res!=0) {
+        sc_debug(card->ctx,SC_LOG_DEBUG_NORMAL,"Can't connect to the User Consent module: %s\n",_gpg_error(res));
+        res=SC_ERROR_INVALID_ARGUMENTS; /* invalid or not available pinentry */
+        goto exit;
+    }
+    res = assuan_transact(
+       ctx, 
+       "SETDESC Está a punto de realizar una firma electrónica\n con su clave de FIRMA del DNI electrónico.\n\n¿Desea permitir esta operación?", 
+       NULL, NULL, NULL, NULL, NULL, NULL);
+    if (res!=0) {
+       sc_debug(card->ctx,SC_LOG_DEBUG_NORMAL,"SETDESC: %s\n", _gpg_error(res));
+       res=SC_ERROR_CARD_CMD_FAILED; /* perhaps should use a better errcode */
+       goto exit;
+    }
+    res = assuan_transact(ctx,"CONFIRM",NULL,NULL,NULL,NULL,NULL,NULL);
+#ifdef HAVE_LIBASSUAN_1
+    if (res == ASSUAN_Canceled) {
+       sc_debug(card->ctx,SC_LOG_DEBUG_VERBOSE,"CONFIRM: signature cancelled by user");
+       res= SC_ERROR_NOT_ALLOWED;
+       goto exit;
+    }
+#endif
+    if (res) {
+       sc_debug(card->ctx,SC_LOG_DEBUG_NORMAL,"SETERROR: %s\n",_gpg_error(res));
+       res=SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;
+     } else {
+       res=SC_SUCCESS;
+     }
+exit:
+#ifdef HAVE_LIBASSUAN_2
+    assuan_release(ctx);
+#else
+    assuan_disconnect(ctx);
+#endif
+    SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_NORMAL,res);
+}
+#endif
+
+/**
+ * Select a file from card, process fci and if path is not A DF
+ * read data and store into cache
+ * This is done by mean of iso_select_file() and iso_read_binary()
+ * If path stands for a DNIe certificate, test for uncompress data
+ *@param card pointer to sc_card data
+ *@param path pathfile
+ *@param file pointer to resulting file descriptor
+ *@param buffer pointer to buffer where to store file contents
+ *@param length length of buffer data
+ *@return SC_SUCCESS if ok; else error code
+ */
+int dnie_read_file(
+        sc_card_t *card,
+        const sc_path_t *path,
+        sc_file_t **file,
+        u8 **buffer,
+        size_t *length
+        ) {
+    u8 *data;
+    int res = SC_SUCCESS;
+    assert( (card!=NULL) && (card->ctx!=NULL) && (path!=NULL) );
+    sc_context_t *ctx= card->ctx;
+    SC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);
+    if (!buffer && !length) /* check received arguments */
+        SC_FUNC_RETURN(ctx,SC_LOG_DEBUG_VERBOSE,SC_ERROR_INVALID_ARGUMENTS);
+    /* try to adquire lock on card */
+    res=sc_lock(card);
+    SC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, res, "sc_lock() failed");
+    /* select file by mean of iso7816 ops */
+    res=iso_ops->select_file(card,path,file);
+    if (res!=SC_SUCCESS) goto dnie_read_file_err;
+    /* iso's select file calls if needed process_fci, so arriving here
+     * we have file structure filled.
+     */
+    if ((*file)->type==SC_FILE_TYPE_DF) {
+        /* just a DF, no need to read_binary() */
+        *buffer=NULL;
+        *length=0;
+        res=SC_SUCCESS;
+        goto dnie_read_file_end;
+    }
+    /* reserve enought space to read data from card*/
+    if((*file)->size <= 0) {
+        res = SC_ERROR_FILE_TOO_SMALL;
+        goto dnie_read_file_err;
+    }
+    data=calloc((*file)->size,sizeof(u8));
+    if (data==NULL) {
+        res = SC_ERROR_OUT_OF_MEMORY;
+        goto dnie_read_file_err;
+    }
+    /* call iso7816 read_binary() to retrieve data */
+    res=iso_ops->read_binary(card,0,data,(*file)->size,0L);
+    if (res<0) { /* read_binary returns number of bytes readed */
+        res = SC_ERROR_CARD_CMD_FAILED;
+        goto dnie_read_file_err;
+    }
+    *buffer=data;
+    *length=res;
+    /* now check if needed to uncompress data */
+    /* TODO: dnie_read_file() check if uncompress data is required */
+    /* arriving here means success */
+    res=SC_SUCCESS;
+    goto dnie_read_file_end;
+dnie_read_file_err:
+    if (*file) sc_file_free(*file);
+dnie_read_file_end:
+    sc_unlock(card);
+    SC_FUNC_RETURN(ctx,SC_LOG_DEBUG_NORMAL,res);
+}
+
+/************************** cardctl defined operations *******************/
+
+/* 
+ * Manual says that generate_keys() is a reserved operation; that is: 
+ * only can be done at DGP offices. But several authors talks about 
+ * this operation is available also outside. So need to test :-)
+ * Notice that write operations are not supported, so we can't use 
+ * created keys to generate and store new certificates into the card.
+ * TODO: copy code from card-jcop.c::jcop_generate_keys()
+ */
+static int dnie_generate_key(sc_card_t *card, void *data) {
+    if ( (card==NULL) || (data==NULL) ) return SC_ERROR_INVALID_ARGUMENTS;
+    int result=SC_ERROR_NOT_SUPPORTED;
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    /* TODO: write dnie_generate_key() */
+    SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_VERBOSE,result);
+}
+
+/**
+ * Retrieve serial number (7 bytes) from card
+ *@param card pointer to card description
+ *@param serial where to store data retrieved
+ *@return SC_SUCCESS if ok; else error code
+ */
+static int dnie_get_serialnr(sc_card_t *card, sc_serial_number_t *serial) {
+    int result;
+    sc_apdu_t apdu;
+    u8        rbuf[SC_MAX_APDU_BUFFER_SIZE];
+    /* 
+     * TODO: get_serialnr() this function seems to be duplicated 
+     * on many cards, just variyng sent APDU. Look for integration
+     */
+    if ( (card==NULL) || (serial==NULL) ) return SC_ERROR_INVALID_ARGUMENTS;
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    if (card->type!=SC_CARD_TYPE_DNIE_USER) return SC_ERROR_NOT_SUPPORTED;
+    /* if serial number is cached, use it */
+    if (card->serialnr.len) {
+        memcpy(serial, &card->serialnr, sizeof(*serial));
+        return SC_SUCCESS;
+    }
+    /* not cached, retrieve it by mean of an APDU */
+    sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xb8, 0x00, 0x00);
+    apdu.cla = 0x90;
+    apdu.resp = rbuf;
+    apdu.resplen = sizeof(rbuf);
+    apdu.le   = 0x11;
+    apdu.lc   = 0;
+    apdu.datalen = 0;
+    /* send apdu */
+    result=sc_transmit_apdu(card,&apdu);
+    SC_TEST_RET(card->ctx,SC_LOG_DEBUG_NORMAL,result,"APDU transmit failed");
+    if (apdu.sw1 != 0x90 || apdu.sw2 != 0x00) return SC_ERROR_INTERNAL;
+    /* cache serial number */
+    /* According to doc only first seven bytes from response are meaningfull */
+    memcpy(card->serialnr.value, apdu.resp, 7*sizeof(u8));
+    card->serialnr.len = 7*sizeof(u8);
+    /* copy and return serial number */
+    memcpy(serial, &card->serialnr, sizeof(*serial));
+    return SC_SUCCESS;
+}
+
+/**************************** sc_card_operations **********************/
+
+/* Generic operations */
+
+/* Called in sc_connect_card().  Must return 1, if the current
+ * card can be handled with this driver, or 0 otherwise.  ATR
+ * field of the sc_card struct is filled in before calling
+ * this function. */
+static int dnie_match_card(struct sc_card *card){
+    int result=0;
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    int matched=_sc_match_atr(card,dnie_atrs,&card->type);
+    result=(matched>=0)? SC_SUCCESS:SC_ERROR_NO_CARD_SUPPORT;
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,result);
+}
+
+/* Called when ATR of the inserted card matches an entry in ATR
+ * table.  May return SC_ERROR_INVALID_CARD to indicate that
+ * the card cannot be handled with this driver. */
+static int dnie_init(struct sc_card *card){
+    int result=SC_SUCCESS;
+    assert(card!=NULL);
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+    /* if recognized as terminated DNIe card, return error */
+    if (card->type==SC_CARD_TYPE_DNIE_TERMINATED) {
+       card->drv_data = NULL;
+       result = SC_ERROR_MEMORY_FAILURE;
+       goto dnie_init_error;
+    }
+
+    /* initialize private data */
+    memset(&dnie_priv,0,sizeof(dnie_private_data_t));
+
+    /* read environment from configuration file */
+    result=dnie_get_environment(card->ctx,&dnie_priv);
+    if (result!=SC_SUCCESS) goto dnie_init_error;
+
+    /* initialize SM to none */
+    result=dnie_sm_init(card,&dnie_priv.sm_handler,DNIE_SM_NONE);
+    if (result!=SC_SUCCESS) goto dnie_init_error;
+    card->drv_data=&dnie_priv;
+     
+    /* set up flags according documentation */
+    card->name = DNIE_CHIP_SHORTNAME;
+    card->cla  = 0x00; // card uses default APDU class (interindustry)
+    card->caps |=SC_CARD_CAP_RNG; /* we have a random number generator */
+    card->max_send_size=256;
+    card->max_recv_size=256;
+
+    unsigned long algoflags = SC_ALGORITHM_RSA_RAW; /* RSA support */
+    algoflags    |= SC_ALGORITHM_RSA_HASH_NONE;
+    _sc_card_add_rsa_alg(card,1024,algoflags,0);
+    _sc_card_add_rsa_alg(card,2048,algoflags,0);
+    
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+dnie_init_error:
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL,result);
+}
+
+/* Called when the card object is being freed.  finish() has to
+ * deallocate all possible private data. */
+static int dnie_finish(struct sc_card *card) {
+    int result=SC_SUCCESS;
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    /* disable sm channel if stablished */
+    dnie_sm_init(card, &dnie_priv.sm_handler, DNIE_SM_NONE);
+    /* free any cached data */
+    dnie_file_cache_t *pt=dnie_priv.cache_top;
+    while(pt!=NULL) {
+        dnie_file_cache_t *next=pt->next;
+	if (!pt->file) sc_file_free(pt->file);
+        if (!pt->data) free(pt->data);
+        free(pt);
+        pt=next;
+    }
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,result);
+}
+
+/* Called before invoke card_driver->ops->transmit.
+ * for performing APDU wrap(flag=0) or unwrap(flag=1)
+ * If set to NULL no wrapping process will be done
+ * Usefull on Secure Messaging APDU encode/decode
+ * Returns SC_SUCCESS or error code */
+static int dnie_wrap_apdu(sc_card_t *card, sc_apdu_t *from,sc_apdu_t *to,int flag) {
+    int res=SC_SUCCESS;
+    assert( (card!=NULL) && (from!=NULL) && (to!=NULL) );
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    if (dnie_priv.sm_handler==NULL) { /* not initialized yet: time to do */
+        res=dnie_sm_init(card,&dnie_priv.sm_handler,DNIE_SM_NONE);
+        if (res!=SC_SUCCESS) SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_NORMAL,res);
+    }
+    /* encode/decode apdu */
+    res=dnie_sm_wrap_apdu(card,dnie_priv.sm_handler,from,to,flag);
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,res);
+}
+
+/* ISO 7816-4 functions */
+
+static int dnie_read_binary(struct sc_card *card, 
+                       unsigned int idx,
+                       u8 * buf,
+                       size_t count,
+                       unsigned long flags){
+    int result=SC_SUCCESS;
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    /* TODO: dnie_read_binary: detect and use cache */
+    /* data is not cached: use std iso function */
+    result=iso_ops->read_binary(card,idx,buf,count, flags);
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,result);
+}
+
+/* select_file: Does the equivalent of SELECT FILE command specified
+ *   in ISO7816-4. Stores information about the selected file to
+ *   <file>, if not NULL. */
+static int dnie_select_file(struct sc_card *card,
+                       const struct sc_path *path,
+                       struct sc_file **file_out){
+    int result=SC_SUCCESS;
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    /* Manual says that some special paths store data in compressed
+     * format. So trap those paths, and perform file_read() & uncompress.
+     * in that way next read_binary call will use catched data */
+    /* find file in cache */
+    dnie_file_cache_t *pt=dnie_priv.cache_top;
+    for (; pt!=NULL; pt=pt->next) {
+        if (!sc_compare_path(path,&(pt->file->path))) continue;
+        /* file found in cache */
+        dnie_priv.cache_pt=pt;
+        *file_out=pt->file;
+        SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+    }
+    /* arriving here means file is not in cache: read and store */
+    /* create a new cache entry */
+    dnie_file_cache_t *cache=
+        (dnie_file_cache_t *)calloc(1,sizeof(dnie_file_cache_t));
+    if (cache==NULL) {
+        result=SC_ERROR_OUT_OF_MEMORY;
+        goto select_file_error;
+    }
+    /* allocate a new file entry */
+    cache->file=sc_file_new();
+    if (cache->file==NULL) {
+        result=SC_ERROR_OUT_OF_MEMORY;
+        goto select_file_error;
+    } 
+    /* do file read */
+    result=dnie_read_file(card,path,&cache->file,&cache->data,&cache->datalen);
+    if (result!=SC_SUCCESS) goto select_file_error;
+    /* add entry at the begining of cache list */
+    cache->next=dnie_priv.cache_top;
+    dnie_priv.cache_top=cache;
+    dnie_priv.cache_pt=cache;
+    /* and set up return values */
+    *file_out=cache->file;
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL,SC_SUCCESS);
+select_file_error:
+    if (cache && cache->file) sc_file_free(cache->file);
+    if (cache) free(cache);
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL,result);
+}
+
+static int dnie_get_challenge(struct sc_card *card,
+                         u8 * buf,
+                         size_t count){
+    int result=SC_SUCCESS;
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    /* TODO: _get_challenge() write */
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,result);
+}
+
+/*
+ * ISO 7816-8 functions
+ */
+
+/* logout: Resets all access rights that were gained. */
+static int dnie_logout(struct sc_card *card){
+    assert(card && card->ctx);
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    /* disable and free any sm channel related data */
+    int result=dnie_sm_init(card,&dnie_priv.sm_handler,DNIE_SM_NONE);
+    /* TODO: _logout() see comments.txt on what to do here */
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,result);
+}
+
+/* set_security_env:  Initializes the security environment on card
+ *   according to <env>, and stores the environment as <se_num> on the
+ *   card. If se_num <= 0, the environment will not be stored. */
+static int dnie_set_security_env(struct sc_card *card,
+                                const struct sc_security_env *env, 
+                                int se_num){
+    sc_apdu_t apdu;
+    int result=SC_SUCCESS;
+    if ( (card==NULL) || (env==NULL) ) 
+      SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_VERBOSE,SC_ERROR_INVALID_ARGUMENTS);
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    /* check algorithms and keys */
+    if (env->flags & SC_SEC_ENV_ALG_REF_PRESENT) {
+      /* TODO: _set_security_env() revise algoritms. 
+       * Manual says that only RSA with SHA1 is supported, but found
+       * some docs where states that SHA256 is also handled
+       */
+    }
+    if (env->flags & SC_SEC_ENV_KEY_REF_PRESENT) {
+      /* TODO: _set_security_env() check key id reference */
+    }
+    /* check and perform operation */
+    switch (env->operation) {
+      case SC_SEC_OPERATION_DECIPHER:
+        /* TODO: _set_security_env() revise if decipher() is supported
+        * not sure if supported: DGP's driver implements nonstandard
+        * decipher() function. Assumed here standard is supported too
+        */
+        sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0x22,0xC1,0xB8);
+        /* TODO: _set_security_env() fill decipher() apdu data */
+        break;
+      case SC_SEC_OPERATION_SIGN:
+        sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0x22,0x81,0xB6);
+        /* TODO: _set_security_env() fill signature() apdu data */
+        break;
+      case SC_SEC_OPERATION_AUTHENTICATE:
+        /* TODO: _set_security_env() study diffs on internal/external auth */
+        sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0x22,0xC1,0xA4);
+        /* TODO: _set_security_env() fill authenticate() apdu data */
+        break;
+      default:
+        SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_VERBOSE,SC_ERROR_INVALID_ARGUMENTS);
+    }
+    /* send composed apdu and retrieve result */
+    result=sc_transmit_apdu(card,&apdu);
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,result);
+}
+
+/* decipher:  Engages the deciphering operation.  Card will use the
+ *   security environment set in a call to set_security_env or
+ *   restore_security_env. */
+static int dnie_decipher(struct sc_card *card, 
+                         const u8 * crgram,
+                         size_t crgram_len, 
+                         u8 * out,
+                         size_t outlen){
+    int result=SC_SUCCESS;
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    /* TODO: _decipher() write */
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,result);
+}
+
+/* compute_signature:  Generates a digital signature on the card.  Similiar
+ *   to the function decipher. */
+static int dnie_compute_signature(struct sc_card *card,
+                                   const u8 * data,
+                                   size_t datalen,
+                                   u8 * out,
+                                   size_t outlen){
+    int result=SC_SUCCESS;
+    struct sc_apdu apdu;
+    u8 rbuf[SC_MAX_APDU_BUFFER_SIZE];
+    u8 sbuf[SC_MAX_APDU_BUFFER_SIZE];
+ 
+    /* some preliminar checks */
+    if ((card==NULL) || (data==NULL) || (out==NULL))
+      SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL,SC_ERROR_INVALID_ARGUMENTS);
+    if (datalen > SC_MAX_APDU_BUFFER_SIZE || outlen > SC_MAX_APDU_BUFFER_SIZE)
+      SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL,SC_ERROR_BUFFER_TOO_SMALL);
+
+    /* OK: start working */
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    /* ensure that secure channel is stablished */
+    result=dnie_sm_init(card,&dnie_priv.sm_handler,DNIE_SM_INTERNAL);
+    if (result!=SC_SUCCESS) goto signature_error;
+    /* (Requested by DGP): on signature operation, ask user consent */
+    if (dnie_priv.rsa_key_ref==0x02) { /* TODO: revise key ID handling */
+        result=ask_user_consent(card);
+        if (result!=SC_SUCCESS) goto signature_error;
+    }
+    /* TODO _compute_signature(): handle separate hash process
+       Manual says that dnie card can do hashing operations
+       Some cards take care on this and compute hash before signing
+       So in a further dev stage, we should take check data
+       content type (plain, partial, hash) and process it
+     */
+
+    memset(&apdu,0,sizeof(struct sc_apdu)); /* clear data */
+    memcpy(sbuf,data,datalen); /* copy data to buffer */
+    /* compose apdu */
+    /* INS: 0x2A  PERFORM SECURITY OPERATION
+     * P1:  0x9E  Resp: Digital Signature
+     * P2:  0x9A  Cmd: Input for Digital Signature */
+    sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x9E, 0x9A);
+    apdu.resp = rbuf;
+    apdu.resplen = sizeof(rbuf);
+    apdu.le = outlen;
+    
+    apdu.data = sbuf;
+    apdu.lc = datalen;
+    apdu.datalen = datalen;
+    /* tell card to compute signature */
+    result = sc_transmit_apdu(card, &apdu);
+    SC_TEST_RET(card->ctx,SC_LOG_DEBUG_NORMAL,result,"APDU transmit failed");
+    /* check response */
+    result=sc_check_sw(card,apdu.sw1,apdu.sw2);
+    if (result!=SC_NO_ERROR) goto signature_error;
+    memcpy(out,rbuf,outlen); /* copy result from buffer */
+    /* and return response length */
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL,apdu.resplen);
+signature_error:
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,result);
+}
+
+/*
+ * ISO 7816-9 functions
+ */
+
+/**
+ * parse APDU results
+ */
+static int dnie_check_sw(struct sc_card *card,
+                         unsigned int sw1,
+                         unsigned int sw2){
+    int res=SC_SUCCESS;
+    int n=0;
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    /* check specific dnie errors */
+    for( n=0; dnie_errors[n].SWs!=0; n++) {
+      if (dnie_errors[n].SWs == ((sw1 << 8) | sw2)) {
+        sc_debug(card->ctx,SC_LOG_DEBUG_NORMAL,"%s",dnie_errors[n].errorstr);
+        return dnie_errors[n].errorno;
+      }
+    }
+    /* arriving here means check for supported iso error codes */
+    res=iso_ops->check_sw(card,sw1,sw2);
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,res);
+}
+
+static int dnie_card_ctl(struct sc_card *card,
+                         unsigned long request,
+                         void *data){
+    int result=SC_SUCCESS;
+    if ( card==NULL) return SC_ERROR_INVALID_ARGUMENTS;
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+    if ( data==NULL) {
+        SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL,SC_ERROR_INVALID_ARGUMENTS); 
+    }
+    switch(request) {
+        /* obtain lifecycle status by reading card->type */
+        case SC_CARDCTL_LIFECYCLE_GET:
+           switch (card->type) {
+               case SC_CARD_TYPE_DNIE_ADMIN: 
+                    result = SC_CARDCTRL_LIFECYCLE_ADMIN; break;
+               case SC_CARD_TYPE_DNIE_USER :
+                    result = SC_CARDCTRL_LIFECYCLE_USER; break;
+               case SC_CARD_TYPE_DNIE_TERMINATED:
+                    result = SC_CARDCTRL_LIFECYCLE_OTHER; break;
+           }
+           *(int*)data=result;
+           SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+        /* call card to obtain serial number */
+        case SC_CARDCTL_GET_SERIALNR:
+           result=dnie_get_serialnr(card, (sc_serial_number_t *) data);
+           SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_VERBOSE,result);
+        case SC_CARDCTL_DNIE_GENERATE_KEY:
+           /* some reports says that this card supports genkey */
+           result=dnie_generate_key(card,data);
+           SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_VERBOSE,result);
+        default:
+           /* default: unsupported function */
+           SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_NORMAL,SC_ERROR_NOT_SUPPORTED);
+    }
+}
+
+static int dnie_process_fci(struct sc_card *card,
+                            struct sc_file *file,
+                            const u8 *buf,
+                            size_t buflen){
+    int res=SC_SUCCESS;
+    if ((card==NULL) || (card->ctx==NULL) || (file==NULL)) return SC_ERROR_INVALID_ARGUMENTS;
+    sc_context_t *ctx=card->ctx;
+    SC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);
+    /* first of all, let iso do the hard work */
+    res = iso_ops -> process_fci(card,file,buf,buflen);
+    SC_TEST_RET(ctx,SC_LOG_DEBUG_NORMAL,res,"iso7816_process_fci() failed");
+    /* if tag 0x85 is received, then file->prop_attr_len should be filled
+     * by sc_file_set_prop_attr() code. So check and set data according manual 
+     * Note errata at pg 35 of Manual  about DF identifier (should be 0x38) */
+    if(file->prop_attr_len==0) { /* no 0x85 tag received */
+        res=SC_SUCCESS;
+        goto dnie_process_fci_end;
+    }
+    /* byte 1 denotes file type */
+    switch(file->prop_attr[0]) {
+        case 0x01:
+            file->type = SC_FILE_TYPE_WORKING_EF;
+            file->ef_structure = SC_FILE_EF_TRANSPARENT;
+            break;
+        case 0x15:
+            file->type = SC_FILE_TYPE_WORKING_EF;
+            break;
+        case 0x38: /* Errata: manual page 35 says wrong 0x34 */
+            file->type = SC_FILE_TYPE_DF;
+            break;
+        default: 
+            res=SC_ERROR_UNKNOWN_DATA_RECEIVED;
+            goto dnie_process_fci_end;
+    }
+    /* bytes 2 and 3 stores file ID */
+    file->id = (file->prop_attr[1] << 8) | file->prop_attr[2];
+    /* bytes 4 and 5 states file length */
+    file->size = (file->prop_attr[3] << 8) | file->prop_attr[4];
+    /* bytes 6 to 10 states security information */
+    /* TODO: _process_fci() parse sec info write */
+
+dnie_process_fci_end:
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,res);
+}
+
+/* pin_cmd: verify/change/unblock command; optionally using the
+ * card's pin pad if supported.
+ */
+static int dnie_pin_cmd(struct sc_card * card,
+                        struct sc_pin_cmd_data * data,
+                        int *tries_left){
+    int res=SC_SUCCESS;
+    sc_apdu_t apdu;
+
+    u8 pinbuffer[SC_MAX_APDU_BUFFER_SIZE];
+    int pinlen=0;
+    int padding=0;
+
+    if ( (card==NULL) || (data==NULL) ) 
+       SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_NORMAL,SC_ERROR_INVALID_ARGUMENTS);
+    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+    /* some flags and settings from documentation */
+    data->flags &= ~SC_PIN_CMD_NEED_PADDING; /* no pin padding */
+    data->apdu = &apdu; /* prepare apdu struct */
+
+    /* ensure that secure channel is established */
+    res=dnie_sm_init(card,&dnie_priv.sm_handler,DNIE_SM_INTERNAL);
+    if (res!=SC_SUCCESS) SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_NORMAL,res);
+
+    /* TODO: _pin_cmd() ensure that card is in USER Lifecycle */
+    /* TODO: _pin_cmd() what about pinpad support? */
+
+    /* only allow changes on CHV pin ) */
+    switch (data->pin_type) {
+      case SC_AC_CHV:  /* Card Holder Verifier */ break;
+      case SC_AC_TERM: /* Terminal auth */
+      case SC_AC_PRO:  /* SM auth */
+      case SC_AC_AUT:  /* Key auth */
+        SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_NORMAL,SC_ERROR_NOT_SUPPORTED);
+      default: 
+        SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_NORMAL,SC_ERROR_INVALID_ARGUMENTS);
+    }
+    /* This DNIe driver only supports VERIFY operation */
+    switch (data->cmd) {
+      case SC_PIN_CMD_VERIFY: break;
+      case SC_PIN_CMD_CHANGE:
+      case SC_PIN_CMD_UNBLOCK:
+      case SC_PIN_CMD_GET_INFO:
+        SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_NORMAL,SC_ERROR_NOT_SUPPORTED);
+      default: 
+        SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_NORMAL,SC_ERROR_INVALID_ARGUMENTS);
+    }
+    /* Arriving here means that's all checks are OK. So do task */
+
+    /* compose pin data to be inserted in apdu*/
+    if (data->flags & SC_PIN_CMD_NEED_PADDING) padding=1;
+    data->pin1.offset=0;
+    res=sc_build_pin(pinbuffer,sizeof(pinbuffer),&data->pin1,padding);
+    if (res<0) SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_NORMAL,res);
+    pinlen=res;
+
+    /* compose apdu */
+    memset(&apdu, 0, sizeof(apdu)); /* clear buffer */
+    apdu.cla = 0x00;
+    apdu.cse = SC_APDU_CASE_3_SHORT;
+    apdu.ins = (u8) 0x20; /* Verify cmd */
+    apdu.p1 = (u8) 0x00;
+    apdu.p2 = (u8) 0x00;
+    apdu.lc = pinlen;
+    apdu.datalen = pinlen;
+    apdu.data = pinbuffer;
+    apdu.resplen = 0;
+    apdu.le = 0;
+
+    /* and send to card throught virtual channel */
+    res=sc_transmit_apdu(card,&apdu);
+    SC_TEST_RET(card->ctx,SC_LOG_DEBUG_NORMAL,res,"VERIFY APDU Transmit fail");
+    
+    /* check response and if requested setup tries_left */
+    if (tries_left!=NULL) { /* returning tries_left count is requested */
+      if ( (apdu.sw1==0x63) && ((apdu.sw2 & 0xF0)==0xC0) ) {
+        *tries_left=apdu.sw2&0x0F;
+        SC_FUNC_RETURN(card->ctx,SC_LOG_DEBUG_VERBOSE,SC_ERROR_PIN_CODE_INCORRECT);
+      }
+    }
+    res=dnie_check_sw(card,apdu.sw1,apdu.sw2); /* not a pinerr: parse result */
+ 
+    /* the end: a bit of Mister Proper and return */
+    memset(&apdu, 0, sizeof(apdu)); /* clear buffer */
+    data->apdu = NULL;
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,res);
+}
+
+/**********************************************************************/
+
+static sc_card_driver_t *get_dnie_driver(void) {
+    sc_card_driver_t *iso_drv = sc_get_iso7816_driver();
+
+    /* memcpy() from standard iso7816 declared operations */
+    if (iso_ops == NULL) iso_ops   = iso_drv->ops;
+    dnie_ops                       = *iso_drv->ops;
+
+    /* fill card specific function pointers */
+    /* if pointer is omitted, default ISO7816 function will be used */
+
+    /* initialization */
+    dnie_ops.match_card            = dnie_match_card;
+    dnie_ops.init                  = dnie_init;
+    dnie_ops.finish                = dnie_finish;
+    dnie_ops.wrap_apdu             = dnie_wrap_apdu;
+
+    /* iso7816-4 functions */
+    dnie_ops.read_binary           = dnie_read_binary;
+    /* dnie_ops.write_binary */
+    /* dnie_ops.update_binary */
+    /* dnie_ops.erase_binary */
+    /* dnie_ops.read_record */
+    /* dnie_ops.write_record */
+    /* dnie_ops.append_record */
+    /* dnie_ops.update_record */
+    dnie_ops.select_file           = dnie_select_file;
+    /* dnie_ops.get_response */
+    dnie_ops.get_challenge         = dnie_get_challenge;
+
+    /* iso7816-8 functions */
+    /* dnie_ops.verify */
+    dnie_ops.logout                = dnie_logout;
+    /* dnie_ops.restore_security_env */
+    dnie_ops.set_security_env      = dnie_set_security_env; 
+    dnie_ops.decipher              = dnie_decipher;
+    dnie_ops.compute_signature     = dnie_compute_signature;
+    /* dnie_ops.change_reference_data */
+    /* dnie_ops.reset_retry_counter */
+
+    /* iso7816-9 functions */
+    dnie_ops.create_file           = NULL; /* not allowed on DNIe user mode*/
+    dnie_ops.delete_file           = NULL;
+    /* dnie_ops.list_files */
+    dnie_ops.check_sw              = dnie_check_sw;
+    dnie_ops.card_ctl              = dnie_card_ctl; 
+    dnie_ops.process_fci           = dnie_process_fci;
+    /* dnie_ops.construct_fci */
+    dnie_ops.pin_cmd               = dnie_pin_cmd;
+    /* dnie_ops.get_data */
+    /* dnie_ops.put_data */
+    /* dnie_ops.delete_record */
+
+    return &dnie_driver;
+}
+
+sc_card_driver_t * sc_get_dnie_driver(void) {
+    return get_dnie_driver();
+}
+
+#undef __CARD_DNIE_C__
Index: src/libopensc/Makefile.am
===================================================================
--- src/libopensc/Makefile.am	(revisión: 4874)
+++ src/libopensc/Makefile.am	(copia de trabajo)
@@ -9,12 +9,12 @@
 	internal-winscard.h p15card-helper.h \
 	opensc.h pkcs15.h \
 	cardctl.h asn1.h log.h \
-	errors.h types.h compression.h itacns.h
+	errors.h types.h compression.h itacns.h dnie.h
 
 AM_CPPFLAGS = -DOPENSC_CONF_PATH=\"$(sysconfdir)/opensc.conf\"
 AM_CFLAGS = $(OPTIONAL_OPENSSL_CFLAGS) $(OPTIONAL_OPENCT_CFLAGS) \
 	$(OPTIONAL_PCSC_CFLAGS) $(OPTIONAL_ZLIB_CFLAGS) \
-	$(LTLIB_CFLAGS)
+	$(LIBASSUAN_CFLAGS) $(LTLIB_CFLAGS)
 INCLUDES = -I$(top_srcdir)/src
 
 libopensc_la_SOURCES = \
@@ -37,7 +37,7 @@
 	card-incrypto34.c card-piv.c card-muscle.c card-acos5.c \
 	card-asepcos.c card-akis.c card-gemsafeV1.c card-rutoken.c \
 	card-rtecp.c card-westcos.c card-myeid.c card-ias.c \
-	card-javacard.c card-itacns.c \
+	card-javacard.c card-itacns.c card-dnie.c sm-dnie.c \
 	\
 	pkcs15-openpgp.c pkcs15-infocamere.c pkcs15-starcert.c \
 	pkcs15-tcos.c pkcs15-esteid.c pkcs15-postecert.c pkcs15-gemsafeGPK.c \
@@ -50,7 +50,7 @@
 libopensc_la_SOURCES += $(top_builddir)/win32/versioninfo.rc
 endif
 libopensc_la_LIBADD = $(OPTIONAL_OPENSSL_LIBS) $(OPTIONAL_OPENCT_LIBS) \
-	$(OPTIONAL_ZLIB_LIBS) $(LTLIB_LIBS) \
+	$(OPTIONAL_ZLIB_LIBS) $(LIBASSUAN_LIBS) $(LTLIB_LIBS) \
 	$(top_builddir)/src/pkcs15init/libpkcs15init.la \
 	$(top_builddir)/src/scconf/libscconf.la \
 	$(top_builddir)/src/common/libcompat.la
Index: src/libopensc/opensc.h
===================================================================
--- src/libopensc/opensc.h	(revisión: 4874)
+++ src/libopensc/opensc.h	(copia de trabajo)
@@ -417,6 +417,13 @@
 	/* Called when the card object is being freed.  finish() has to
 	 * deallocate all possible private data. */
 	int (*finish)(struct sc_card *card);
+        /* Called before invoke card_driver->ops->transmit.
+         * for performing APDU wrap(flag=0) or unwrap(flag=1)
+         * If set to NULL no wrapping process will be done
+         * Usefull on Secure Messaging APDU encode/decode
+         * Returns SC_SUCCESS or error code */
+        int (*wrap_apdu)(struct sc_card *card,
+                         struct sc_apdu *from, struct sc_apdu *to, int flag);
 
 	/* ISO 7816-4 functions */
 
Index: configure.ac
===================================================================
--- configure.ac	(revisión: 4874)
+++ configure.ac	(copia de trabajo)
@@ -481,6 +481,14 @@
 	AC_DEFINE([ENABLE_PCSC], [1], [Define if PC/SC is to be enabled])
 fi
 
+dnl AM_PATH_LIBASSUAN([MINIMUM-VERSION,
+dnl                   [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND ]]])
+dnl Test for libassuan and define LIBASSUAN_CFLAGS and LIBASSUAN_LIBS
+AM_PATH_LIBASSUAN(
+        1.0.0,
+        [AC_DEFINE([HAVE_LIBASSUAN],[1],[Define if you have ASSUAN libraries and header files])]
+)
+
 if test "${enable_man}" = "detect"; then
 	if test "${WIN32}" = "yes"; then
 		enable_man="no"
@@ -643,6 +651,8 @@
 OPENCT_CFLAGS:           ${OPENCT_CFLAGS}
 OPENCT_LIBS:             ${OPENCT_LIBS}
 PCSC_CFLAGS:             ${PCSC_CFLAGS}
+LIBASSUAN_CFLAGS:        ${LIBASSUAN_CFLAGS}
+LIBASSUAN_LIBS:          ${LIBASSUAN_LIBS}
 
 EOF
 
Index: etc/opensc.conf.in
===================================================================
--- etc/opensc.conf.in	(revisión: 4874)
+++ etc/opensc.conf.in	(copia de trabajo)
@@ -112,6 +112,14 @@
 		# module = /usr/lib/opensc/drivers/card_customcos.so;
 	# }
 
+        # Special configuration data for dnie card driver
+        # card_driver dnie {
+        #       # Enable/Disable user consent on signing (default: enable)
+        #       user_consent_enabled = true;
+        #       # Program to be used for ask confirmation (default: pinentry)
+        #       user_consent_app = /usr/bin/pinentry;
+        # }
+        #
 	# Force using specific card driver
 	#
 	# If this option is present, OpenSC will use the supplied
