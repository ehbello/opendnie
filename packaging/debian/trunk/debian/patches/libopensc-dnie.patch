Index: opensc-0.11.12/src/libopensc/dnie/Makefile.am
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/Makefile.am	2010-11-17 19:14:03.000000000 +0000
@@ -0,0 +1,45 @@
+# Process this file with automake to create Makefile.in
+
+includedir = @includedir@/opensc
+
+MAINTAINERCLEANFILES = Makefile.in
+
+AM_CFLAGS = $(OPTIONAL_OPENSSL_CFLAGS) $(LIBASSUAN_CFLAGS) $(LTLIB_CFLAGS)
+INCLUDES = -I$(top_srcdir)/src -I$(top_srcdir)/src/include
+
+c_sources = \
+        util.c \
+        map.c \
+        map_helper.c \
+        pkcs15_default.c \
+        pkcs15_standard.c \
+        base_card.c \
+        virtual_fs.c \
+        virtual_pkcs15_fs.c \
+        card_sync.c \
+        card_helper.c \
+        file_compression.c \
+	trusted_channel_card.c \
+        dialog.c
+
+h_sources = \
+        card_structures.h \
+        util.h \
+        map.h \
+        map_helper.h \
+        base_card.h \
+        pkcs15_default.h \
+        pkcs15_standard.h \
+        virtual_fs.h \
+        virtual_pkcs15_fs.h \
+        card_sync.h \
+        card_helper.h \
+        file_compression.h 
+
+noinst_LTLIBRARIES = libdniecard.la
+
+libdniecard_la_SOURCES = \
+        $(h_sources) \
+        $(c_sources)
+
+libdniecard_la_LIBADD = $(OPENSSL_LIBS) $(LIBASSUAN_LIBS)
Index: opensc-0.11.12/src/libopensc/dnie/base_card.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/base_card.c	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,1442 @@
+/*
+ * base_card.c: Support for DNI-e card 
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+*/
+
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <zlib.h>
+#include <libopensc/internal.h> 
+#include <opensc/opensc.h>
+#include <opensc/cardctl.h>
+#include <opensc/log.h>
+#include <opensc/asn1.h>
+#include <opensc/pkcs15.h>
+#include "base_card.h"
+#include "pkcs15_default.h"
+#include "pkcs15_standard.h"
+#include "util.h"
+#include "virtual_fs.h"
+#include "virtual_pkcs15_fs.h"
+#include "card_sync.h"
+
+static struct sc_atr_table card_atrs[] = {
+  /* ATR DNIe perso 1.0 */
+  /*  { "3B:7F:38:00:00:00:6A:44:4E:49:65:10:02:4C:34:01:10:03:90:00", NULL, DNIE_CHIP_NAME , SC_CARD_TYPE_DNIE, 0, NULL } */
+  {
+    "3B:7F:00:00:00:00:6A:44:4E:49:65:00:00:00:00:00:00:00:90:00",
+    "FF:FF:00:FF:FF:FF:FF:FF:FF:FF:FF:00:00:00:00:00:00:00:FF:FF",
+    CARD_CHIP_NAME, 
+    SC_CARD_TYPE_DNIE_USER,
+    0,
+    NULL
+  },
+  { /* card invalidated */
+    "3B:7F:00:00:00:00:6A:44:4E:49:65:00:00:00:00:00:00:0F:65:81",
+    "FF:FF:00:FF:FF:FF:FF:FF:FF:FF:FF:00:00:00:00:00:00:FF:FF:FF",
+    CARD_CHIP_NAME, 
+    SC_CARD_TYPE_DNIE_TERMINATED,
+    0,
+    NULL
+  },
+  { NULL, NULL, NULL, 0, 0, NULL }
+};
+
+static struct sc_card_operations card_ops;
+static const struct sc_card_operations *iso_ops = NULL;
+
+static struct sc_card_driver card_drv = {
+  MODULE_DESC,
+  MODULE_NAME,
+  &card_ops,
+  NULL, 0, NULL
+};
+
+int _dnie_add_algorithm(sc_card_t *card, const sc_algorithm_info_t *info)
+{
+        sc_algorithm_info_t *p;
+        // from rev r4785 sc_card_valid(card) is removed
+        assert( (card != NULL) && (info != NULL) );
+        p = (sc_algorithm_info_t *) realloc(card->algorithms, (card->algorithm_count + 1) * sizeof(*info));
+        if (!p) {
+                if (card->algorithms)
+                        free(card->algorithms);
+                card->algorithms = NULL;
+                card->algorithm_count = 0;
+                return SC_ERROR_OUT_OF_MEMORY;
+        }
+        card->algorithms = p;
+        p += card->algorithm_count;
+        card->algorithm_count++;
+        *p = *info;
+        return 0;
+}
+
+
+int _dnie_add_rsa_alg(sc_card_t *card, unsigned int key_length,
+                         unsigned long flags, unsigned long exponent)
+{
+        sc_algorithm_info_t info;
+
+        memset(&info, 0, sizeof(info));
+        info.algorithm = SC_ALGORITHM_RSA;
+        info.key_length = key_length;
+        info.flags = flags;
+        info.u._rsa.exponent = exponent;
+
+        return _dnie_add_algorithm(card, &info);
+}
+
+
+static int dnie_match_atr_table(sc_context_t *ctx, struct sc_atr_table *table, u8 *atr, size_t atr_len)
+{
+        u8 *card_atr_bin = atr;
+        size_t card_atr_bin_len = atr_len;
+        char card_atr_hex[3 * SC_MAX_ATR_SIZE];
+        size_t card_atr_hex_len;
+        unsigned int i = 0;
+
+        if (ctx == NULL || table == NULL || atr == NULL)
+                return -1;
+        sc_bin_to_hex(card_atr_bin, card_atr_bin_len, card_atr_hex, sizeof(card_atr_hex), ':');
+        card_atr_hex_len = strlen(card_atr_hex);
+
+        sc_debug(ctx, "ATR     : %s\n", card_atr_hex);
+
+        for (i = 0; table[i].atr != NULL; i++) {
+                const char *tatr = table[i].atr;
+                const char *matr = table[i].atrmask;
+                size_t tatr_len = strlen(tatr);
+                u8 mbin[SC_MAX_ATR_SIZE], tbin[SC_MAX_ATR_SIZE];
+                size_t mbin_len, tbin_len, s, matr_len;
+                size_t fix_hex_len = card_atr_hex_len;
+                size_t fix_bin_len = card_atr_bin_len;
+                sc_debug(ctx, "ATR try : %s\n", tatr);
+
+                if (tatr_len != fix_hex_len) {
+                        sc_debug(ctx, "ignored - wrong length\n", tatr);
+                        continue;
+                }
+                if (matr != NULL) {
+                        sc_debug(ctx, "ATR mask: %s\n", matr);
+
+                        matr_len = strlen(matr);
+                        if (tatr_len != matr_len)
+                                continue;
+                        tbin_len = sizeof(tbin);
+                        sc_hex_to_bin(tatr, tbin, &tbin_len);
+                        mbin_len = sizeof(mbin);
+                        sc_hex_to_bin(matr, mbin, &mbin_len);
+                        if (mbin_len != fix_bin_len) {
+                                sc_error(ctx,"length of atr and atr mask do not match - ignored: %s - %s", tatr, matr);
+                                continue;
+                        }
+                        for (s = 0; s < tbin_len; s++) {
+                                /* reduce tatr with mask */
+                                tbin[s] = (tbin[s] & mbin[s]);
+                                /* create copy of card_atr_bin masked) */
+                                mbin[s] = (card_atr_bin[s] & mbin[s]);
+                        }
+                        if (memcmp(tbin, mbin, tbin_len) != 0)
+                                continue;
+                } else {
+                        if (strncasecmp(tatr, card_atr_hex, tatr_len) != 0)
+                                continue;
+                }
+                return i;
+        }
+        return -1;
+}
+
+
+int _dnie_match_atr(sc_card_t *card, struct sc_atr_table *table, int *type_out)
+{
+        int res;
+
+        if (card == NULL)
+                return -1;
+        res = dnie_match_atr_table(card->ctx, table, card->atr, card->atr_len);
+        if (res < 0)
+                return res;
+        if (type_out != NULL)
+                *type_out = table[res].type;
+        return res;
+}
+
+static int card_match_card(struct sc_card *card)
+{   
+  int r = SC_SUCCESS;;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+	
+  r = _dnie_match_atr(card, card_atrs, &card->type);
+  if (card->ctx->debug && (card->type==SC_CARD_TYPE_DNIE_TERMINATED))
+    sc_debug(card->ctx, "ATR Matches invalidated DNIe\n"); 
+  if (r<0)
+    r = 0; /* error */
+  else
+    r = 1; /* ok! */
+
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+
+static int card_init(struct sc_card *card)
+{ 
+  struct card_priv_data * priv;
+  int i, id, r=0;
+  unsigned long flags;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  /* if recognized an invalidated DNIe card, return error */
+  if (card->type==SC_CARD_TYPE_DNIE_TERMINATED) {
+    card->drv_data = priv = NULL;
+    r = SC_ERROR_MEMORY_FAILURE;
+    goto ci_err;
+  }
+
+  card->drv_data = priv = (struct card_priv_data *) malloc(sizeof(struct card_priv_data));
+  if (card->drv_data == NULL) {    
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto ci_err;
+  }
+
+  memset( priv, 0, sizeof( *priv ) );
+  priv->secure_channel_state = secure_channel_not_created;
+  priv->trusted_channel_err = 0;
+  /* Maps a path from virtual_fs to card */
+  priv->virtual_fs_to_card_path_map = map_path_to_path_new();
+  if(!priv->virtual_fs_to_card_path_map) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto ci_err;
+  }
+
+  /* Maps a ckaid from virtual_fs to card */
+  priv->virtual_fs_to_card_ckaid_map = map_id_to_id_new();
+  if(!priv->virtual_fs_to_card_ckaid_map) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto ci_err;
+  }
+
+  /* Maps a card ckaid to der encoding for cdf */
+  priv->cdf_card_ckaid_to_card_der_map = map_id_to_der_new();
+  if(!priv->cdf_card_ckaid_to_card_der_map) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto ci_err;
+  }
+
+  /* Maps a card ckaid to der encoding for prkdf */
+  priv->prkdf_card_ckaid_to_card_der_map = map_id_to_der_new();
+  if(!priv->prkdf_card_ckaid_to_card_der_map) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto ci_err;
+  }
+
+  /* Maps a card ckaid to der encoding for pukdf */
+  priv->pukdf_card_ckaid_to_card_der_map = map_id_to_der_new();
+  if(!priv->pukdf_card_ckaid_to_card_der_map) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto ci_err;
+  }
+
+  /* Maps a card certificate file path to card certificate ckaid */
+  priv->card_path_to_card_ckaid_map = map_path_to_id_new();
+  if(!priv->card_path_to_card_ckaid_map) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto ci_err;
+  }
+
+  sc_format_path("3F00", &priv->current_path); /* set current path to 3F00 */
+  priv->virtual_fs = virtual_fs_new();
+  if(!priv->virtual_fs) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto ci_end;
+  }
+
+  /* activate virtual_fs */
+  card_set_virtual_fs_state(card, 1);
+  
+  r = virtual_pkcs15_fs_init(priv->virtual_fs);
+  if (r!=SC_SUCCESS) {
+    sc_error (card->ctx, "Couldn't initialize PKCS#15 virtual fs\n");
+    goto ci_end;
+  }
+
+  i = _dnie_match_atr(card, card_atrs, &id);
+  if (i < 0) {
+    sc_error (card->ctx, "no correct id parsed!! Id:%d\n", id);
+    goto ci_err;
+  }
+
+  card->name = "dnie";
+
+  flags = SC_ALGORITHM_RSA_RAW;
+  flags |= SC_ALGORITHM_RSA_HASH_NONE;
+
+  _dnie_add_rsa_alg(card, 1024, flags, 0);
+  _dnie_add_rsa_alg(card, 2048, flags, 0);
+
+  card->type=id;
+  priv->card_type = id;		
+
+  card->cla = 0x00;	
+
+
+  /* State that we have an RNG */
+  card->caps |= SC_CARD_CAP_RNG;
+
+ ci_err:
+ ci_end:
+  if(r != SC_SUCCESS) {
+    if(priv) {
+      if(priv->virtual_fs_to_card_path_map) {
+	map_free(priv->virtual_fs_to_card_path_map);
+	priv->virtual_fs_to_card_path_map = NULL;
+      }
+
+      if(priv->virtual_fs_to_card_ckaid_map) {
+	map_free(priv->virtual_fs_to_card_ckaid_map);
+	priv->virtual_fs_to_card_ckaid_map = NULL;
+      }
+
+      if(priv->cdf_card_ckaid_to_card_der_map) {
+	map_free(priv->cdf_card_ckaid_to_card_der_map);
+	priv->cdf_card_ckaid_to_card_der_map = NULL;
+      }
+
+      if(priv->prkdf_card_ckaid_to_card_der_map) {
+	map_free(priv->prkdf_card_ckaid_to_card_der_map);
+	priv->prkdf_card_ckaid_to_card_der_map = NULL;
+      }
+
+      if(priv->pukdf_card_ckaid_to_card_der_map) {
+	map_free(priv->pukdf_card_ckaid_to_card_der_map);
+	priv->pukdf_card_ckaid_to_card_der_map = NULL;
+      }
+
+      if(priv->virtual_fs) {
+        virtual_fs_free(priv->virtual_fs);
+        priv->virtual_fs = NULL;
+      }
+      free(priv);
+      priv = NULL;
+    }
+  }
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+
+static int card_finish(struct sc_card *card)
+{ 
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if (DRVDATA(card)) {
+    if(DRVDATA(card)->virtual_fs) {
+      virtual_fs_free(DRVDATA(card)->virtual_fs);
+      DRVDATA(card)->virtual_fs = NULL;
+    }
+    if(DRVDATA(card)->virtual_fs_to_card_path_map) {
+      map_free(DRVDATA(card)->virtual_fs_to_card_path_map);
+      DRVDATA(card)->virtual_fs_to_card_path_map = NULL;
+    }
+    if(DRVDATA(card)->virtual_fs_to_card_ckaid_map) {
+      map_free(DRVDATA(card)->virtual_fs_to_card_ckaid_map);
+      DRVDATA(card)->virtual_fs_to_card_ckaid_map = NULL;
+    }
+    if(DRVDATA(card)->cdf_card_ckaid_to_card_der_map) {
+      map_free(DRVDATA(card)->cdf_card_ckaid_to_card_der_map);
+      DRVDATA(card)->cdf_card_ckaid_to_card_der_map = NULL;
+    }
+    if(DRVDATA(card)->prkdf_card_ckaid_to_card_der_map) {
+      map_free(DRVDATA(card)->prkdf_card_ckaid_to_card_der_map);
+      DRVDATA(card)->prkdf_card_ckaid_to_card_der_map = NULL;
+    }
+    if(DRVDATA(card)->pukdf_card_ckaid_to_card_der_map) {
+      map_free(DRVDATA(card)->pukdf_card_ckaid_to_card_der_map);
+      DRVDATA(card)->pukdf_card_ckaid_to_card_der_map = NULL;
+    }
+    if(DRVDATA(card)->card_path_to_card_ckaid_map) {
+      map_free(DRVDATA(card)->card_path_to_card_ckaid_map);
+      DRVDATA(card)->card_path_to_card_ckaid_map = NULL;
+    }    
+
+    /* Wipe out private card struct memory */
+    memset( card->drv_data, 0, sizeof(struct card_priv_data) );
+    free(card->drv_data);
+  }
+  card->drv_data = NULL;
+  SC_FUNC_RETURN(card->ctx, 1, SC_SUCCESS);
+}
+
+static int card_check_sw(sc_card_t *card, unsigned int sw1, unsigned int sw2)
+{
+  sc_debug(card->ctx, "Entering function card_check_sw\n"); 
+
+  if((sw1==0x66)&&(sw2==0x88)) {
+    sc_error(card->ctx, "The securized message value is incorrect\n");
+    return SC_ERROR_UNKNOWN;
+  }
+  if(sw1==0x6A && (sw2==0x88 || sw2==0x80 || sw2==0x89)){
+    sc_error(card->ctx, "File/Key already exists!\n");
+    return SC_ERROR_OBJECT_ALREADY_EXISTS;
+  }  
+  if(sw1==0x62 && sw2==0x83) {
+    sc_error(card->ctx, "Invalid file!\n");   
+    return SC_ERROR_INVALID_FILE;
+  }
+  if(sw1==0x6A && sw2==0x84) {
+    sc_error(card->ctx, "Not enought memory!\n");
+    return SC_ERROR_OUT_OF_MEMORY;
+  }
+
+  sc_debug(card->ctx, "Leaving function card_check_sw\n"); 
+  
+  return iso_ops->check_sw(card,sw1,sw2);
+}
+
+/* virtual fs functions */
+int card_is_virtual_fs_active(struct sc_card *card)
+{
+  return DRVDATA(card)->use_virtual_fs;
+}
+
+void card_set_virtual_fs_state(struct sc_card *card, int active)
+{
+  if(active) {
+    DRVDATA(card)->use_virtual_fs = 1;
+    card->max_send_size = 0xffff;
+    card->max_recv_size = 0xffff;
+    sc_debug(card->ctx, "virtual_fs mode activated\n");
+  } else {
+    DRVDATA(card)->use_virtual_fs = 0;
+    card->max_send_size = 0xf0;
+    card->max_recv_size = 0xf0;
+    sc_debug(card->ctx, "virtual_fs mode deactivated\n");
+  }
+}
+
+static int card_set_security_env(struct sc_card *card,
+				 const struct sc_security_env *env,
+				 int se_num)
+{
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if (env->flags & SC_SEC_ENV_ALG_PRESENT) {
+		
+    if (env->algorithm != SC_ALGORITHM_RSA) {
+      sc_error(card->ctx, "La tarjeta DNIe solo soporta el algoritmo RSA.\n");
+      return SC_ERROR_NOT_SUPPORTED;
+    }		
+    if (((env->algorithm_flags & SC_ALGORITHM_RSA_HASHES) != 0) && !(env->algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA1))
+      {
+	sc_error(card->ctx, "La tarjeta DNIe solo soporta algoritmo RSA con SHA1.\n");
+	return SC_ERROR_NOT_SUPPORTED;
+      }
+  }
+  
+  if (env->flags & SC_SEC_ENV_KEY_REF_PRESENT) {
+    if(env->key_ref_len>1)
+      {
+	sc_error(card->ctx, "Identificador de clave erroneo.\n");
+	return SC_ERROR_NOT_SUPPORTED;
+      }
+    
+    DRVDATA(card)->rsa_key_ref = env->key_ref[0];		
+  }
+  
+  sc_debug(card->ctx, "Key_ref= 0x%X", env->key_ref[0]);
+
+  SC_FUNC_RETURN(card->ctx, 1, SC_SUCCESS);
+}
+
+static int card_compute_signature(struct sc_card *card,
+				  const u8 * data, size_t datalen,
+				  u8 * out, size_t outlen)
+{ 
+  struct sc_apdu apdu;		
+  int r = SC_SUCCESS;	
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  assert(card != NULL && data != NULL && out != NULL);
+
+  memset(&apdu, 0, sizeof(struct sc_apdu));
+
+  /* Check if we are using FIRMA private key */
+  if (DRVDATA(card)->rsa_key_ref == 0x02) {
+    r = ask_user_consent(card);
+    if (r != SC_SUCCESS) {
+      sc_error(card->ctx, "ask_user_auth returned %d\n", r);
+      goto end;
+    }
+  }
+
+  /* check if serial channel has been created and create it if not */
+  if((r = card_assure_secure_channel(card)) != SC_SUCCESS)
+    goto end;
+
+  /* Load Data */
+  memset(&apdu, 0, sizeof(apdu));
+  sc_format_apdu(card, &apdu, 
+		 SC_APDU_CASE_3_SHORT,
+		 0x58,   
+		 0x00,   
+		 0x00 );
+  
+  apdu.cla = 0x90;
+  apdu.lc = datalen;
+  apdu.data = data;
+  apdu.datalen = datalen;	
+
+  r = card_transmit_apdu(card, &apdu);
+  if (r!=SC_SUCCESS)
+    goto end;
+
+  /* Sign Data */
+  sc_format_apdu(card, &apdu, 
+		 SC_APDU_CASE_3_SHORT,
+		 0x5A,   
+		 0x80,   
+		 DRVDATA(card)->rsa_key_ref );
+  
+  apdu.cla = 0x90;
+  apdu.le = outlen;
+  apdu.resp = out;
+  apdu.resplen = outlen;
+
+  r = card_transmit_apdu(card, &apdu);
+  SC_TEST_RET(card->ctx, r, "APDU transmit failed");
+
+  if (apdu.resplen == 0)
+    return sc_check_sw(card, apdu.sw1, apdu.sw2);
+
+ end:
+  if (r!=SC_SUCCESS) {
+    SC_FUNC_RETURN(card->ctx, 1, r);
+  }
+  else if (apdu.resplen==0) {
+    SC_FUNC_RETURN(card->ctx, 1, sc_check_sw(card, apdu.sw1, apdu.sw2));
+  }
+  else {
+    SC_FUNC_RETURN(card->ctx, 1, apdu.resplen);
+  }
+}
+
+static int card_decipher(struct sc_card *card, const u8 *data, size_t datalen,
+			 u8 *out, size_t outlen)
+{ 
+  int r = SC_SUCCESS;
+  struct sc_apdu apdu;
+  u8 rbuf[4096];		
+  size_t len=0;
+  
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  assert(card != NULL && data != NULL && out != NULL);
+
+  /* check if trusted channel has been created and create it if not */
+  if((r = card_assure_secure_channel(card)) != SC_SUCCESS)
+    SC_FUNC_RETURN(card->ctx, 1, r);
+
+  /*! format apdu */
+  sc_format_apdu(card, &apdu, 
+		 SC_APDU_CASE_4_SHORT,
+		 0x74,   
+		 0x40,   
+		 DRVDATA(card)->rsa_key_ref );
+   
+  memset(rbuf, 0, sizeof(rbuf));
+  apdu.cla = 0x90;
+  apdu.lc = datalen;
+  apdu.data = data;
+  apdu.datalen = apdu.lc;
+  apdu.le      = sizeof(rbuf); 
+  apdu.resp    = rbuf;
+  apdu.resplen = sizeof(rbuf);
+
+  /* transmit data to card */
+  r = card_transmit_apdu(card, &apdu);
+  if (r || apdu.resplen==0)
+    r = card_check_sw(card, apdu.sw1, apdu.sw2);
+
+  /* copies data to returned buffer */
+  len = apdu.resplen > outlen ? outlen : apdu.resplen;
+  memcpy(out, apdu.resp, len);
+  
+  SC_FUNC_RETURN(card->ctx, 1, len);
+}
+
+static int card_get_challenge(struct sc_card *card, u8 *rnd, size_t len)
+{ 
+  int r = SC_SUCCESS;
+  struct sc_apdu apdu;
+  u8 buf[22];
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  /* check if serial channel has been created and create it if not */
+  if((r = card_assure_secure_channel(card)) != SC_SUCCESS)
+    SC_FUNC_RETURN(card->ctx, 1, r);
+  
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT,
+		 0x84, 0x00, 0x00);
+  apdu.le = 20;
+  apdu.resp = buf;
+  apdu.resplen = 20;	/* include SW's */
+
+  while (len > 0) {
+    int n = len > 20 ? 20 : len;
+		
+    r = card_transmit_apdu(card, &apdu);
+    SC_TEST_RET(card->ctx, r, "APDU transmit failed");
+    if (apdu.resplen != 20)
+      return card_check_sw(card, apdu.sw1, apdu.sw2);
+    memcpy(rnd, apdu.resp, n);
+    len -= n;
+    rnd += n;
+  }	
+
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+static int iso_build_pin_apdu(sc_card_t *card, sc_apdu_t *apdu,
+		struct sc_pin_cmd_data *data, u8 *buf, size_t buf_len)
+{
+	int r, len = 0, pad = 0, use_pin_pad = 0, ins, p1 = 0;
+	
+	switch (data->pin_type) {
+	case SC_AC_CHV:
+		break;
+	default:
+		return SC_ERROR_INVALID_ARGUMENTS;
+	}
+
+	if (data->flags & SC_PIN_CMD_NEED_PADDING)
+		pad = 1;
+	if (data->flags & SC_PIN_CMD_USE_PINPAD)
+		use_pin_pad = 1;
+
+	data->pin1.offset = 5;
+
+	switch (data->cmd) {
+	case SC_PIN_CMD_VERIFY:
+		ins = 0x20;
+		if ((r = sc_build_pin(buf, buf_len, &data->pin1, pad)) < 0)
+			return r;
+		len = r;
+		break;
+	case SC_PIN_CMD_CHANGE:
+		ins = 0x24;
+		if (data->pin1.len != 0 || use_pin_pad) {
+			if ((r = sc_build_pin(buf, buf_len, &data->pin1, pad)) < 0)
+				return r;
+			len += r;
+		} else {
+			/* implicit test */
+			p1 = 1;
+		}
+
+		data->pin2.offset = data->pin1.offset + len;
+		if ((r = sc_build_pin(buf+len, buf_len-len, &data->pin2, pad)) < 0)
+			return r;
+		len += r;
+		break;
+	case SC_PIN_CMD_UNBLOCK:
+		ins = 0x2C;
+		if (data->pin1.len != 0 || use_pin_pad) {
+			if ((r = sc_build_pin(buf, buf_len, &data->pin1, pad)) < 0)
+				return r;
+			len += r;
+		} else {
+			p1 |= 0x02;
+		}
+
+		if (data->pin2.len != 0 || use_pin_pad) {
+			data->pin2.offset = data->pin1.offset + len;
+			if ((r = sc_build_pin(buf+len, buf_len-len, &data->pin2, pad)) < 0)
+				return r;
+			len += r;
+		} else {
+			p1 |= 0x01;
+		}
+		break;
+	default:
+		return SC_ERROR_NOT_SUPPORTED;
+	}
+
+	sc_format_apdu(card, apdu, SC_APDU_CASE_3_SHORT,
+				ins, p1, data->pin_reference);
+
+	apdu->lc = len;
+	apdu->datalen = len;
+	apdu->data = buf;
+	apdu->resplen = 0;
+        apdu->sensitive =1;
+
+	return 0;
+}
+
+static int iso_pin_cmd(sc_card_t *card, struct sc_pin_cmd_data *data,
+		       int *tries_left)
+{
+  sc_apdu_t local_apdu, *apdu;
+  int r;
+  u8  sbuf[SC_MAX_APDU_BUFFER_SIZE];
+  
+  if (tries_left)
+    *tries_left = -1;
+   
+
+   //card_card_create_secure_channel(card); /*Uncomment this on MAC OS X systems*/
+  /* See if we've been called from another card driver, which is
+   * passing an APDU to us (this allows to write card drivers
+   * whose PIN functions behave "mostly like ISO" except in some
+   * special circumstances.
+   */
+  if (data->apdu == NULL) {
+    r = iso_build_pin_apdu(card, &local_apdu, data, sbuf, sizeof(sbuf));
+    if (r < 0)
+      return r;
+    data->apdu = &local_apdu;
+  }
+  apdu = data->apdu;
+
+  /* Transmit the APDU to the card */
+  r = card_transmit_apdu(card, apdu);
+  
+  /* Clear the buffer - it may contain pins */
+  sc_mem_clear(sbuf, sizeof(sbuf));
+
+  /* Don't pass references to local variables up to the caller. */
+  if (data->apdu == &local_apdu)
+    data->apdu = NULL;
+
+  SC_TEST_RET(card->ctx, r, "APDU transmit failed");
+  if (apdu->sw1 == 0x63) {
+    if ((apdu->sw2 & 0xF0) == 0xC0 && tries_left != NULL)
+      *tries_left = apdu->sw2 & 0x0F;
+    return SC_ERROR_PIN_CODE_INCORRECT;
+  }
+  return card_check_sw(card, apdu->sw1, apdu->sw2);
+}
+
+static int card_build_pin_apdu(struct sc_card *card,
+			       struct sc_apdu *apdu,
+			       struct sc_pin_cmd_data *data)
+{ 
+  u8 sbuf[SC_MAX_APDU_BUFFER_SIZE];
+  int r = SC_SUCCESS, len=0, pad = 0, cla=0, ins, p1 = 0, p2 = 0;	
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  switch (data->pin_type) {
+  case SC_AC_CHV:
+    break;
+  default:
+    return SC_ERROR_INVALID_ARGUMENTS;
+  }
+
+  if (data->flags & SC_PIN_CMD_NEED_PADDING)
+    pad = 1;
+
+  switch (data->cmd) {
+  case SC_PIN_CMD_VERIFY:
+
+    data->pin1.offset = 0;
+    if ((r = sc_build_pin(sbuf, sizeof(sbuf), &data->pin1, pad)) < 0)
+      return r;
+    len = r;
+
+    cla = 0x00;
+    ins = 0x20;
+    p1 = 0;
+    /* ignore pin_reference */
+    p2 = 0x00;
+    break;
+  case SC_PIN_CMD_CHANGE:
+    /* not supported in user driver */
+    return SC_ERROR_NOT_SUPPORTED;
+  case SC_PIN_CMD_UNBLOCK:
+    /* not supported in user driver */
+    return SC_ERROR_NOT_SUPPORTED;
+  default:
+    return SC_ERROR_NOT_SUPPORTED;
+  }
+
+  memset(apdu, 0, sizeof(*apdu));
+  apdu->cla = cla;
+  apdu->cse = SC_APDU_CASE_3_SHORT;
+  apdu->ins = (u8) ins;
+  apdu->p1 = (u8) p1;
+  apdu->p2 = (u8) p2;
+
+  apdu->lc = len;
+  apdu->datalen = len;
+  apdu->data = sbuf;
+  apdu->resplen = 0;
+  apdu->le = 0;
+
+  SC_FUNC_RETURN(card->ctx, 1, SC_SUCCESS);
+}
+
+static int card_pin_cmd(sc_card_t *card, struct sc_pin_cmd_data *data, int *tries_left)
+{ 
+  int r = SC_SUCCESS;
+  sc_apdu_t local_apdu;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  /* check if serial channel has been created and create it if not */
+  if((r = card_assure_secure_channel(card)) != SC_SUCCESS)
+    SC_FUNC_RETURN(card->ctx, 1, r);
+
+  data->flags &= ~SC_PIN_CMD_NEED_PADDING;  
+  data->apdu = &local_apdu;
+  r = card_build_pin_apdu(card, data->apdu, data);
+  if (r!=SC_SUCCESS)
+    SC_FUNC_RETURN(card->ctx, 1, r);
+
+  r = iso_pin_cmd(card, data, tries_left);
+  if (r!=SC_SUCCESS)
+    SC_FUNC_RETURN(card->ctx, 1, r);
+
+  /* remove reference to stack variable apdu */
+  memset(&local_apdu, 0, sizeof(local_apdu));
+  data->apdu = NULL;
+
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+int iso_select_file(sc_card_t *card,
+		    const sc_path_t *in_path,
+		    sc_file_t **file_out)
+{
+  sc_context_t *ctx = NULL;
+  sc_apdu_t apdu;
+  u8 buf[SC_MAX_APDU_BUFFER_SIZE];
+  u8 pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;
+  int r = SC_SUCCESS, pathlen;
+  sc_file_t *file = NULL;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+ 
+  assert(card != NULL && in_path != NULL);
+
+  ctx = card->ctx;
+  memcpy(path, in_path->value, in_path->len);
+  pathlen = in_path->len;
+
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0);       
+  
+  switch (in_path->type) {
+  case SC_PATH_TYPE_FILE_ID:
+    apdu.p1 = 0;
+    if (pathlen != 2) {
+      sc_error(card->ctx, "ERROR: Invalid arguments! pathlen != 2\n");
+      SC_FUNC_RETURN(card->ctx, 1, SC_ERROR_INVALID_ARGUMENTS);
+    }
+    break;
+  case SC_PATH_TYPE_DF_NAME:
+    apdu.p1 = 4;
+    break;
+  case SC_PATH_TYPE_PATH:
+    /* transform to file id */
+    if(pathlen%2) {
+      sc_error(card->ctx, "ERROR: Invalid arguments! pathlen not multiple of 2\n");
+      SC_FUNC_RETURN(card->ctx, 1, SC_ERROR_INVALID_ARGUMENTS);
+    }
+    
+    while(pathlen>0) {
+      sc_path_t temp_path;
+      if(path[0] == 0x3f && path[1] == 0x00) {
+	temp_path.type = SC_PATH_TYPE_DF_NAME;
+	strcpy((char *)temp_path.value, CARD_MF_NAME);
+	temp_path.len = sizeof(CARD_MF_NAME) - 1;
+      } else {
+	temp_path.type = SC_PATH_TYPE_FILE_ID;
+	temp_path.value[0] = path[0];
+	temp_path.value[1] = path[1];
+	temp_path.len = 2;
+      }
+      r = iso_select_file(card, &temp_path, file_out);
+      if(r != SC_SUCCESS) {
+	goto end;
+      }
+      pathlen-=2;
+      path+=2;
+    }
+    goto end;
+    break;
+  default:
+    sc_error(card->ctx, "ERROR: Invalid arguments! default case %d\n", in_path->type);
+    SC_FUNC_RETURN(card->ctx, 2, SC_ERROR_INVALID_ARGUMENTS);
+  }
+  apdu.p2 = 0;		/* first record, return FCI */
+  apdu.lc = pathlen;
+  apdu.data = path;
+  apdu.datalen = pathlen;
+
+  if (file_out != NULL) {
+    apdu.resp = buf;
+    apdu.resplen = sizeof(buf);
+    apdu.le = 256;
+  } else {
+    apdu.resplen = 0;
+    apdu.le = 0;
+    apdu.cse = SC_APDU_CASE_3_SHORT;
+  }
+  r = card_transmit_apdu(card, &apdu);
+  SC_TEST_RET(card->ctx, r, "APDU transmit failed");
+  if (file_out == NULL) {
+    if (apdu.sw1 == 0x61)
+      SC_FUNC_RETURN(card->ctx, 2, 0);
+    SC_FUNC_RETURN(card->ctx, 2, card_check_sw(card, apdu.sw1, apdu.sw2));
+  }
+
+  r = card_check_sw(card, apdu.sw1, apdu.sw2);
+  if (r!=SC_SUCCESS)
+    SC_FUNC_RETURN(card->ctx, 2, r);
+
+  switch (apdu.resp[0]) {
+  case 0x6F:
+    file = sc_file_new();
+    if (file == NULL)
+      SC_FUNC_RETURN(card->ctx, 0, SC_ERROR_OUT_OF_MEMORY);
+    file->path = *in_path;
+    if (card->ops->process_fci == NULL) {
+      sc_file_free(file);
+      SC_FUNC_RETURN(card->ctx, 2, SC_ERROR_NOT_SUPPORTED);
+    }
+    if (apdu.resp[1] <= apdu.resplen)
+      card->ops->process_fci(card, file, apdu.resp+2, apdu.resp[1]);
+    *file_out = file;
+    break;
+  case 0x00:	/* proprietary coding */
+    SC_FUNC_RETURN(card->ctx, 2, SC_ERROR_UNKNOWN_DATA_RECEIVED);
+    break;
+  default:
+    SC_FUNC_RETURN(card->ctx, 2, SC_ERROR_UNKNOWN_DATA_RECEIVED);
+  }
+
+ end:
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+int card_select_file(struct sc_card *card, const struct sc_path *in_path,
+		     struct sc_file **file)
+{   
+  int r = SC_SUCCESS;
+  unsigned int ii=0;
+  sc_path_t temp_path;
+  sc_path_t next_path;
+  virtual_file_t *virtual_file = NULL;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if(card_is_virtual_fs_active(card)) {
+    /* virtual fs usage */
+    if(!in_path || in_path->len < 2 || (in_path->len%2) == 1) {
+      /* non-existant or bad in_path */
+      r = SC_ERROR_INVALID_ARGUMENTS;
+      goto csf_end;
+    }
+
+    if((in_path->type != SC_PATH_TYPE_FILE_ID) &&
+       (in_path->type != SC_PATH_TYPE_PATH)) {
+      /* we don't support string names in path for now */
+      r = SC_ERROR_INVALID_ARGUMENTS;
+      goto csf_end;
+    }
+
+    /* set current path to next_path */
+    memcpy(&next_path, &DRVDATA(card)->current_path, sizeof(next_path));
+  
+    /* iterate through path */
+    for(ii=0; ii<in_path->len; ii+=2) {
+      if((in_path->value[ii]==0x3f) && (in_path->value[ii+1]==0x00)) {
+	/* we go to root again */
+	sc_format_path("3F00", &next_path);
+      } else {
+	/* build a temporal path with current file */
+	/* the casting is needed tp remove warning. sc_path_set should const param id because it remains unmodified */
+	r = sc_path_set_dnie(&temp_path, in_path->type, (unsigned char *)in_path->value+ii, 2, 0, 0);
+	if(r!=SC_SUCCESS) 
+	  goto csf_end;
+	
+	/* append to current file */
+	r = sc_append_path(&next_path, &temp_path);
+	if(r!=SC_SUCCESS) 
+	  goto csf_end;
+      }
+
+      /* we have a path we should select */
+      sc_debug(card->ctx, "Selecting %s\n", sc_print_path(&next_path));
+      virtual_file = virtual_fs_find_by_path(DRVDATA(card)->virtual_fs, &next_path);
+      if(virtual_file) {
+	/* file exists! */
+	sc_debug(card->ctx, "File selected successfully\n");
+
+	/* set current path to this new path */
+	memcpy(&DRVDATA(card)->current_path, &next_path, sizeof(next_path));
+      } else {
+	/* file doesn't exist! */
+	r = SC_ERROR_FILE_NOT_FOUND;
+	sc_debug(card->ctx, "File selection failed\n");
+	goto csf_end;
+      }
+      
+    }
+
+    if(!virtual_file) {
+      /* this should be impossible.
+	 we should really have a virtual_file here.
+	 if not something happened with the internal logic */
+      r = SC_ERROR_INTERNAL;
+      goto csf_end;
+    }
+
+    /* we now synchronize file because this gets a correct size for it */
+    r = virtual_file_data_synchronize(virtual_file, card, virtual_file_sync_type_card_to_virtual_fs, DRVDATA(card)->virtual_fs);
+    if (r != SC_SUCCESS) {
+      sc_error(card->ctx, "Synchronization failed\n");
+      goto csf_end;
+    }
+  
+    if(file) {
+      /* we have to create a file structure */
+      *file = sc_file_new();
+      if(!*file) {
+	r=SC_ERROR_OUT_OF_MEMORY;
+	goto csf_end;
+      }
+
+      /* fill file */
+      r = virtual_file_export_file(virtual_file, *file);
+      if(r != SC_SUCCESS) {
+	sc_file_free(*file);
+	*file = NULL;
+      }
+    }
+  } else {
+    /* check if serial channel has been created and create it if not */
+    if((r = card_assure_secure_channel(card)) != SC_SUCCESS)
+      goto csf_end;
+  
+    /* not virtual fs select file */
+    r = iso_select_file(card, in_path, file);
+    if (r!=SC_SUCCESS)
+      goto csf_end;
+  }  
+  
+ csf_end:
+  SC_FUNC_RETURN(card->ctx, 1, r); 
+}
+
+static void card_add_acl_entry(sc_card_t *card, sc_file_t *file, int op, u8 byte)
+{
+  unsigned int method, key_ref = SC_AC_KEY_REF_NONE;
+
+  assert(card!=NULL);
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  switch (byte >> 4) {
+  case 0:
+    method = SC_AC_NONE;
+    break;
+  case 1:
+    method = SC_AC_CHV;
+    key_ref = byte & 0x0F;	       
+    break;
+  case 3:
+    method = SC_AC_CHV;
+    key_ref = byte & 0x0F;	       
+    break;
+  case 4:
+    method = SC_AC_TERM;
+    key_ref = byte & 0x0F;
+    break;
+  case 15:
+    method = SC_AC_NEVER;
+    break;
+  default:
+    method = SC_AC_UNKNOWN;
+    break;
+  }
+  sc_file_add_acl_entry(file, op, method, key_ref);
+
+  sc_debug(card->ctx, "Leaving function card_add_acl_entry\n"); 
+}
+
+static void card_parse_sec_attr(sc_card_t *card, sc_file_t *file, const u8 * buf, size_t len)
+{
+  int i;
+  int idx[4];
+
+  assert(card!=NULL);
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if (len < 4)
+    return;
+  if (file->type == SC_FILE_TYPE_DF) {
+    const int df_idx[4] = {
+      SC_AC_OP_CREATE, SC_AC_OP_DELETE ,
+      SC_AC_OP_REHABILITATE, SC_AC_OP_INVALIDATE
+    };
+    for (i = 0; i <4; i++)
+      idx[i] = df_idx[i];
+  } else {
+    const int ef_idx[4] = {
+      SC_AC_OP_READ, SC_AC_OP_UPDATE,
+      SC_AC_OP_REHABILITATE, SC_AC_OP_INVALIDATE
+    };
+    for (i = 0; i < 4; i++)
+      idx[i] = ef_idx[i];
+  }
+  for (i = 0; i < 4; i++)
+    card_add_acl_entry(card, file, idx[i], buf[i]);
+
+  sc_debug(card->ctx, "Leaving function card_parse_sec_attr\n"); 
+}
+
+static int card_process_fci(sc_card_t *card, sc_file_t *file,
+			    const u8 *buf, size_t buflen)
+{
+  int r = SC_SUCCESS;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  r = iso_ops->process_fci(card, file, buf, buflen);
+  if (r!=SC_SUCCESS)
+    goto cpf_err;
+
+  if (file->prop_attr_len >= 10) {
+
+    /* Examine file type */
+    switch (file->prop_attr[0]) {
+    case 0x01:
+      file->type = SC_FILE_TYPE_WORKING_EF;
+      file->ef_structure = SC_FILE_EF_TRANSPARENT;
+      break;
+    case 0x15:
+      file->type = SC_FILE_TYPE_WORKING_EF;
+      break;
+    case 0x38: /* 0x38 is DF */
+      file->type = SC_FILE_TYPE_DF;
+      break;
+    }
+    /* File identifier */
+    file->id = (file->prop_attr[1] << 8) | file->prop_attr[2];
+
+    /* File size */
+    file->size = (file->prop_attr[3] << 8) | file->prop_attr[4];
+
+    /* Parse acces conditions bytes (4) from propietary information */
+    card_parse_sec_attr(card, file, (file->prop_attr)+5, 4);
+  }
+
+ cpf_err:
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+static int card_ctl(struct sc_card *card, unsigned long cmd, void *ptr)
+{ 
+  assert(card!=NULL);
+
+  SC_FUNC_CALLED(card->ctx, 1);
+  
+  switch (cmd) {
+  case SC_CARDCTL_GET_SERIALNR:
+    sc_debug(card->ctx, "Calling function card_get_serialnr\n"); 
+    return card_get_serialnr(card, (sc_serial_number_t *) ptr);
+  default:
+    return SC_ERROR_NOT_SUPPORTED;
+  }	
+  
+}
+
+static int card_read_binary(sc_card_t *card,
+			    unsigned int idx, u8 *buf, size_t count,
+			    unsigned long flags)
+{
+  int r = SC_SUCCESS;
+  virtual_file_t *virtual_file = NULL;
+  sc_apdu_t apdu;
+  u8 recvbuf[SC_MAX_APDU_BUFFER_SIZE];
+ 
+  SC_FUNC_CALLED(card->ctx, 1);
+  
+  if(card_is_virtual_fs_active(card)) {
+    /* we get file from our virtual_fs */
+    virtual_file = virtual_fs_find_by_path(DRVDATA(card)->virtual_fs, &DRVDATA(card)->current_path);
+    if(!virtual_file) {
+      /* this should be impossible.
+	 we should really have a virtual_file here.
+	 if not something happened with the internal logic */
+      r = SC_ERROR_INTERNAL;
+      goto crb_end;
+    }
+
+    if(!virtual_file->is_ef) {
+      r = SC_ERROR_NOT_ALLOWED;
+      goto crb_end;
+    }
+    
+    /* synchronizes if needed from the card to the virtual fs */
+    r = virtual_file_data_synchronize(virtual_file, card, virtual_file_sync_type_card_to_virtual_fs, DRVDATA(card)->virtual_fs);
+    if (r != SC_SUCCESS) {
+      sc_error(card->ctx, "Synchronization failed\n");
+      goto crb_end;
+    }
+
+    r = virtual_file_data_read(virtual_file, idx, buf, count);
+  } else {
+    /* we get file as usual from the card */
+    assert(count <= card->max_recv_size);
+    sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xB0,
+                   (idx >> 8) & 0x7F, idx & 0xFF);
+    apdu.le = count;
+    apdu.resplen = count;
+    apdu.resp = recvbuf;
+    
+    r = card_transmit_apdu(card, &apdu);
+    SC_TEST_RET(card->ctx, r, "APDU transmit failed");
+    if (apdu.resplen == 0)
+      SC_FUNC_RETURN(card->ctx, 2, card_check_sw(card, apdu.sw1, apdu.sw2));    
+    memcpy(buf, recvbuf, apdu.resplen);
+  }
+
+ crb_end:
+  if (r == SC_SUCCESS)
+    r = count;
+
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+
+static int card_logout(struct sc_card *card)
+{ 
+  /* reset flag secure channel as not created */
+  ((struct card_priv_data *) card->drv_data)->secure_channel_state = secure_channel_not_created;
+  sc_debug(card->ctx, "Leaving function card_logout");
+  return 0;
+}
+
+int card_get_serialnr(sc_card_t *card, sc_serial_number_t *serial)
+{
+  int r = SC_SUCCESS;
+  u8  rbuf[17];
+  sc_apdu_t apdu;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if (card->type != SC_CARD_TYPE_DNIE_USER)
+    return SC_ERROR_NOT_SUPPORTED;
+
+  if (!serial)
+    return SC_ERROR_INVALID_ARGUMENTS;
+  /* see if we have cached serial number */
+  if (card->serialnr.len) {
+    memcpy(serial, &card->serialnr, sizeof(*serial));
+    return SC_SUCCESS;
+  }
+
+  /* check if serial channel has been created and create it if not */
+  if((r = card_assure_secure_channel(card)) != SC_SUCCESS)
+    return r;
+    
+  /* get serial number via APDU */
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xb8, 0x00, 0x00);
+  apdu.cla = 0x90;
+  apdu.resp = rbuf;
+  apdu.resplen = sizeof(rbuf);
+  apdu.le   = 0x11;
+  apdu.lc   = 0;
+  apdu.datalen = 0;
+  r = card_transmit_apdu(card, &apdu);
+  SC_TEST_RET(card->ctx, r, "APDU transmit failed");
+  if (apdu.sw1 != 0x90 || apdu.sw2 != 0x00) {
+    sc_error(card->ctx, "ERROR: SW1:0x%x, SW2:0x%x\n", apdu.sw1, apdu.sw2); 
+    return SC_ERROR_INTERNAL;
+  }
+  /* cache serial number */
+  memcpy(card->serialnr.value, apdu.resp, 7*sizeof(u8)); /*apdu.resplen);*/
+  card->serialnr.len = 7*sizeof(u8); /* apdu.resplen; */
+  /* copy and return serial number */
+  memcpy(serial, &card->serialnr, sizeof(*serial));
+
+  SC_FUNC_RETURN(card->ctx, 1, SC_SUCCESS);
+}  
+
+int card_envelope_transmit (sc_card_t *card, sc_apdu_t *tx)
+{
+  sc_apdu_t envelope_apdu;
+  u8 corrected_tx[1024], envelope_data[1024];
+  unsigned int len = 0, temp = 0, length = 0, total = 0;
+  int r=0;
+
+  memset(corrected_tx, 0, 1024);
+  memset(envelope_data, 0, 1024);
+
+  assert(card!=NULL);
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  /* set correct p3 and slice commands if necessary */
+  if (tx->lc > 255) {       
+    corrected_tx[len++] = tx->cla;     /* CLA */
+    corrected_tx[len++] = tx->ins;     /* INS */
+    corrected_tx[len++] = tx->p1;      /* P1 */
+    corrected_tx[len++] = tx->p2;      /* P2 */
+    /* code data length */
+    corrected_tx[len++] = 0x00;        /* 1st byte */
+    corrected_tx[len++] = tx->lc>>8;   /* 2nd byte */
+    corrected_tx[len++] = tx->lc&0xff; /* 3rd byte */
+
+    /* add data */
+    memcpy(corrected_tx+len,tx->data, tx->lc);
+
+    /* total bytes */
+    total = 7+tx->lc;
+
+    /* next block length */
+    length = 0;
+
+    /* process all blocks */
+    for (temp=0; temp<total; temp+=length) {
+      length = ((total-temp)>255) ? 255 : total-temp;      
+
+      /* prepare envelope apdu header */
+      sc_format_apdu(card, &envelope_apdu, tx->cse, 0xC2, 0x00, 0x00);
+
+      envelope_apdu.cla = 0x90;
+      envelope_apdu.data = envelope_data;
+
+      envelope_apdu.resp = tx->resp;
+      envelope_apdu.resplen = tx->resplen;
+      envelope_apdu.le = tx->le;
+      
+      /* P3 */
+      envelope_apdu.lc = length;
+      envelope_apdu.datalen = length;      
+
+      /* copy next block */
+      memcpy(envelope_data, corrected_tx+temp, length);            
+      
+      /* if secure channel is created, a get_response ALWAYS must be sent */
+      if((((struct card_priv_data *) card->drv_data)->secure_channel_state == secure_channel_created) &&
+	 (envelope_apdu.cse==SC_APDU_CASE_3_SHORT) &&
+	 (envelope_apdu.resplen>0)) {
+	envelope_apdu.cse = SC_APDU_CASE_4_SHORT;
+	envelope_apdu.le = envelope_apdu.resplen > 255 ? 255 : envelope_apdu.resplen;
+      }
+
+      r = sc_transmit_apdu(card, &envelope_apdu);
+      if (r != SC_SUCCESS)
+	goto dea_err;
+    }
+
+    tx->resplen = envelope_apdu.resplen;
+  } else {
+    /* no envelope needed */
+    int tmp_cse = tx->cse;
+
+    /* if secure channel is created, a get_response ALWAYS must be sent */
+    if((((struct card_priv_data *) card->drv_data)->secure_channel_state == secure_channel_created) &&
+       (tmp_cse==SC_APDU_CASE_3_SHORT) &&
+       (tx->resplen>0)) {
+      tx->cse = SC_APDU_CASE_4_SHORT;
+      tx->le = tx->resplen > 255 ? 255 : tx->resplen;
+    }
+    
+    r = sc_transmit_apdu(card, tx);
+
+    tx->cse=tmp_cse;        
+  }
+  
+ dea_err:
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+int card_transmit_apdu(sc_card_t *card, sc_apdu_t *tx)
+{
+  int r=0;
+  int retries=3;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if (((struct card_priv_data *) card->drv_data)->secure_channel_state == secure_channel_created){
+    r = card_secure_transmit(card, tx);
+
+    while((((tx->sw1==0x66) && (tx->sw2==0x88)) ||  /* The value of the securized message is incorrect*/
+           ((tx->sw1==0x69) && ((tx->sw2==0x87) || (tx->sw2==0x88)))) && /* The value of the securized message is incorrect*/
+          (retries != 0)){
+        
+      r = card_secure_transmit(card, tx);
+      retries--;
+    }
+  } 
+  else
+    r = card_envelope_transmit(card, tx);
+  
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+static struct sc_card_driver * sc_get_driver(void)
+{ 
+  struct sc_card_driver *iso_drv = sc_get_iso7816_driver();
+
+  card_ops = *iso_drv->ops;
+  card_ops.match_card = card_match_card;
+  card_ops.init = card_init;
+  card_ops.finish = card_finish;
+  if (iso_ops == NULL)
+    iso_ops = iso_drv->ops;
+  card_ops.create_file = NULL;
+  card_ops.set_security_env = card_set_security_env; 
+  card_ops.delete_file= NULL;
+  card_ops.compute_signature = card_compute_signature;
+  card_ops.decipher = card_decipher;
+  card_ops.get_challenge = card_get_challenge;
+  card_ops.pin_cmd = card_pin_cmd;
+  card_ops.select_file = card_select_file;
+  card_ops.check_sw=card_check_sw;
+  card_ops.process_fci = card_process_fci;
+  card_ops.card_ctl = card_ctl;	
+  card_ops.read_binary=card_read_binary;
+  card_ops.logout=card_logout;
+  
+  return &card_drv;
+}
+
+struct sc_card_driver *sc_get_dnie_driver(void)
+{
+	return sc_get_driver();
+}
+    
+   
+int card_create_cert_file( sc_card_t *card, sc_path_t *path, size_t size ) {
+  sc_error(card->ctx, "Function not implemented!");
+  return SC_ERROR_NOT_IMPLEMENTED;
+      
+}
Index: opensc-0.11.12/src/libopensc/dnie/base_card.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/base_card.h	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,98 @@
+/*
+ * base_card.h: Support for DNI-e card 
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#ifndef BASE_CARD_H
+#define BASE_CARD_H
+
+#include <stdlib.h>
+#include <opensc/pkcs15.h>
+#include "base_cardctl.h"
+#include "card_structures.h"
+#include "virtual_fs.h"
+#include "map.h"
+#include "map_helper.h"
+
+/* definitions */
+#define MODULE_DESC "DNIe card driver"
+#define MODULE_NAME "dnie"
+
+#define CARD_CHIP_NAME		"dnie"
+
+#define CARD_MF_TYPE		0x00
+#define CARD_DF_TYPE		0x01
+#define CARD_EF_TYPE		0x02
+#define CARD_SEL_ID		0x00
+#define CARD_SEL_AID		0x04
+#define CARD_FID_MF		0x3F00
+#define CARD_MF_NAME		"Master.File"
+
+#define CARD_SCHANNEL_KEYLEN_IN_BYTES 128
+
+#define SC_PKCS15_ODF           0xC0
+#define SC_PKCS15_TOKENINFO     0xC1
+#define SC_PKCS15_UNUSED        0xC2
+
+struct card_priv_data {
+  /* this variable holds secure channel state */
+  enum {
+    secure_channel_not_created = 0, /* set when secure channel hasn't been created yet */
+    secure_channel_creating, /* set by card_create_secure_channel when it has begun creating
+				the secure channel but it hasn't succeeded yet */
+    secure_channel_created /* set by card_create_secure_channel when it has succeeded
+			      creating the secure channel */
+  } secure_channel_state;
+  u8 kenc[16];
+  u8 kmac[16];
+  u8 ssc[8];
+  int card_type;
+  int rsa_key_ref;		
+  int trusted_channel_err;
+  /* virtual fs variables */
+  sc_path_t current_path; /*!< current path */
+  virtual_fs_t *virtual_fs; /*!< virtual fs */
+  int use_virtual_fs; /*!< use virtual fs in operations */
+
+  /* mapped variables */
+  map_path_to_path_t *virtual_fs_to_card_path_map; /*!< maps virtual_fs sc_path_t * to card sc_path_t * */
+  map_id_to_id_t *virtual_fs_to_card_ckaid_map; /*< maps CKA_ID virtual_fs sc_pkcs15_id * to card sc_pkcs15_id * */
+  map_id_to_der_t *cdf_card_ckaid_to_card_der_map; /*< maps CDF card CKA_ID to card der encoded asn1 */
+  map_id_to_der_t *prkdf_card_ckaid_to_card_der_map; /*< maps PrKDF card CKA_ID to card der encoded asn1 */
+  map_id_to_der_t *pukdf_card_ckaid_to_card_der_map; /*< maps PuKDF card CKA_ID to card der encoded asn1 */
+  map_path_to_id_t *card_path_to_card_ckaid_map; /*< maps card certificate file path to card certificate ckaid */
+};
+
+/* useful macros */
+#define DRVDATA(card) ((struct card_priv_data *) ((card)->drv_data))
+
+/* function declarations */
+int card_get_serialnr(sc_card_t *card, sc_serial_number_t *serial);
+int card_assure_secure_channel(struct sc_card *card);
+int card_card_create_secure_channel(struct sc_card *card);
+int card_secure_transmit(sc_card_t *card, sc_apdu_t *tx);
+int card_envelope_transmit (sc_card_t *card, sc_apdu_t *tx);
+int card_transmit_apdu(sc_card_t *card, sc_apdu_t *tx);
+int card_select_file(struct sc_card *card, const struct sc_path *in_path, struct sc_file **file);
+int card_create_cert_file( sc_card_t *card, sc_path_t *path, size_t size );
+int ask_user_auth();
+int card_is_virtual_fs_active(struct sc_card *card);
+void card_set_virtual_fs_state(struct sc_card *card, int active);
+
+#endif /* BASE_CARD_H */
Index: opensc-0.11.12/src/libopensc/dnie/base_cardctl.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/base_cardctl.h	2010-11-17 19:14:03.000000000 +0000
@@ -0,0 +1,87 @@
+/*
+ * base_cardctl.h: cardctl definitions for custom driver
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+*/
+
+#ifndef _SC_DNIE_CARDCTL_H
+#define _SC_DNIE_CARDCTL_H
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <opensc/cardctl.h>
+
+/* key usage for card keys */
+#define SC_CARD_KEY_USAGE_SIG 0x80
+#define SC_CARD_KEY_USAGE_CIF 0x40
+
+/* ERRORS */
+#define SC_ERROR_INVALID_FILE -3001
+/*
+#ifndef SC_ERROR_NOT_ENOUGH_MEMORY
+#define SC_ERROR_NOT_ENOUGH_MEMORY -3002
+#endif
+*/
+#define SC_ERROR_OBJECT_ALREADY_EXISTS -3003
+
+
+enum {
+  SC_CARDCTL_DNIE_BASE = _CTL_PREFIX('D', 'N', 'I'),
+  SC_CARDCTL_DNIE_GENERATE_KEY,
+  SC_CARDCTL_DNIE_STORE_KEY_COMPONENT,
+  SC_CARDCTL_DNIE_GET_NEW_KEY_REFERENCE,
+  SC_CARDCTL_DNIE_CREATE_FILE,
+  SC_CARDCTL_DNIE_DELETE_FILE
+};
+  
+struct sc_cardctl_card_genkey_info {
+  unsigned char   *pubkey;
+  unsigned int    pubkey_len;
+  unsigned char   *exponent;
+  unsigned int    exponent_len;
+  unsigned int    key_usage;
+  unsigned char   key_reference;
+
+};
+
+struct tlv {
+  u8 tag;
+  u8 *length;
+  size_t nlen;
+  u8 *value;
+};
+typedef struct tlv tlv_t;
+
+struct sc_cardctl_card_store_key_component_info {
+  int private_component;
+  u8 key_usage;
+  u8 key_id; 
+  tlv_t component;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: opensc-0.11.12/src/libopensc/dnie/card_helper.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/card_helper.c	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,341 @@
+/*!
+ * \file card_helper.c
+ * \brief Card helper routines
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#include "card_helper.h"
+#include "base_card.h"
+#include <opensc/log.h>
+#include <assert.h>
+#include <string.h>
+#include "pkcs15_default.h"
+#include "card_sync.h"
+#include "util.h"
+
+int card_helper_read_file(sc_card_t *card, const sc_path_t *path, u8 **buffer, size_t *length)
+{
+  int r = SC_SUCCESS;
+  sc_file_t *file = NULL;
+  unsigned char *card_data = NULL;
+  int old_use_virtual_fs; /*!< backup of use_virtual_fs */
+
+  SC_FUNC_CALLED(card->ctx, 1);
+  
+  /* we backup use_virtual_fs */
+  old_use_virtual_fs = card_is_virtual_fs_active(card);
+
+  /* we want to use card without virtual fs */
+  card_set_virtual_fs_state(card, 0);
+
+  if(!buffer || !length) {
+    r = SC_ERROR_INVALID_ARGUMENTS;
+    goto end;
+  }
+
+  if(*buffer) {
+    free(*buffer);
+    *buffer = NULL;
+  }
+
+  /* get file */
+  r = card_select_file(card, path, &file);
+  if(r != SC_SUCCESS)
+    goto end;
+
+  if(file->size <= 0) {
+    r = SC_ERROR_FILE_TOO_SMALL;
+    goto end;
+  }
+
+  card_data = malloc(file->size);
+  if(!card_data) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto end;
+  }
+
+  r = sc_read_binary(card, 0, card_data, file->size, 0);
+  if(r < 0)
+    goto end;
+
+  *buffer = card_data;
+  card_data = NULL;
+  *length = r;
+  r = SC_SUCCESS;
+
+ end:
+  /* we restore use_virtual_fs */
+  card_set_virtual_fs_state(card, old_use_virtual_fs);
+
+  if(file) {
+    sc_file_free(file);
+    file = NULL;
+  }
+  
+  if(card_data) {
+    free(card_data);
+    card_data = NULL;
+  }
+
+
+  SC_FUNC_RETURN(card->ctx, 1, r); 
+}
+
+int card_helper_update_file(sc_card_t *card, const sc_path_t *path, u8 *buffer, size_t length)
+{
+  int r = SC_SUCCESS;
+  sc_file_t *file = NULL;
+  int old_use_virtual_fs; /*!< backup of use_virtual_fs */
+
+  SC_FUNC_CALLED(card->ctx, 1);
+  
+  /* we backup use_virtual_fs */
+  old_use_virtual_fs = card_is_virtual_fs_active(card);
+
+  /* we want to use card without virtual fs */
+  card_set_virtual_fs_state(card, 0);
+
+  if(!buffer || length<=0) {
+    r = SC_ERROR_INVALID_ARGUMENTS;
+    goto chuf_end;
+  }
+
+  /* get file */
+  r = card_select_file(card, path, &file);
+  if(r != SC_SUCCESS)
+    goto chuf_end;
+  
+  if(file->size <= 0) {
+    r = SC_ERROR_FILE_TOO_SMALL;
+    goto chuf_end;
+  }
+  
+  if (file->size<length) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto chuf_end;
+  }
+
+  r = sc_update_binary(card, 0, buffer, length, 0);
+  if(r < 0)
+    goto chuf_end;
+  if (r ==length)
+    r = SC_SUCCESS;
+
+ chuf_end:
+  /* we restore use_virtual_fs */
+  card_set_virtual_fs_state(card, old_use_virtual_fs);
+
+  if(file) {
+    sc_file_free(file);
+    file = NULL;
+  }
+
+ SC_FUNC_RETURN(card->ctx, 1, r); 
+}
+
+int card_helper_create_cert_file(sc_card_t *card, struct _virtual_file_t *virtual_file, 
+				 size_t fcert_len, struct _virtual_file_t **certificate_virtual_file)
+{
+  int r = SC_SUCCESS;
+  sc_path_t fcert_path;
+  sc_pkcs15_unusedspace_t *unused_space=NULL;
+  sc_pkcs15_card_t *temp_p15card = NULL;
+  int old_use_virtual_fs; /*!< backup of use_virtual_fs */
+
+  assert(card!=NULL && virtual_file!=NULL && certificate_virtual_file!=NULL);
+
+  SC_FUNC_CALLED(card->ctx, 1);
+  
+  /* we backup use_virtual_fs */
+  old_use_virtual_fs = card_is_virtual_fs_active(card);
+
+  /* we want to use card without virtual fs */
+  card_set_virtual_fs_state(card, 0);
+
+  if(*certificate_virtual_file) {
+    virtual_file_free(*certificate_virtual_file);
+    *certificate_virtual_file = NULL;
+  }
+
+  memset(&fcert_path, 0, sizeof(struct sc_path));
+
+  /* 2. Look for a suitable file on UnusedSpace struct
+     which fits the final certificate file size.
+     2.1 If found, take file's path to reuse it.
+     2.2 If not, create a file on Certificate Directory
+     with final certificate len as its size
+  */
+    
+  /* we create a fake p15card structure */
+  temp_p15card = sc_pkcs15_card_new();
+  temp_p15card->card = card;
+    
+  r = sc_find_free_unusedspace( temp_p15card, fcert_len, &unused_space );
+  if (r!=SC_SUCCESS)
+    goto chccf_end;
+
+  if(unused_space) {
+    /* we got a path */
+    r = sc_path_set_dnie ( &fcert_path, 
+		      unused_space->path.type, 
+		      unused_space->path.value,
+		      unused_space->path.len,
+		      unused_space->path.index,
+		      unused_space->path.count );
+    if (r!=SC_SUCCESS)
+      goto chccf_end;
+  } else {            
+    sc_path_t temp_path;
+    /* move to certificate DF */
+    sc_format_path("3F006061", &temp_path);
+    r = card_select_file(card, &temp_path, NULL);
+    if(r != SC_SUCCESS)
+      goto chccf_end;
+
+    /* we start at 0x7001 file ID */
+    sc_format_path("7001", &fcert_path);
+
+    do {
+      r = card_create_cert_file( card, &fcert_path, fcert_len );
+      if (r == SC_ERROR_OBJECT_ALREADY_EXISTS) {
+	fcert_path.value[1]++;	
+      }
+      if(r!=SC_SUCCESS && r!=SC_ERROR_OBJECT_ALREADY_EXISTS)
+	goto chccf_end;
+    } while (r!=SC_SUCCESS);
+    r = SC_SUCCESS;
+  }    
+
+  /* create certificate file into vfs */
+  r = virtual_fs_append_new_virtual_file( DRVDATA(card)->virtual_fs, 
+					  &fcert_path, 
+					  virtual_file->data, 
+					  virtual_file->data_size, 
+					  virtual_file->data_size, 
+					  1, 
+					  virtual_file_sync_state_synced, 
+					  card_sync_card_to_virtual_fs_certificate_file_callback, 
+					  virtual_file_sync_state_sync_pending, 
+					  card_sync_virtual_fs_to_card_certificate_file_callback );
+  if(r != SC_SUCCESS)
+    goto chccf_end;
+
+  /* retrieve just created virtual file */
+  *certificate_virtual_file = virtual_fs_find_by_path( DRVDATA(card)->virtual_fs, &fcert_path );
+
+ chccf_end:
+/* we restore use_virtual_fs */
+  card_set_virtual_fs_state(card, old_use_virtual_fs);
+
+  if (unused_space) {
+    /* Delete UnusedSpace object if reused 
+       and also frees reserved memory
+    */
+    sc_pkcs15_remove_unusedspace(temp_p15card, unused_space);
+  }
+  if (temp_p15card) { 
+    /* set to NULL without freeing because we reused structure */
+    temp_p15card->card = NULL;
+    
+    /* now free temp structure */
+    sc_pkcs15_card_free(temp_p15card);
+    temp_p15card = NULL;
+  }
+  SC_FUNC_RETURN(card->ctx, 1, r); 
+}
+
+int card_helper_read_certificate_file(sc_card_t *card, const sc_path_t *path, u8 **buffer, size_t *length)
+{
+  int r = SC_SUCCESS;
+  sc_file_t *file = NULL;
+  unsigned char *card_data = NULL;
+  u8 header[8];
+  int old_use_virtual_fs; /*!< backup of use_virtual_fs */
+  size_t compressed_data_length=0;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+  
+  /* we backup use_virtual_fs */
+  old_use_virtual_fs = card_is_virtual_fs_active(card);
+
+  /* we want to use card without virtual fs */
+  card_set_virtual_fs_state(card, 0);
+
+  if(!buffer || !length) {
+    r = SC_ERROR_INVALID_ARGUMENTS;
+    goto end;
+  }
+
+  if(*buffer) {
+    free(*buffer);
+    *buffer = NULL;
+  }
+
+  /* get file */
+  r = card_select_file(card, path, &file);
+  if(r != SC_SUCCESS)
+    goto end;
+
+  if(file->size <= 0) {
+    r = SC_ERROR_FILE_TOO_SMALL;
+    goto end;
+  }
+
+  memset(header, 0, sizeof(header));
+  /* read certificate header information */
+  r = sc_read_binary(card, 0, header, sizeof(header), 0);
+  if(r<0 || r!=sizeof(header))
+    goto end;
+  /* get certificate compressed length */
+  compressed_data_length = lebytes2ulong(header+4);
+
+  /* update file size */
+  file->size = (file->size>(compressed_data_length+8)) ? compressed_data_length+8 : file->size;
+
+  card_data = malloc(file->size);
+  if(!card_data) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto end;
+  }
+
+  r = sc_read_binary(card, 0, card_data, file->size, 0);
+  if(r < 0)
+    goto end;
+
+  *buffer = card_data;
+  card_data = NULL;
+  *length = r;
+  r = SC_SUCCESS;
+
+ end:
+  /* we restore use_virtual_fs */
+  card_set_virtual_fs_state(card, old_use_virtual_fs);
+
+  if(file) {
+    sc_file_free(file);
+    file = NULL;
+  }
+  
+  if(card_data) {
+    free(card_data);
+    card_data = NULL;
+  }
+
+  SC_FUNC_RETURN(card->ctx, 1, r); 
+}
Index: opensc-0.11.12/src/libopensc/dnie/card_helper.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/card_helper.h	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,83 @@
+/*!
+ * \file card_helper.h
+ * \brief Card helper routines
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#ifndef CARD_HELPER_H
+#define CARD_HELPER_H
+
+
+#include <opensc/opensc.h>
+#include "virtual_fs.h"
+
+/*!
+  Selects path and reads a file. It returns an allocated
+  buffer (which must be freed by the user) with the data.
+  
+  \param card Struct to access the card
+  \param path Path to the file to be read.
+  \param buffer Output buffer with data allocated using malloc
+  \param length Output length of data
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_helper_read_file(sc_card_t *card, const sc_path_t *path, u8 **buffer, size_t *length); 
+
+/*!
+  Selects path and updates new data to file. 
+  
+  \param[in] card Struct to access the card
+  \param[in] path Path to the file to be updated.
+  \param[in] buffer Buffer with data
+  \param[in] length Length of data buffer
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_helper_update_file(sc_card_t *card, const sc_path_t *path, u8 *buffer, size_t length); 
+
+/*!
+  Creates a certificate file to card and also a new certificate file
+  into virtual fs. This last file is returned as a parameter.
+  
+  \param[in] card Struct to access the card
+  \param[in] virtual_file File containing certificate data but with an OpenSC path
+  \param[in] fcert_len Length of certificate file
+  \param[out] certificate_virtual_file New certificate file created into virtual fs
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_helper_create_cert_file(sc_card_t *card, struct _virtual_file_t *virtual_file, 
+				 size_t fcert_len, struct _virtual_file_t **certificate_virtual_file);
+
+/*!
+  Selects path and reads a certificate file checking header compressed information.
+  It returns an allocated buffer (which must be freed by the user) with the data.
+  
+  \param card Struct to access the card
+  \param path Path to the file to be read.
+  \param buffer Output buffer with data allocated using malloc
+  \param length Output length of data
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_helper_read_certificate_file(sc_card_t *card, const sc_path_t *path, u8 **buffer, size_t *length);
+
+#endif /* CARD_HELPER_H */
+	    
Index: opensc-0.11.12/src/libopensc/dnie/card_structures.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/card_structures.h	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,50 @@
+/*
+ * card_structures.h: Support functions for additional card structures
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ * oficinatecnica@dnielectronico.es
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#ifndef _CARD_STRUCTURES_H
+#define _CARD_STRUCTURES_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <opensc/opensc.h>
+
+/* structure defintions */
+struct card_pkcs15_df {
+  u8 *            data;        /* Buffer to hold PKCS#15 struct info               */
+  size_t          data_len;    /* Data buffer length and also the corresponding    */              
+  size_t          file_len;    /* PKCS#15 card file size                           */
+  size_t          filled_len;  /* Length of pkcs#15 struct info stored on df       */ 
+                               /* This value will be lower or at maximum           */
+                               /*  equals than len and will be increased/decreased */ 
+                               /*  when added/deleted pkcs#15 objects              */
+  sc_path_t       df_path;     /* Path of pkcs15_df                                */                               
+  unsigned int    type;        /* PKCS#15 DF type                                  */
+};
+typedef struct card_pkcs15_df card_pkcs15_df_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _CARD_STRUCTURES_H */
Index: opensc-0.11.12/src/libopensc/dnie/card_sync.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/card_sync.c	2010-11-17 19:14:03.000000000 +0000
@@ -0,0 +1,1013 @@
+/*!
+ * \file card_sync.c
+ * \brief Card synchronization functions
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#include "card_sync.h"
+#include <opensc/opensc.h>
+#include <opensc/pkcs15.h>
+#include "base_card.h"
+#include "pkcs15_standard.h"
+#include "pkcs15_default.h"
+#include "card_helper.h"
+#include "file_compression.h"
+#include <string.h> /*!< to call memory functions */
+
+
+int card_sync_card_to_virtual_fs_filter_cert( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, sc_pkcs15_object_t *obj )
+{
+  int r = SC_SUCCESS;
+  struct sc_pkcs15_cert_info *cert = NULL;
+  unsigned char *card_data = NULL;
+  virtual_file_t  *certificate_virtual_file = NULL;
+  virtual_file_t  *certificate_virtual_file_weak_link = NULL; 
+  sc_path_t abs_cert_path, cert_card_path;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  /* we need to correct certificate length in path */
+  cert = (struct sc_pkcs15_cert_info *) obj->data;
+  if(cert) {
+    /* set asn1 to map */
+    r = map_id_to_der_set_item(DRVDATA(card)->cdf_card_ckaid_to_card_der_map, &cert->id, &obj->der);
+    if(r != SC_SUCCESS)
+      goto end;
+    
+    if(cert->path.len > 0) {
+      certificate_virtual_file = virtual_file_new();
+      if(!certificate_virtual_file) {
+	r = SC_ERROR_OUT_OF_MEMORY;
+	goto end;
+      }
+      
+      memset(&abs_cert_path, 0, sizeof(struct sc_path));
+      memset(&cert_card_path, 0, sizeof(struct sc_path));
+
+      if(cert->path.len==2) {
+	sc_format_path("3F005015", &abs_cert_path);
+	r = sc_append_path(&abs_cert_path, &cert->path);
+	if(r!=SC_SUCCESS)
+	  goto end;
+	sc_format_path("3F006061", &cert_card_path);
+	r = sc_append_path(&cert_card_path, &cert->path);
+	if(r!=SC_SUCCESS)
+	  goto end;
+      } else if(cert->path.len==4) {
+	sc_format_path("3F00", &abs_cert_path);
+	r = sc_append_path(&abs_cert_path, &cert->path);
+	if(r!=SC_SUCCESS)
+	  goto end;
+	sc_format_path("3F00", &cert_card_path);
+	r = sc_append_path(&cert_card_path, &cert->path);
+	if(r!=SC_SUCCESS)
+	  goto end;
+        memcpy(cert->path.value, cert_card_path.value, cert_card_path.len);
+        cert->path.len = 6;
+      } else { 
+	r = sc_append_path(&abs_cert_path, &cert->path);
+	if(r!=SC_SUCCESS)
+	  goto end;
+	if(abs_cert_path.len==6) {
+	  r = sc_append_path(&cert_card_path, &cert->path);
+	  if(r!=SC_SUCCESS)
+	    goto end;
+	}
+      }
+
+      memcpy(&certificate_virtual_file->path, &abs_cert_path, sizeof(certificate_virtual_file->path));
+      r = map_path_to_path_set_item(DRVDATA(card)->virtual_fs_to_card_path_map, &certificate_virtual_file->path, &cert_card_path);
+      if(r != SC_SUCCESS)
+	goto end;
+      certificate_virtual_file->is_ef = 1;
+
+      certificate_virtual_file->card_to_virtual_fs.sync_state = virtual_file_sync_state_sync_pending;
+      certificate_virtual_file->card_to_virtual_fs.sync_callback = card_sync_card_to_virtual_fs_certificate_file_callback;
+      certificate_virtual_file->virtual_fs_to_card.sync_state = virtual_file_sync_state_unknown;
+      certificate_virtual_file->virtual_fs_to_card.sync_callback = NULL;
+      
+      /* append file to virtual_fs */
+      r = virtual_fs_append(virtual_fs, certificate_virtual_file);
+      if(r != SC_SUCCESS)
+	goto end;
+
+      /* we don't have ownership of virtual_file now,
+	 so we don't need to free it */
+      certificate_virtual_file_weak_link = certificate_virtual_file;
+      certificate_virtual_file = NULL;
+        
+      /* we now synchronize file because this gets a correct size for it */
+      r = virtual_file_data_synchronize(certificate_virtual_file_weak_link, card, virtual_file_sync_type_card_to_virtual_fs, DRVDATA(card)->virtual_fs);
+      if (r != SC_SUCCESS) {
+	sc_error(card->ctx, "Synchronization failed\n");
+	goto end;
+      }
+      
+      /* correct length in PKCS#15 */
+      cert->path.count = certificate_virtual_file_weak_link->data_size;
+    } else {
+      sc_debug(card->ctx, "Path length is 0");
+    }
+  } else {
+    sc_debug(card->ctx, "Pointer to cert info was empty");
+  }
+
+ end:
+  if(card_data) {
+    free(card_data);
+    card_data = NULL;
+  }
+
+  if(certificate_virtual_file) {
+    virtual_file_free(certificate_virtual_file);
+    certificate_virtual_file = NULL;
+  }
+
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+int card_sync_card_to_virtual_fs_filter_prkey( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, sc_pkcs15_object_t *obj )
+{
+  int r = SC_SUCCESS;
+  struct sc_pkcs15_prkey_info *prkey = NULL;
+  sc_path_t def_path;
+
+  /* This flag identifies the FIRMA private key */
+  u8 flag_id[1] = "F";
+  
+  memset(&def_path, 0, sizeof(struct sc_path));
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if(!card || !virtual_file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  prkey = (struct sc_pkcs15_prkey_info *) obj->data;
+  if(prkey) {
+    /* set asn1 to map */
+    r = map_id_to_der_set_item(DRVDATA(card)->prkdf_card_ckaid_to_card_der_map, &prkey->id, &obj->der);
+    if(r != SC_SUCCESS)
+      goto end;
+
+    if(prkey->modulus_length < 512)
+      prkey->modulus_length = prkey->modulus_length * 8;
+    if(prkey->modulus_length != 2048)
+      prkey->modulus_length = 1024;
+
+    if(prkey->path.len > 0) {
+      /* append empty file */
+
+      if(prkey->path.len == 4) {
+        sc_format_path("3F00", &def_path);
+   	r = sc_append_path(&def_path, &prkey->path);
+
+	if(r!=SC_SUCCESS)
+	  goto end;
+
+        memcpy(prkey->path.value, def_path.value, def_path.len);
+        prkey->path.len = 6;
+
+      } else {
+        memcpy(&def_path, &prkey->path, sizeof(prkey->path));      
+      }
+
+      r = virtual_fs_append_new_virtual_file(virtual_fs, &def_path, NULL, 1, 1, 1, virtual_file_sync_state_unknown, NULL, virtual_file_sync_state_unknown, NULL);
+      if(r != SC_SUCCESS)
+	goto end;
+
+      /* correct length in PKCS#15 */
+      prkey->path.count = 0;
+
+      /* Fixed key usage for FIRMA private key */
+      if(memcmp(prkey->id.value, flag_id, 1)==0)
+	prkey->usage |= SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;
+
+      obj->auth_id.value[0]=0x01;
+      obj->auth_id.len=0x01;
+    } else {
+      sc_debug(card->ctx, "Path length is 0");
+    }
+  } else {
+    sc_debug(card->ctx, "Pointer to prkey info was empty");
+  }
+
+ end:
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+int card_sync_card_to_virtual_fs_filter_pukey( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, sc_pkcs15_object_t *obj )
+{
+  int r = SC_SUCCESS;
+  struct sc_pkcs15_pubkey_info *pukey = NULL;
+  sc_path_t def_path;
+  /* This flag identifies the FIRMA public key */
+  u8 flag_id[1] = "F";
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  memset(&def_path, 0, sizeof(struct sc_path));
+
+  if(!card || !virtual_file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  pukey = (struct sc_pkcs15_pubkey_info *) obj->data;
+  if(pukey) {
+    /* set asn1 to map */
+    r = map_id_to_der_set_item(DRVDATA(card)->pukdf_card_ckaid_to_card_der_map, &pukey->id, &obj->der);
+    if(r != SC_SUCCESS)
+      goto end;
+
+
+    if(pukey->path.len > 0) {
+
+      if(pukey->path.len == 4) {
+        sc_format_path("3F00", &def_path);
+   	r = sc_append_path(&def_path, &pukey->path);
+
+	if(r!=SC_SUCCESS)
+	  goto end;
+
+        memcpy(pukey->path.value, def_path.value, def_path.len);
+        pukey->path.len = 6;
+
+      } else {
+        memcpy(&def_path, &pukey->path, sizeof(pukey->path));      
+      }
+
+      /* append empty file */
+      r = virtual_fs_append_new_virtual_file(virtual_fs, 
+					     &def_path, 
+					     obj->der.value, 
+					     obj->der.len, 
+					     obj->der.len, 
+					     1, 
+					     virtual_file_sync_state_unknown, 
+					     NULL, 
+					     virtual_file_sync_state_unknown, 
+					     NULL);
+      if(r != SC_SUCCESS)
+	goto end;
+
+      /* correct length in PKCS#15 */
+      pukey->path.count = 0;
+
+      /* Fixed key usage for FIRMA public key */
+      if(memcmp(pukey->id.value, flag_id, 1)==0)
+	pukey->usage |= SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;
+
+    } else {
+      sc_debug(card->ctx, "Path length is 0");
+    }
+  } else {
+    sc_debug(card->ctx, "Pointer to pukey info was empty");
+  }
+
+ end:
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+
+int card_sync_card_to_virtual_fs_filter_data_object( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, sc_pkcs15_object_t *obj )
+{
+  int r = SC_SUCCESS;
+  struct sc_pkcs15_data_info *data = NULL;
+  unsigned char *card_data = NULL;
+  virtual_file_t  *data_virtual_file = NULL;
+  virtual_file_t  *data_virtual_file_weak_link = NULL; 
+  sc_path_t abs_data_path, data_card_path, def_path;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  /* we need to correct certificate length in path */
+  data = (struct sc_pkcs15_data_info *) obj->data;
+  if(data) {    
+    if(data->path.len > 0) {
+      data_virtual_file = virtual_file_new();
+      if(!data_virtual_file) {
+	r = SC_ERROR_OUT_OF_MEMORY;
+	goto end;
+      }
+
+      memset(&abs_data_path, 0, sizeof(struct sc_path));
+      memset(&data_card_path, 0, sizeof(struct sc_path));      	
+      memset(&def_path, 0, sizeof(struct sc_path));
+
+      
+      if(data->path.len == 4) {
+        sc_format_path("3F00", &def_path);
+   	r = sc_append_path(&def_path, &data->path);
+
+	if(r!=SC_SUCCESS)
+	  goto end;
+
+        memcpy(data->path.value, def_path.value, def_path.len);
+        data->path.len = 6;
+
+      } else {
+        memcpy(&def_path, &data->path, sizeof(data->path));
+      }
+
+      r = sc_append_path(&abs_data_path, &def_path);
+      if(r!=SC_SUCCESS)
+	goto end;
+
+      if(abs_data_path.len==6) {
+	r = sc_append_path(&data_card_path, &def_path);
+	if(r!=SC_SUCCESS)
+	  goto end;
+      }      
+
+      memcpy(&data_virtual_file->path, &abs_data_path, sizeof(data_virtual_file->path));
+      r = map_path_to_path_set_item(DRVDATA(card)->virtual_fs_to_card_path_map, &data_virtual_file->path, &data_card_path);
+      if(r != SC_SUCCESS)
+	goto end;
+      data_virtual_file->is_ef = 1;
+
+      data_virtual_file->card_to_virtual_fs.sync_state = virtual_file_sync_state_sync_pending;
+      data_virtual_file->card_to_virtual_fs.sync_callback = card_sync_card_to_virtual_fs_data_file_callback;
+      data_virtual_file->virtual_fs_to_card.sync_state = virtual_file_sync_state_unknown;
+      data_virtual_file->virtual_fs_to_card.sync_callback = NULL;
+      
+      /* append file to virtual_fs */
+      r = virtual_fs_append(virtual_fs, data_virtual_file);
+      if(r != SC_SUCCESS)
+	goto end;
+
+      /* we don't have ownership of virtual_file now,
+	 so we don't need to free it */
+      data_virtual_file_weak_link = data_virtual_file;
+      data_virtual_file = NULL;
+        
+      /* we now synchronize file because this gets a correct size for it */
+      r = virtual_file_data_synchronize(data_virtual_file_weak_link, card, virtual_file_sync_type_card_to_virtual_fs, DRVDATA(card)->virtual_fs);
+      if (r != SC_SUCCESS) {
+	sc_error(card->ctx, "Synchronization failed\n");
+	goto end;
+      }
+      
+      /* correct length in PKCS#15 */
+      data->path.count = data_virtual_file_weak_link->data_size;
+      obj->auth_id.value[0]=0x01;
+      obj->auth_id.len=0x01;
+    } else {
+      sc_debug(card->ctx, "Path length is 0");
+    }
+  } else {
+    sc_debug(card->ctx, "Pointer to data info was empty");
+  }
+
+ end:
+  if(card_data) {
+    free(card_data);
+    card_data = NULL;
+  }
+
+  if(data_virtual_file) {
+    virtual_file_free(data_virtual_file);
+    data_virtual_file = NULL;
+  }
+
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+int card_sync_card_to_virtual_fs_any_df( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, int type )
+{
+  int r = SC_SUCCESS;
+  unsigned char *encoded_pkcs15 = NULL;
+  size_t encoded_pkcs15_size = 0;
+  sc_pkcs15_card_t *temp_pkcs15_card  = NULL;
+  sc_pkcs15_object_t *obj = NULL;
+  unsigned char *card_data = NULL;
+  size_t card_data_length = 0;  
+  
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if(!card || !virtual_file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  /* get file */
+  r = card_helper_read_file(card, &virtual_file->path, &card_data, &card_data_length);
+  if(r < 0)
+    goto end;
+
+  /* create a new pkcs15_card structure */
+  temp_pkcs15_card = sc_pkcs15_card_new();
+  if(!temp_pkcs15_card) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto end;
+  }
+
+  /* we set some important fields */
+  temp_pkcs15_card->card = card;
+  temp_pkcs15_card->file_app = sc_file_new();
+  if (!temp_pkcs15_card->file_app) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto end;
+  }
+  sc_format_path("3F00", &temp_pkcs15_card->file_app->path);
+  // temp_pkcs15_card->flags=SC_PKCS15_TOKEN_PRN_GENERATION | SC_PKCS15_TOKEN_EID_COMPLIANT;
+
+  /* Convert card df read to a list of same type of pkcs15 objects. 
+     This function uses our internal card decoding parser.
+  */
+  r = sc_pkcs15_parse_card_df( temp_pkcs15_card, 
+			       type, 
+			       card_data, 
+			       card_data_length
+                               );
+  if(r != SC_SUCCESS) {
+    sc_error(card->ctx, "Card parsing failed\n"); 
+    goto end;
+  }
+
+  /* we need to correct some PKCS#15 data */
+  for(obj = temp_pkcs15_card->obj_list; obj != NULL; obj = obj->next) {
+    switch(obj->type & SC_PKCS15_TYPE_CLASS_MASK) {
+    case SC_PKCS15_TYPE_CERT:
+      r = card_sync_card_to_virtual_fs_filter_cert(card, virtual_file, virtual_fs, obj);
+      break;
+
+    case SC_PKCS15_TYPE_PRKEY:
+      r = card_sync_card_to_virtual_fs_filter_prkey(card, virtual_file, virtual_fs, obj);
+      break;
+      
+    case SC_PKCS15_TYPE_PUBKEY:
+      r = card_sync_card_to_virtual_fs_filter_pukey(card, virtual_file, virtual_fs, obj);
+      break;
+
+    case SC_PKCS15_TYPE_AUTH:
+      if(obj->data) {
+	sc_pkcs15_pin_info_t * pin=obj->data;
+	/* remove security officer pin */
+	pin->flags &= (~SC_PKCS15_PIN_FLAG_SO_PIN);
+	sc_format_path("3F00", &pin->path);		
+	pin->stored_length= (pin->max_length>pin->stored_length) ? pin->max_length : pin->stored_length;
+      }
+      break;
+
+    case SC_PKCS15_TYPE_DATA_OBJECT:
+      r = card_sync_card_to_virtual_fs_filter_data_object(card, virtual_file, virtual_fs, obj);
+      break;
+
+    default:
+      /* ignore this object */
+      break;
+    }
+  }
+  if(r != SC_SUCCESS) {
+    sc_error(card->ctx, "Object filtering failed\n");
+    goto end;
+  }
+ 
+
+  /* generate pkcs#15 stream for the appropiate object type */
+  r = sc_standard_pkcs15_encode_any_df( card->ctx, 
+					temp_pkcs15_card, 
+					type, /* encode only specific objects type */
+					&encoded_pkcs15,
+					&encoded_pkcs15_size
+                                        );
+  if(r != SC_SUCCESS) {
+    sc_error(card->ctx, "Standard PKCS#15 encoding failed\n"); 
+    goto end;
+  }
+    
+  r = virtual_file_data_update(virtual_file, 0, encoded_pkcs15, encoded_pkcs15_size);
+  if(r == SC_SUCCESS) {
+    /* add a trailing 0 */
+    r = virtual_file_data_update(virtual_file, encoded_pkcs15_size, (const unsigned char *)"\0", 1);
+  }
+
+ end:
+  if(card_data) {
+    free(card_data);
+    card_data = NULL;
+  }
+
+  if(temp_pkcs15_card) { 
+    /* set to NULL without freeing because we reused structure */
+    temp_pkcs15_card->card = NULL;
+    
+    /* now free temp structure */
+    sc_pkcs15_card_free(temp_pkcs15_card);
+    temp_pkcs15_card = NULL;
+  }  
+
+  if(encoded_pkcs15) {
+    free(encoded_pkcs15);
+    encoded_pkcs15 = NULL;
+  }
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+int card_sync_card_to_virtual_fs_odf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs )
+{
+  return card_sync_card_to_virtual_fs_any_df(card, virtual_file, virtual_fs, SC_PKCS15_ODF);
+}
+
+int card_sync_card_to_virtual_fs_tokeninfo_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs )
+{
+  return card_sync_card_to_virtual_fs_any_df(card, virtual_file, virtual_fs, SC_PKCS15_TOKENINFO);
+}
+
+int card_sync_card_to_virtual_fs_aodf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs )
+{
+  return card_sync_card_to_virtual_fs_any_df(card, virtual_file, virtual_fs, SC_PKCS15_AODF);
+}
+
+int card_sync_card_to_virtual_fs_prkdf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs )
+{
+  /* use generic synchronization with PrKDF param */
+  return card_sync_card_to_virtual_fs_any_df(card, virtual_file, virtual_fs, SC_PKCS15_PRKDF);
+}
+
+int card_sync_card_to_virtual_fs_pukdf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs )
+{
+  /* use generic synchronization with PuKDF param */
+  return card_sync_card_to_virtual_fs_any_df(card, virtual_file, virtual_fs, SC_PKCS15_PUKDF);
+}
+
+int card_sync_card_to_virtual_fs_cdf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs )
+{
+  return card_sync_card_to_virtual_fs_any_df(card, virtual_file, virtual_fs, SC_PKCS15_CDF);
+}
+
+int card_sync_card_to_virtual_fs_dodf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs )
+{
+  return card_sync_card_to_virtual_fs_any_df(card, virtual_file, virtual_fs, SC_PKCS15_DODF);
+}
+
+int card_sync_virtual_fs_to_card_filter_cert( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, sc_pkcs15_object_t *obj )
+{
+  int r = SC_SUCCESS;
+  struct sc_pkcs15_cert_info *cert = NULL;
+  sc_pkcs15_der_t *der = NULL;
+  sc_path_t *path = NULL;
+  sc_pkcs15_id_t *ckaid = NULL;
+  struct _virtual_file_t *tmp_vf=NULL;
+  unsigned char *compressed_data = NULL;
+  size_t compressed_data_length = 0;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if(!card || !virtual_file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  cert = (struct sc_pkcs15_cert_info *) obj->data;
+  if(cert) {
+    sc_der_clear(&obj->der);
+    // sc_pkcs15_free_object_content(obj);
+
+    /* try to find an old der if present */
+    der = map_id_to_der_find(DRVDATA(card)->cdf_card_ckaid_to_card_der_map, &cert->id);
+    if(der) {
+      sc_der_copy(&obj->der, der);
+    }
+
+    path = map_path_to_path_find(DRVDATA(card)->virtual_fs_to_card_path_map, &cert->path);
+    if(path) {
+      /* replace path data */
+      memcpy(&cert->path, path, sizeof(sc_path_t));
+      
+      tmp_vf=virtual_fs_find_by_path(virtual_fs, &cert->path);
+      if(!tmp_vf) {
+	r = SC_ERROR_INVALID_DATA;
+	goto end;
+      }
+      
+      r = file_compress_data(card, tmp_vf->data, tmp_vf->data_size, &compressed_data, &compressed_data_length); 
+      if(r!=SC_SUCCESS)
+	goto end;
+
+      /* certificate file has an info header */
+      cert->path.count = compressed_data_length+8;
+    }
+
+    ckaid = map_opensc_id_to_id_find(DRVDATA(card)->virtual_fs_to_card_ckaid_map, &cert->id);
+    if(ckaid) {
+      /* replace ckaid */
+      memcpy(&cert->id, ckaid, sizeof(struct sc_pkcs15_id));
+    } else {
+      ckaid = map_path_to_id_find(DRVDATA(card)->card_path_to_card_ckaid_map, &cert->path);
+      if (ckaid) {
+	/* replace ckaid */
+	memcpy(&cert->id, ckaid, sizeof(struct sc_pkcs15_id));
+      }
+    }
+  }
+
+ end:
+  if(compressed_data) {
+    free(compressed_data);
+    compressed_data = NULL;
+  }
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+int card_sync_virtual_fs_to_card_filter_prkey( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, sc_pkcs15_object_t *obj )
+{
+  int r = SC_SUCCESS;
+  struct sc_pkcs15_prkey_info *prkey = NULL;
+  sc_pkcs15_der_t *der = NULL;
+  sc_path_t *path = NULL;
+  sc_pkcs15_id_t *ckaid = NULL;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if(!card || !virtual_file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+  
+  prkey = (struct sc_pkcs15_prkey_info *) obj->data;
+  if(prkey) {
+    sc_der_clear(&obj->der);
+    // sc_pkcs15_free_object_content(obj);
+
+    /* try to find an old der if present */
+    der = map_id_to_der_find(DRVDATA(card)->prkdf_card_ckaid_to_card_der_map, &prkey->id);
+    if(der) {
+      sc_der_copy(&obj->der, der);
+    }
+
+    path = map_path_to_path_find(DRVDATA(card)->virtual_fs_to_card_path_map, &prkey->path);
+    if(path) {
+      /* replace path data */
+      memcpy(&prkey->path, path, sizeof(sc_path_t));
+    }
+
+    ckaid = map_opensc_id_to_id_find(DRVDATA(card)->virtual_fs_to_card_ckaid_map, &prkey->id);
+    if(ckaid) {
+      /* replace ckaid */
+      memcpy(&prkey->id, ckaid, sizeof(struct sc_pkcs15_id));
+    }
+
+    /* add manual flags */
+    prkey->native = 0x01;
+  } else {
+    sc_debug(card->ctx, "Pointer to prkey info was empty");
+  }
+
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+int card_sync_virtual_fs_to_card_filter_pukey( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, sc_pkcs15_object_t *obj )
+{
+  int r = SC_SUCCESS;
+  struct sc_pkcs15_pubkey_info *pukey = NULL;
+  sc_pkcs15_der_t *der = NULL;
+  sc_path_t *path = NULL;
+  sc_pkcs15_id_t *ckaid = NULL;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if(!card || !virtual_file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+  
+  pukey = (struct sc_pkcs15_pubkey_info *) obj->data;
+  if(pukey) {
+    sc_der_clear(&obj->der);
+    // sc_pkcs15_free_object_content(obj);
+
+    /* try to find an old der if present */
+    der = map_id_to_der_find(DRVDATA(card)->pukdf_card_ckaid_to_card_der_map, &pukey->id);
+    if(der) {
+      sc_der_copy(&obj->der, der);
+    }
+
+    path = map_path_to_path_find(DRVDATA(card)->virtual_fs_to_card_path_map, &pukey->path);
+    if(path) {
+      /* replace path data */
+      memcpy(&pukey->path, path, sizeof(sc_path_t));
+    }
+
+    ckaid = map_opensc_id_to_id_find(DRVDATA(card)->virtual_fs_to_card_ckaid_map, &pukey->id);
+    if(ckaid) {
+      /* replace ckaid */
+      memcpy(&pukey->id, ckaid, sizeof(struct sc_pkcs15_id));
+    }
+        /* add manual flags */
+    pukey->native = 0x01;
+    pukey->access_flags |= SC_PKCS15_PRKEY_ACCESS_LOCAL;
+    pukey->access_flags |= SC_PKCS15_PRKEY_ACCESS_EXTRACTABLE;
+    pukey->key_reference = pukey->path.value[pukey->path.len-1];
+  } else {
+    sc_debug(card->ctx, "Pointer to pukey info was empty");
+  }
+
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+int card_sync_virtual_fs_to_card_any_df( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, int type )
+{
+  int r = SC_SUCCESS;
+  sc_pkcs15_card_t *temp_pkcs15_card  = NULL;
+  sc_pkcs15_object_t *obj = NULL;
+  card_pkcs15_df_t p15_df;
+  sc_pkcs15_df_t df;
+  u8 *translated_buf = NULL;
+  size_t translated_bufsize = 0;
+  u8 *card_buf = NULL;
+  size_t card_bufsize = 0;
+
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if(!card || !virtual_file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  /* init p15_df structure */
+  memset(&p15_df, 0, sizeof(p15_df));
+  p15_df.type = type;
+
+  /* virtualfs keeps buffer ownership */
+  p15_df.data = virtual_file->data;
+  p15_df.data_len = virtual_file->data_size;
+  p15_df.file_len = virtual_file->data_size;
+  p15_df.filled_len = virtual_file->data_size;
+
+  /* We parse PKCS#15 using a standard parser */
+  r = card_parse_standard_pkcs15(card, &p15_df, &df, &temp_pkcs15_card);
+  if(r != SC_SUCCESS) {
+    if (card->ctx->debug) sc_debug(card->ctx, "Parsing of standard PKCS#15 failed\n");
+    goto end;
+  }
+
+  /* we need to correct some PKCS#15 data */
+  for(obj = temp_pkcs15_card->obj_list; obj != NULL; obj = obj->next) {
+    switch(obj->type & SC_PKCS15_TYPE_CLASS_MASK) {
+    case SC_PKCS15_TYPE_CERT:
+      {
+	r = card_sync_virtual_fs_to_card_filter_cert(card, virtual_file, virtual_fs, obj);
+      }
+      break;
+
+    case SC_PKCS15_TYPE_PRKEY:
+      {
+	r = card_sync_virtual_fs_to_card_filter_prkey(card, virtual_file, virtual_fs, obj);
+      }
+      break;
+
+    case SC_PKCS15_TYPE_PUBKEY:
+      {
+	r = card_sync_virtual_fs_to_card_filter_pukey(card, virtual_file, virtual_fs, obj);
+      }
+      break;
+      
+    default:
+      /* ignore this object */
+      break;
+    }
+  }
+  if(r != SC_SUCCESS) {
+    sc_error(card->ctx, "Object filtering failed\n");
+    goto end;
+  }
+
+  /* We encode PKCS#15 using DNIe PKCS#15 */
+  r = sc_pkcs15_card_encode_df(card->ctx,
+                               temp_pkcs15_card,
+                               &df,
+                               &translated_buf,
+                               &translated_bufsize);
+ 
+  if(r != SC_SUCCESS) {
+    sc_error(card->ctx, "DNIe PKCS#15 encoding failed\n"); 
+    goto end;
+  }
+
+  card_bufsize = translated_bufsize+1;
+  card_buf = (u8 *) malloc(card_bufsize);
+  if(!card_buf) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto end;
+  }
+      
+  memcpy(card_buf, translated_buf, translated_bufsize);
+  card_buf[translated_bufsize] = 0x00;
+
+  r = card_helper_update_file( card, &virtual_file->path, card_buf, card_bufsize);
+  if(r != SC_SUCCESS) {
+    sc_error(card->ctx, "DNIe PKCS#15 encoding failed\n"); 
+    goto end;
+  } 
+ end:
+  if(translated_buf) {
+    memset(translated_buf, 0, translated_bufsize);
+    free(translated_buf);
+    translated_buf = NULL;
+    translated_bufsize = 0;
+  }
+
+  if(card_buf) {
+    memset(card_buf, 0, card_bufsize);
+    free(card_buf);
+    card_buf = NULL;
+    card_bufsize = 0;
+  }
+
+  if(temp_pkcs15_card) { 
+    /* set to NULL without freeing because we reused structure */
+    temp_pkcs15_card->card = NULL;
+    
+    /* now free temp structure */
+    sc_pkcs15_card_free(temp_pkcs15_card);
+    temp_pkcs15_card = NULL;
+  }  
+
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+int card_sync_virtual_fs_to_card_cdf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs )
+{
+  /* use generic synchronization with CDF param */
+  return card_sync_virtual_fs_to_card_any_df(card, virtual_file, virtual_fs, SC_PKCS15_CDF);
+}
+
+int card_sync_virtual_fs_to_card_prkdf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs )
+{
+  /* use generic synchronization with PrKDF param */
+  return card_sync_virtual_fs_to_card_any_df(card, virtual_file, virtual_fs, SC_PKCS15_PRKDF);
+}
+
+int card_sync_virtual_fs_to_card_pukdf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs )
+{
+  /* use generic synchronization with PrKDF param */
+  return card_sync_virtual_fs_to_card_any_df(card, virtual_file, virtual_fs, SC_PKCS15_PUKDF);
+}
+
+int card_sync_card_to_virtual_fs_certificate_file_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs )
+{
+  int r = SC_SUCCESS;
+  unsigned char *card_data = NULL;
+  unsigned char *uncompressed_data = NULL;
+  size_t card_data_length = 0;
+  size_t uncompressed_data_length = 0;
+  sc_path_t *path=NULL;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if(!card || !virtual_file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  path=NULL;
+  path = map_path_to_path_find(DRVDATA(card)->virtual_fs_to_card_path_map, &virtual_file->path);
+  if(!path) {
+    r = SC_ERROR_OBJECT_NOT_FOUND;
+    goto end;
+  }
+
+  /* get file */
+  r = card_helper_read_certificate_file(card, path, &card_data, &card_data_length);
+  if (r!=SC_SUCCESS)
+    goto end;
+  if (card_data_length>0) {     
+    r = file_uncompress_data(card, card_data, card_data_length, &uncompressed_data, &uncompressed_data_length); 
+    if(r < 0)
+      goto end;
+    
+    r = virtual_file_data_update(virtual_file, 0, uncompressed_data, uncompressed_data_length);
+    if(r != SC_SUCCESS)
+      goto end;
+  }
+ end:
+  if(card_data) {
+    free(card_data);
+    card_data = NULL;
+  }
+
+  if(uncompressed_data) {
+    free(uncompressed_data);
+    uncompressed_data = NULL;
+  }
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+
+int card_sync_virtual_fs_to_card_certificate_file_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs )
+{
+  int r = SC_SUCCESS;
+  unsigned char *compressed_data = NULL;
+  size_t compressed_data_length = 0;
+  struct _virtual_file_t *certificate_virtual_file=NULL;
+  sc_pkcs15_id_t *card_ckaid=NULL;
+  sc_path_t *cert_path=NULL;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if(!card || !virtual_file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+  
+  r = file_compress_data(card, virtual_file->data, virtual_file->data_size, &compressed_data, &compressed_data_length); 
+  if(r!=SC_SUCCESS)
+    goto cert_vfs2c_end;
+
+  /* create certificate file into card */
+  r = card_helper_create_cert_file(card, virtual_file, compressed_data_length, &certificate_virtual_file);
+  if(r!=SC_SUCCESS)
+    goto cert_vfs2c_end;
+
+  /* set file data to card */
+  r = card_helper_update_file(card, &certificate_virtual_file->path, compressed_data, compressed_data_length);
+  if(r!=SC_SUCCESS)
+    goto cert_vfs2c_end;
+
+  /* add path_to_path */
+  r = map_path_to_path_set_item(DRVDATA(card)->virtual_fs_to_card_path_map, &virtual_file->path, &certificate_virtual_file->path);
+  if(r != SC_SUCCESS)
+    goto cert_vfs2c_end;
+
+  /* get ckaid from certificate (computeing a sha1 form public key modulus) */
+  card_ckaid = calloc(1, sizeof(struct sc_pkcs15_id));
+  if (!card_ckaid) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto cert_vfs2c_end;
+  }
+  r = get_ckaid_from_certificate( card, virtual_file->data, virtual_file->data_size, card_ckaid );
+  if(r!=SC_SUCCESS)
+    goto cert_vfs2c_end;
+
+  cert_path = calloc(1, sizeof(struct sc_path));
+  if(!cert_path) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto cert_vfs2c_end;
+  }
+  memcpy(cert_path, &certificate_virtual_file->path, sizeof(struct sc_path));
+  r = map_path_to_id_set_item(DRVDATA(card)->card_path_to_card_ckaid_map, cert_path, card_ckaid);
+  if(r!=SC_SUCCESS)
+    goto cert_vfs2c_end;
+
+  /* ownership regards to vfs */
+  certificate_virtual_file=NULL;
+  card_ckaid=NULL;
+  cert_path=NULL;
+    
+ cert_vfs2c_end:
+  if(compressed_data) {
+    free(compressed_data);
+    compressed_data = NULL;
+  }
+  if(certificate_virtual_file) {
+    free(certificate_virtual_file);
+    certificate_virtual_file=NULL;
+  }
+  if(card_ckaid) {
+    free(card_ckaid);
+    card_ckaid=NULL;
+  }
+  if(cert_path) {
+    free(cert_path);
+    cert_path=NULL;
+  }
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+int card_sync_card_to_virtual_fs_data_file_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs )
+{
+  int r = SC_SUCCESS;
+  unsigned char *card_data = NULL;
+  size_t card_data_length = 0;
+  sc_path_t *path=NULL;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if(!card || !virtual_file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  path = map_path_to_path_find(DRVDATA(card)->virtual_fs_to_card_path_map, &virtual_file->path);
+  if(!path) {
+    r = SC_ERROR_OBJECT_NOT_FOUND;
+    goto end;
+  }
+
+  /* get file */
+  r = card_helper_read_file(card, path, &card_data, &card_data_length);
+  if (r!=SC_SUCCESS)
+    goto end;
+  if (card_data_length>0) {
+    r = virtual_file_data_update(virtual_file, 0, card_data, card_data_length);
+    if(r != SC_SUCCESS)
+      goto end;
+  }
+ end:
+  if(card_data) {
+    free(card_data);
+    card_data = NULL;
+  }
+
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
Index: opensc-0.11.12/src/libopensc/dnie/card_sync.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/card_sync.h	2010-11-17 19:14:03.000000000 +0000
@@ -0,0 +1,361 @@
+/*!
+ * \file card_sync.h
+ * \brief Card synchronization functions
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardía Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#ifndef CARD_SYNC_H
+#define CARD_SYNC_H
+
+/* include for all virtual_* definitions */
+#include "virtual_fs.h"
+#include <opensc/pkcs15.h>
+
+/*!
+  Function to filter object fields from certificate PKCS#15
+  objects called when loading objects from the card
+
+  It also loads certificates from the card and adds it to
+  the virtual_fs
+  
+  \param card Struct to access the card
+  \param virtual_file this is CDF virtual file
+  \param virtual_fs Virtual fs pointer.
+  \param obj PKCS#15 object
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_card_to_virtual_fs_filter_cert( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, sc_pkcs15_object_t *obj );
+
+/*!
+  Function to filter object fields from prkey PKCS#15
+  objects called when loading objects from the card
+
+  \param card Struct to access the card
+  \param virtual_file this is PrKDF virtual file
+  \param virtual_fs Virtual fs pointer.
+  \param obj PKCS#15 object
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_card_to_virtual_fs_filter_prkey( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, sc_pkcs15_object_t *obj );
+
+/*!
+  Function to filter object fields from pukey PKCS#15
+  objects called when loading objects from the card
+
+  \param card Struct to access the card
+  \param virtual_file this is PuKDF virtual file
+  \param virtual_fs Virtual fs pointer.
+  \param obj PKCS#15 object
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_card_to_virtual_fs_filter_pukey( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, sc_pkcs15_object_t *obj );
+
+/*!
+  Function to filter object fields from data object PKCS#15
+  objects called when loading objects from the card
+
+  \param card Struct to access the card
+  \param virtual_file this is DODF virtual file
+  \param virtual_fs Virtual fs pointer.
+  \param obj PKCS#15 object
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_card_to_virtual_fs_filter_data_object( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, sc_pkcs15_object_t *obj );
+
+/*!
+  Function to synchronize any PKCS#15 file from the card. It
+  follows the virtual_file_sync_callback definition except for
+  an extra file_type parameter.
+
+  This synchronization might need inclusion of new files into
+  virtual_fs as a side effect (for instance: new certificate data
+  files).
+  
+  \param card Struct to access the card
+  \param virtual_file this is virtual file to sync
+  \param virtual_fs Virtual fs pointer.
+  \param type PKCS#15 object type in encoding
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_card_to_virtual_fs_any_df( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, int type );
+
+
+/*!
+  Callback to synchronize a ODF PKCS#15 file from the card. It
+  follows the virtual_file_sync_callback definition.
+
+  This synchronization might need inclusion of new files into
+  virtual_fs as a side effect (for instance: new certificate data
+  files).
+  
+  \param card Struct to access the card
+  \param virtual_file this is ODF virtual file
+  \param virtual_fs Virtual fs pointer.
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_card_to_virtual_fs_odf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs );
+
+/*!
+  Callback to synchronize a TokenInfo PKCS#15 file from the card. It
+  follows the virtual_file_sync_callback definition.
+
+  This synchronization might need inclusion of new files into
+  virtual_fs as a side effect (for instance: new certificate data
+  files).
+  
+  \param card Struct to access the card
+  \param virtual_file this is TokenInfo virtual file
+  \param virtual_fs Virtual fs pointer.
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_card_to_virtual_fs_tokeninfo_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs );
+
+/*!
+  Callback to synchronize a AODF PKCS#15 file from the card. It
+  follows the virtual_file_sync_callback definition.
+
+  This synchronization might need inclusion of new files into
+  virtual_fs as a side effect (for instance: new certificate data
+  files).
+  
+  \param card Struct to access the card
+  \param virtual_file this is AODF virtual file
+  \param virtual_fs Virtual fs pointer.
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_card_to_virtual_fs_aodf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs );
+
+/*!
+  Callback to synchronize PRKDF from the card. It
+  follows the virtual_file_sync_callback definition.
+
+  It internally uses card_sync_card_to_virtual_fs_any_df() with SC_PKCS15_PRKDF in type param.
+
+  This synchronization might need inclusion of new files into
+  virtual_fs as a side effect (for instance: new certificate data
+  files).
+  
+  \param card Struct to access the card
+  \param virtual_file this is PrKDF virtual file
+  \param virtual_fs Virtual fs pointer.
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_card_to_virtual_fs_prkdf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs );
+
+/*!
+  Callback to synchronize PUKDF from the card. It
+  follows the virtual_file_sync_callback definition.
+
+  It internally uses card_sync_card_to_virtual_fs_any_df() with SC_PKCS15_PUKDF in type param.
+
+  This synchronization might need inclusion of new files into
+  virtual_fs as a side effect (for instance: new certificate data
+  files).
+  
+  \param card Struct to access the card
+  \param virtual_file this is PuKDF virtual file
+  \param virtual_fs Virtual fs pointer.
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_card_to_virtual_fs_pukdf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs );
+
+/*!
+  Callback to synchronize CDF from the card. It
+  follows the virtual_file_sync_callback definition.
+
+  It internally uses card_sync_card_to_virtual_fs_any_df() with SC_PKCS15_CDF in type param.
+
+  This synchronization might need inclusion of new files into
+  virtual_fs as a side effect (for instance: new certificate data
+  files).
+  
+  \param card Struct to access the card
+  \param virtual_file this is CDF virtual file
+  \param virtual_fs Virtual fs pointer.
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_card_to_virtual_fs_cdf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs );
+
+/*!
+  Callback to synchronize DODF from the card. It
+  follows the virtual_file_sync_callback definition.
+
+  It internally uses card_sync_card_to_virtual_fs_any_df() with SC_PKCS15_DODF in type param.
+
+  This synchronization might need inclusion of new files into
+  virtual_fs as a side effect (for instance: new certificate data
+  files).
+  
+  \param card Struct to access the card
+  \param virtual_file this is DODF virtual file
+  \param virtual_fs Virtual fs pointer.
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_card_to_virtual_fs_dodf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs );
+
+/*!
+  Function to filter object fields from certificate PKCS#15
+  objects called when loading objects from the card
+
+  It also loads certificates from the card and adds it to
+  the virtual_fs
+  
+  \param card Struct to access the card
+  \param virtual_file this is CDF virtual file
+  \param virtual_fs Virtual fs pointer.
+  \param obj PKCS#15 object
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_virtual_fs_to_card_filter_cert( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, sc_pkcs15_object_t *obj );
+
+/*!
+  Function to filter object fields from prkey PKCS#15
+  objects called when loading objects from the card
+
+  \param card Struct to access the card
+  \param virtual_file this is PrKDF virtual file
+  \param virtual_fs Virtual fs pointer.
+  \param obj PKCS#15 object
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_virtual_fs_to_card_filter_prkey( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, sc_pkcs15_object_t *obj );
+
+/*!
+  Function to filter object fields from pukey PKCS#15
+  objects called when loading objects from the card
+
+  \param card Struct to access the card
+  \param virtual_file this is PuKDF virtual file
+  \param virtual_fs Virtual fs pointer.
+  \param obj PKCS#15 object
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_virtual_fs_to_card_filter_pukey( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, sc_pkcs15_object_t *obj );
+
+/*!
+  Function to synchronize any PKCS#15 file to the card. It
+  follows the virtual_file_sync_callback definition except for
+  an extra file_type parameter.
+
+  \param card Struct to access the card
+  \param virtual_file this is PuKDF virtual file
+  \param virtual_fs Virtual fs pointer.
+  \param type PKCS#15 object type in encoding
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_virtual_fs_to_card_any_df( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs, int type );
+
+/*!
+  Callback to synchronize CDF to the card. It
+  follows the virtual_file_sync_callback definition.
+
+  It internally uses card_sync_virtual_fs_to_card_any_df()
+  with SC_PKCS15_CDF in type param.
+
+  \param card Struct to access the card
+  \param virtual_file this is CDF virtual file
+  \param virtual_fs Virtual fs pointer.
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_virtual_fs_to_card_cdf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs );
+
+/*!
+  Callback to synchronize PRKDF to the card. It
+  follows the virtual_file_sync_callback definition.
+
+  It internally uses card_sync_virtual_fs_to_card_any_df()
+  with SC_PKCS15_PRKDF in type param.
+
+  \param card Struct to access the card
+  \param virtual_file this is PrKDF virtual file
+  \param virtual_fs Virtual fs pointer.
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_virtual_fs_to_card_prkdf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs );
+
+/*!
+  Callback to synchronize PUKDF to the card. It
+  follows the virtual_file_sync_callback definition.
+
+  It internally uses card_sync_virtual_fs_to_card_any_df()
+  with SC_PKCS15_PUKDF in type param.
+
+  \param card Struct to access the card
+  \param virtual_file this is PuKDF virtual file
+  \param virtual_fs Virtual fs pointer.
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_virtual_fs_to_card_pukdf_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs );
+
+/*!
+  Callback to synchronize a certificate file from the card. It
+  follows the virtual_file_sync_callback definition.
+
+  \param card Struct to access the card
+  \param virtual_file this is CDF virtual file
+  \param virtual_fs Virtual fs pointer.
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_card_to_virtual_fs_certificate_file_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs );
+
+/*!
+  Callback to synchronize a certificate file from virtual fs to the card. It
+  follows the virtual_file_sync_callback definition.
+
+  \param card Struct to access the card
+  \param virtual_file this is certificate virtual file
+  \param virtual_fs Virtual fs pointer.
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_virtual_fs_to_card_certificate_file_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs );
+
+/*!
+  Callback to synchronize a data object file from virtual fs to the card. It
+  follows the virtual_file_sync_callback definition.
+
+  \param card Struct to access the card
+  \param virtual_file this is data object virtual file
+  \param virtual_fs Virtual fs pointer.
+
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int card_sync_card_to_virtual_fs_data_file_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, virtual_fs_t *virtual_fs );
+
+#endif /* CARD_SYNC_H */
Index: opensc-0.11.12/src/libopensc/dnie/dialog.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/dialog.c	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,135 @@
+/*
+ * User consent function
+ * Based on dialog.c from opensc-0.11.14
+ * And original code from DGP's DNIe module
+ */
+
+/* 
+ * IMPORTANT NOTICE:
+ * This code may don't work on:
+ * - Headless systems
+ * - Sites without pinentry / libassuan properly installed
+ * So to handle this, we provide several flags at /etc/opensc.conf:
+ * ....
+ *     card_driver dnie {
+ *          # Enable/Disable user consent on signing (default: enable)
+ *          user_consent_enabled = true;
+ *          # Program to be used for ask confirmation (default: pinentry)
+ *          user_consent_app = /usr/bin/pinentry;
+ *     }
+ * .....
+ * NOTICE that disable User Consent may result on unnoticed signing if 
+ * used on unsecure environments and/or with bad designed/uncertified apps
+ *
+ */
+
+#include <stdio.h>
+#include <assuan.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+
+#include <opensc/opensc.h>
+#include <opensc/errors.h>
+#include <opensc/log.h>
+
+#ifndef PIN_ENTRY
+#define PIN_ENTRY "/usr/bin/pinentry"
+#endif
+
+static char *user_consent_app=PIN_ENTRY;
+static int  user_consent_enabled=1; /* default true */
+
+/* check for libassuan version */
+#ifndef ASSUAN_No_Error
+#define HAVE_ASSUAN_2
+#define _gpg_error(t) gpg_strerror((t))
+#else
+#define HAVE_ASSUAN_1
+#define _gpg_error(t) assuan_strerror( (AssuanError) (t) )
+#endif
+
+
+/**
+ * Parse configuration file to extract user consent flags
+ */
+static int get_user_consent_env(sc_context_t *ctx) {
+    int i;
+    scconf_block **blocks, *blk;
+    for (i = 0; ctx->conf_blocks[i]; i++) {
+        blocks = scconf_find_blocks(ctx->conf, ctx->conf_blocks[i],"card_driver","dnie");
+        if (!blocks) continue;
+        blk=blocks[0];
+        free(blocks);
+        if (blk==NULL) continue;
+        user_consent_app = scconf_get_str(blk,"user_consent_app",PIN_ENTRY); 
+        user_consent_enabled = scconf_get_bool(blk,"user_consent_enabled",1);
+    }
+    return SC_SUCCESS;
+}
+
+int ask_user_consent(sc_card_t *card) {
+    int res;
+    struct stat buf;
+    const char *argv[3];
+    assuan_fd_t noclosefds[2];
+    assuan_context_t ctx; 
+    if ( (card==NULL) || (card->ctx==NULL)) return SC_ERROR_INVALID_ARGUMENTS;
+    get_user_consent_env(card->ctx);
+    res=stat(user_consent_app,&buf);
+    if (res!=0) {
+      /* TODO: check that pinentry file is executable */
+      sc_debug(card->ctx,"Invalid pinentry application: %s\n",user_consent_app);
+      SC_FUNC_RETURN(card->ctx,1,SC_ERROR_INVALID_ARGUMENTS);
+    }
+    argv[0]=user_consent_app;
+    argv[1]=NULL;
+    argv[2]=NULL;
+    noclosefds[0]= fileno(stderr);
+    noclosefds[1]= ASSUAN_INVALID_FD;
+#ifdef HAVE_ASSUAN_2
+    res = assuan_new(&ctx);
+    if (res!=0) {
+      sc_debug(card->ctx,"Can't create the User Consent environment: %s\n",_gpg_error(res));
+      SC_FUNC_RETURN(card->ctx,1,SC_ERROR_INVALID_ARGUMENTS);
+    }
+    res = assuan_pipe_connect(ctx,user_consent_app,argv,noclosefds,NULL,NULL,0);
+#else 
+    res = assuan_pipe_connect(&ctx,user_consent_app,argv,0);
+#endif
+    if (res!=0) {
+        sc_debug(card->ctx,"Can't connect to the User Consent module: %s\n",_gpg_error(res));
+        res=SC_ERROR_INVALID_ARGUMENTS; /* invalid or not available pinentry */
+        goto exit;
+    }
+    res = assuan_transact(
+       ctx, 
+       "SETDESC Está a punto de realizar una firma electrónica con su clave de FIRMA del DNI electrónico.¿Desea permitir esta operación?", 
+       NULL, NULL, NULL, NULL, NULL, NULL);
+    if (res!=0) {
+       sc_debug(card->ctx,"SETDESC: %s\n", _gpg_error(res));
+       res=SC_ERROR_CARD_CMD_FAILED; /* perhaps should use a better errcode */
+       goto exit;
+    }
+    res = assuan_transact(ctx,"CONFIRM",NULL,NULL,NULL,NULL,NULL,NULL);
+#ifdef HAVE_ASSUAN_1
+    if (res == ASSUAN_Canceled) {
+       sc_debug(card->ctx,"Sign cancelled by user");
+       res= SC_ERROR_NOT_ALLOWED;
+       goto exit;
+    }
+#endif
+    if (res) {
+       sc_debug(card->ctx,"SETERROR: %s\n",_gpg_error(res));
+       res=SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;
+     } else {
+       res=SC_SUCCESS;
+     }
+exit:
+#ifdef HAVE_ASSUAN_2
+    assuan_release(ctx);
+#else
+    assuan_disconnect(ctx);
+#endif
+    SC_FUNC_RETURN(card->ctx,1,res);
+}
Index: opensc-0.11.12/src/libopensc/dnie/file_compression.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/file_compression.c	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,152 @@
+/*!
+ * \file file_compression.h
+ * \brief File compression functions
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+
+#include "file_compression.h"
+#include <opensc/opensc.h>
+#include <opensc/log.h>
+#include <zlib.h>
+#include <string.h>
+#include "util.h"
+#include <stdlib.h>
+#include <assert.h>
+
+int file_uncompress_data(struct sc_card *card, u8 * data, size_t length, u8 **uncompressed_data, size_t *uncompressed_data_length )
+{
+  size_t compressed_data_length;
+  int r = SC_SUCCESS, pos=0;
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  /* zlib header; uncompressed length + compressed length: always will be 8 bytes */
+  pos = 8;	
+  *uncompressed_data_length = lebytes2ulong(data);
+  compressed_data_length = lebytes2ulong(data+4);
+
+  *uncompressed_data = (u8 *) calloc(*uncompressed_data_length, sizeof(u8));		
+  if (!*uncompressed_data)		
+    return SC_ERROR_OUT_OF_MEMORY;
+
+  if(compressed_data_length < *uncompressed_data_length) {
+    r = uncompress(*uncompressed_data, (unsigned long *)uncompressed_data_length, data+pos, length-pos);			
+    if(r!=Z_OK) {
+      free(*uncompressed_data);		
+      return r;
+    }
+    r = SC_SUCCESS;
+  }  else {
+    memcpy(*uncompressed_data, data+pos, *uncompressed_data_length);
+    r = SC_SUCCESS;
+  }
+
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
+
+int file_compress_data(struct sc_card *card, 
+		       u8 * uncompressed_data, size_t uncompressed_data_length, 
+		       u8 **compressed_data, size_t *compressed_data_length )
+{
+  int r = SC_SUCCESS;
+  u8 *tmp_compressed_data=NULL, header[8];
+  unsigned long tmp_compressed_data_len=0;
+  size_t complen=0, unclen=0;
+
+  assert(card!=NULL && uncompressed_data!=NULL && compressed_data!=NULL && 
+	 compressed_data_length!=NULL);
+
+  SC_FUNC_CALLED(card->ctx, 1);
+
+  if(*compressed_data) {
+    free(*compressed_data);
+    *compressed_data = NULL;
+  }
+  *compressed_data_length = 0;
+
+  /* Compress certificate and get compressed length */
+  /* make room for a new one */
+  /* compress function says to make room for at least 0.1% more plus 8. 
+     We make sure everything is ok by using a little bit more   */
+
+  tmp_compressed_data_len = (unsigned long) uncompressed_data_length*1.002+8+1;
+  tmp_compressed_data = (u8 *) calloc(1, tmp_compressed_data_len);
+  if (!tmp_compressed_data) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto fcd_end;
+  }
+    
+  r = compress( tmp_compressed_data, 
+		&tmp_compressed_data_len, 
+		uncompressed_data, 
+		uncompressed_data_length );
+  if(r)
+    goto fcd_end;
+
+  unclen = uncompressed_data_length;
+  complen = tmp_compressed_data_len;
+   
+  if ( complen > unclen ) {
+    /* we keep the uncompressed certificate */
+    if (*compressed_data)
+      *compressed_data_length = unclen;
+
+    r = push_back_data2buf( compressed_data, 
+			    compressed_data_length,
+			    uncompressed_data,
+			    uncompressed_data_length );
+    if(r!=SC_SUCCESS)
+      goto fcd_end;
+
+  } else {
+    /* we keep the compressed certificate */
+    if (*compressed_data)
+      *compressed_data_length = complen;
+
+    r = push_back_data2buf( compressed_data, 
+			    compressed_data_length,
+			    tmp_compressed_data, 
+			    tmp_compressed_data_len );
+    if(r!=SC_SUCCESS)
+      goto fcd_end;
+
+  }
+
+  /* Add 8 header compress info bytes to certificate data */
+  memset(header, 0, 8);
+  ulong2lebytes(header, unclen);
+  ulong2lebytes(header+4, *compressed_data_length);
+
+  r = push_front_data2buf( compressed_data, 
+			   compressed_data_length,
+			   header,
+			   8 );
+  if (r!=SC_SUCCESS)
+    goto fcd_end;
+
+ fcd_end:
+  /* free buffers */
+  if (tmp_compressed_data) {
+    free(tmp_compressed_data);
+    tmp_compressed_data=NULL;
+  }
+
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
Index: opensc-0.11.12/src/libopensc/dnie/file_compression.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/file_compression.h	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,35 @@
+/*!
+ * \file file_compression.h
+ * \brief File compression functions
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#ifndef FILE_COMPRESSION_H
+#define FILE_COMPRESSION_H
+
+#include <opensc/opensc.h>
+
+int file_uncompress_data(struct sc_card *card, u8 * data, size_t length, u8 **uncompressed_data, size_t *uncompressed_data_length );
+
+int file_compress_data(struct sc_card *card, 
+		       u8 * uncompressed_data, size_t uncompressed_data_length, 
+		       u8 **compressed_data, size_t *compressed_data_length );
+
+#endif /* FILE_COMPRESSION_H */
+
Index: opensc-0.11.12/src/libopensc/dnie/keys.inc
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/keys.inc	2010-11-17 19:14:03.000000000 +0000
@@ -0,0 +1,75 @@
+static const u8 ifd_modulus [] = {
+   0xdb, 0x2c, 0xb4, 0x1e, 0x11, 0x2b, 0xac, 0xfa, 0x2b, 0xd7, 0xc3, 0xd3,
+   0xd7, 0x96, 0x7e, 0x84, 0xfb, 0x94, 0x34, 0xfc, 0x26, 0x1f, 0x9d, 0x09,
+   0x0a, 0x89, 0x83, 0x94, 0x7d, 0xaf, 0x84, 0x88, 0xd3, 0xdf, 0x8f, 0xbd,
+   0xcc, 0x1f, 0x92, 0x49, 0x35, 0x85, 0xe1, 0x34, 0xa1, 0xb4, 0x2d, 0xe5,
+   0x19, 0xf4, 0x63, 0x24, 0x4d, 0x7e, 0xd3, 0x84, 0xe2, 0x6d, 0x51, 0x6c,
+   0xc7, 0xa4, 0xff, 0x78, 0x95, 0xb1, 0x99, 0x21, 0x40, 0x04, 0x3a, 0xac,
+   0xad, 0xfc, 0x12, 0xe8, 0x56, 0xb2, 0x02, 0x34, 0x6a, 0xf8, 0x22, 0x6b,
+   0x1a, 0x88, 0x21, 0x37, 0xdc, 0x3c, 0x5a, 0x57, 0xf0, 0xd2, 0x81, 0x5c,
+   0x1f, 0xcd, 0x4b, 0xb4, 0x6f, 0xa9, 0x15, 0x7f, 0xdf, 0xfd, 0x79, 0xec,
+   0x3a, 0x10, 0xa8, 0x24, 0xcc, 0xc1, 0xeb, 0x3c, 0xe0, 0xb6, 0xb4, 0x39,
+   0x6a, 0xe2, 0x36, 0x59, 0x00, 0x16, 0xba, 0x69
+};
+
+static const u8 ifd_public_exponent [] = {
+   0x01, 0x00, 0x01
+};
+
+static const u8 ifd_private_exponent [] = {
+   0x18, 0xb4, 0x4a, 0x3d, 0x15, 0x5c, 0x61, 0xeb, 0xf4, 0xe3, 0x26, 0x1c,
+   0x8b, 0xb1, 0x57, 0xe3, 0x6f, 0x63, 0xfe, 0x30, 0xe9, 0xaf, 0x28, 0x89,
+   0x2b, 0x59, 0xe2, 0xad, 0xeb, 0x18, 0xcc, 0x8c, 0x8b, 0xad, 0x28, 0x4b,
+   0x91, 0x65, 0x81, 0x9c, 0xa4, 0xde, 0xc9, 0x4a, 0xa0, 0x6b, 0x69, 0xbc,
+   0xe8, 0x17, 0x06, 0xd1, 0xc1, 0xb6, 0x68, 0xeb, 0x12, 0x86, 0x95, 0xe5,
+   0xf7, 0xfe, 0xde, 0x18, 0xa9, 0x08, 0xa3, 0x01, 0x1a, 0x64, 0x6a, 0x48,
+   0x1d, 0x3e, 0xa7, 0x1d, 0x8a, 0x38, 0x7d, 0x47, 0x46, 0x09, 0xbd, 0x57,
+   0xa8, 0x82, 0xb1, 0x82, 0xe0, 0x47, 0xde, 0x80, 0xe0, 0x4b, 0x42, 0x21,
+   0x41, 0x6b, 0xd3, 0x9d, 0xfa, 0x1f, 0xac, 0x03, 0x00, 0x64, 0x19, 0x62,
+   0xad, 0xb1, 0x09, 0xe2, 0x8c, 0xaf, 0x50, 0x06, 0x1b, 0x68, 0xc9, 0xca,
+   0xbd, 0x9b, 0x00, 0x31, 0x3c, 0x0f, 0x46, 0xed
+};
+
+// Certificado en formato CVC (Card verifiable certificate)
+static const u8 C_CV_CA_CS_AUT_cert [] = {
+  0x7f, 0x21, 0x81, 0xce, 0x5f, 0x37, 0x81, 0x80, 0x3c, 0xba, 0xdc, 0x36,
+  0x84, 0xbe, 0xf3, 0x20, 0x41, 0xad, 0x15, 0x50, 0x89, 0x25, 0x8d, 0xfd,
+  0x20, 0xc6, 0x91, 0x15, 0xd7, 0x2f, 0x9c, 0x38, 0xaa, 0x99, 0xad, 0x6c,
+  0x1a, 0xed, 0xfa, 0xb2, 0xbf, 0xac, 0x90, 0x92, 0xfc, 0x70, 0xcc, 0xc0,
+  0x0c, 0xaf, 0x48, 0x2a, 0x4b, 0xe3, 0x1a, 0xfd, 0xbd, 0x3c, 0xbc, 0x8c,
+  0x83, 0x82, 0xcf, 0x06, 0xbc, 0x07, 0x19, 0xba, 0xab, 0xb5, 0x6b, 0x6e,
+  0xc8, 0x07, 0x60, 0xa4, 0xa9, 0x3f, 0xa2, 0xd7, 0xc3, 0x47, 0xf3, 0x44,
+  0x27, 0xf9, 0xff, 0x5c, 0x8d, 0xe6, 0xd6, 0x5d, 0xac, 0x95, 0xf2, 0xf1,
+  0x9d, 0xac, 0x00, 0x53, 0xdf, 0x11, 0xa5, 0x07, 0xfb, 0x62, 0x5e, 0xeb,
+  0x8d, 0xa4, 0xc0, 0x29, 0x9e, 0x4a, 0x21, 0x12, 0xab, 0x70, 0x47, 0x58,
+  0x8b, 0x8d, 0x6d, 0xa7, 0x59, 0x22, 0x14, 0xf2, 0xdb, 0xa1, 0x40, 0xc7,
+  0xd1, 0x22, 0x57, 0x9b, 0x5f, 0x38, 0x3d, 0x22, 0x53, 0xc8, 0xb9, 0xcb,
+  0x5b, 0xc3, 0x54, 0x3a, 0x55, 0x66, 0x0b, 0xda, 0x80, 0x94, 0x6a, 0xfb,
+  0x05, 0x25, 0xe8, 0xe5, 0x58, 0x6b, 0x4e, 0x63, 0xe8, 0x92, 0x41, 0x49,
+  0x78, 0x36, 0xd8, 0xd3, 0xab, 0x08, 0x8c, 0xd4, 0x4c, 0x21, 0x4d, 0x6a,
+  0xc8, 0x56, 0xe2, 0xa0, 0x07, 0xf4, 0x4f, 0x83, 0x74, 0x33, 0x37, 0x37,
+  0x1a, 0xdd, 0x8e, 0x03, 0x00, 0x01, 0x00, 0x01, 0x42, 0x08, 0x65, 0x73,
+  0x52, 0x44, 0x49, 0x60, 0x00, 0x06
+};
+// Interfaz, Authentication CVC (PK.IFD.AUT)
+static const u8 C_CV_IFDuser_AUT_cert [] = {
+  0x7f, 0x21, 0x81, 0xcd, 0x5f, 0x37, 0x81, 0x80, 0x82, 0x5b, 0x69, 0xc6,
+  0x45, 0x1e, 0x5f, 0x51, 0x70, 0x74, 0x38, 0x5f, 0x2f, 0x17, 0xd6, 0x4d,
+  0xfe, 0x2e, 0x68, 0x56, 0x75, 0x67, 0x09, 0x4b, 0x57, 0xf3, 0xc5, 0x78,
+  0xe8, 0x30, 0xe4, 0x25, 0x57, 0x2d, 0xe8, 0x28, 0xfa, 0xf4, 0xde, 0x1b,
+  0x01, 0xc3, 0x94, 0xe3, 0x45, 0xc2, 0xfb, 0x06, 0x29, 0xa3, 0x93, 0x49,
+  0x2f, 0x94, 0xf5, 0x70, 0xb0, 0x0b, 0x1d, 0x67, 0x77, 0x29, 0xf7, 0x55,
+  0xd1, 0x07, 0x02, 0x2b, 0xb0, 0xa1, 0x16, 0xe1, 0xd7, 0xd7, 0x65, 0x9d,
+  0xb5, 0xc4, 0xac, 0x0d, 0xde, 0xab, 0x07, 0xff, 0x04, 0x5f, 0x37, 0xb5,
+  0xda, 0xf1, 0x73, 0x2b, 0x54, 0xea, 0xb2, 0x38, 0xa2, 0xce, 0x17, 0xc9,
+  0x79, 0x41, 0x87, 0x75, 0x9c, 0xea, 0x9f, 0x92, 0xa1, 0x78, 0x05, 0xa2,
+  0x7c, 0x10, 0x15, 0xec, 0x56, 0xcc, 0x7e, 0x47, 0x1a, 0x48, 0x8e, 0x6f,
+  0x1b, 0x91, 0xf7, 0xaa, 0x5f, 0x38, 0x3c, 0xad, 0xfc, 0x12, 0xe8, 0x56,
+  0xb2, 0x02, 0x34, 0x6a, 0xf8, 0x22, 0x6b, 0x1a, 0x88, 0x21, 0x37, 0xdc,
+  0x3c, 0x5a, 0x57, 0xf0, 0xd2, 0x81, 0x5c, 0x1f, 0xcd, 0x4b, 0xb4, 0x6f,
+  0xa9, 0x15, 0x7f, 0xdf, 0xfd, 0x79, 0xec, 0x3a, 0x10, 0xa8, 0x24, 0xcc,
+  0xc1, 0xeb, 0x3c, 0xe0, 0xb6, 0xb4, 0x39, 0x6a, 0xe2, 0x36, 0x59, 0x00,
+  0x16, 0xba, 0x69, 0x00, 0x01, 0x00, 0x01, 0x42, 0x08, 0x65, 0x73, 0x53,
+  0x44, 0x49, 0x60, 0x00, 0x06
+};
+
Index: opensc-0.11.12/src/libopensc/dnie/libopensc-dnie.pc.in
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/libopensc-dnie.pc.in	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,10 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: libopensc-dnie
+Description: OpenSC based library for DNIe card
+Version: @VERSION@
+Libs: -L${libdir} -lopensc-dnie -lopensc
+Cflags: -I${includedir}
Index: opensc-0.11.12/src/libopensc/dnie/license
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/license	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,675 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
+
Index: opensc-0.11.12/src/libopensc/dnie/map.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/map.c	2010-11-17 19:14:03.000000000 +0000
@@ -0,0 +1,185 @@
+/*!
+ * \file map.c
+ * \brief A map data type
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ * oficinatecnica@dnielectronico.es
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#include "map.h"
+#include <opensc/opensc.h>
+#include <stdlib.h>
+#include <string.h>
+
+map_item_t * map_item_new( int num_columns, void **item_data )
+{
+  map_item_t *map_item = NULL;
+  void **data = NULL;
+
+  if(!num_columns || !item_data)
+    return NULL;
+
+  data = malloc(sizeof(void *) * num_columns);
+  if(!data)
+    goto end;
+
+  memcpy(data, item_data, sizeof(void *) * num_columns);
+
+  map_item = calloc(1, sizeof(map_item_t));
+  if(!map_item)
+    goto end;
+  
+  /* transfer ownership of allocated data */
+  map_item->data = data;
+  data = NULL;
+ 
+ end:
+  if(data) {
+    free(data);
+    data = NULL;
+  }
+
+  return map_item;
+}
+
+void map_item_free( map_item_t *map_item, int num_columns, const column_operations_t *column_operations, map_item_t **next_map_item )
+{
+  int ii;
+
+  if(next_map_item)
+    *next_map_item = NULL;
+
+  if(!map_item)
+    return;
+
+  if(map_item->data) {
+    for(ii=0; ii<num_columns; ii++) {
+      if(map_item->data[ii] && column_operations && column_operations[ii].free) {
+	/* we have data and a pointer to a function to free it! */
+	column_operations[ii].free(map_item->data[ii]);
+	map_item->data[ii] = NULL;
+      }
+    }
+    
+    /* free data array */
+    free(map_item->data);
+    map_item->data = NULL;
+  }
+
+  *next_map_item = map_item->next;
+
+  free(map_item);
+  map_item = NULL;
+}
+
+map_t * map_new( int num_columns, const column_operations_t *column_operations )
+{
+  map_t *map = NULL;
+  column_operations_t *map_column_operations;
+
+  if(!num_columns || !column_operations)
+    return NULL;
+
+  map_column_operations = malloc(sizeof(column_operations_t) * num_columns);
+  if(!map_column_operations)
+    return NULL;
+
+  memcpy(map_column_operations, column_operations, sizeof(column_operations_t) * num_columns);
+  
+  map = calloc(1, sizeof(map_t));
+  if(!map)
+    goto end;
+  
+  /* transfer ownership of allocated map_column_operations */
+  map->column_operations = map_column_operations;
+  map_column_operations = NULL;
+
+  map->num_columns = num_columns;
+  
+ end:
+  if(map_column_operations) {
+    free(map_column_operations);
+    map_column_operations = NULL;
+  }
+  
+  return map;
+}
+
+void map_free( map_t *map )
+{
+  map_item_t *map_item = NULL;
+
+  if(!map)
+    return;
+
+  /* free all map_items */
+  for(map_item = map->first;
+      map_item;
+      map_item_free(map_item, map->num_columns, map->column_operations, &map_item)
+      );
+
+  map->first = NULL;
+
+  /* free operations */
+  if(map->column_operations) {
+    free(map->column_operations);
+    map->column_operations = NULL;
+  }
+
+  free(map);
+}
+
+int map_append_item( map_t *map, void **item_data )
+{
+  map_item_t *map_item = NULL;
+
+  if(!map || !item_data)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  map_item = map_item_new(map->num_columns, item_data);
+  if(!map_item)
+    return SC_ERROR_OUT_OF_MEMORY;
+
+  map_item->next = map->first;
+  map->first = map_item;
+
+  return SC_SUCCESS;
+}
+
+void ** map_find_by_column_data( map_t *map, const void *column_data, int index_column )
+{
+  map_item_t *map_item = NULL;
+
+  if(!map || index_column<0 || index_column>=map->num_columns)
+    return NULL;
+
+  for(map_item = map->first; map_item; map_item = map_item->next) {
+    if(map_item->data) {
+      if(map->column_operations && map->column_operations[index_column].is_equal) {
+	if(map->column_operations[index_column].is_equal(map_item->data[index_column], column_data)) {
+	  /* we found it! */
+	  return map_item->data;
+	}
+      }
+    }
+  }
+  
+  /* we didn't find it! */
+  return NULL;
+}
+
Index: opensc-0.11.12/src/libopensc/dnie/map.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/map.h	2010-11-17 19:14:03.000000000 +0000
@@ -0,0 +1,124 @@
+/*!
+ * \file map.h
+ * \brief A map data type
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#ifndef MAP_H
+#define MAP_H
+
+/*! frees object... If object can't be freed just set to null */
+typedef void column_operation_free(void *);
+
+/*! operation that tests for equality two objects */
+typedef int column_operation_is_equal(const void *, const void *);
+
+
+/*!
+  Operations on each item column
+*/
+typedef struct _column_operations_t {
+  void (*free)(void *); /*!< frees object... If object can't be freed just set to null */
+  int (*is_equal)(const void *, const void *); /*< operation that tests for equality two objects */
+} column_operations_t;
+
+/*!
+  This is an item
+*/
+typedef struct _map_item_t {
+  void **data; /*! Array of num_columns elements which hold data */
+  struct _map_item_t *next; /*! Pointer to next item */
+} map_item_t;
+
+/*!
+  This is a map type
+*/
+typedef struct _map_t {
+  map_item_t *first; /*!< Pointer to first element in map */
+  column_operations_t *column_operations; /*!< pointer to array of column_operations_t. There are num_columns elements in this array */
+  int num_columns; /*!< number of columns */
+} map_t;
+
+/*!
+  Creates a new map_item.
+  
+  \param num_columns Number of columns in this map
+  \param item_data num_columns array of void * holding each column of a data item
+  
+  \returns pointer to newly allocated structure and initialized.
+*/
+map_item_t * map_item_new( int num_columns, void **item_data );
+
+/*!
+  Frees a map_item. It freed all objects it holds if column_operations_t.free operation
+  is defined.
+
+  It doesn't free linked (in next) map_item. But it returns it in next_map_item.
+  
+  \param map_item The map_item to be freed.
+  \param num_columns Number of columns in this map
+  \param column_operations Operations to free each column. It uses free function. If NULL it doesn't free anything.
+  \param next_map_item Returns linked next map item.
+*/
+void map_item_free( map_item_t *map_item, int num_columns, const column_operations_t *column_operations, map_item_t **next_map_item );
+
+
+/*!
+  Creates a new map.
+  
+  \param num_columns Number of columns in this map
+  \param column_operations num_columns long array of operations for each column.
+  
+  \returns pointer to newly allocated structure and initialized.
+*/
+map_t * map_new( int num_columns, const column_operations_t *column_operations );
+
+/*!
+  Frees a map. It freed all objects it holds if column_operations_t.free operation
+  is defined.
+  
+  \param map The map to be freed.
+*/
+void map_free( map_t *map );
+
+
+/*!
+  Append object to map.
+
+  \param map The map object
+  \param item_data num_columns array of void * holding each column of a data item
+  
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int map_append_item( map_t *map, void **item_data );
+
+/*!
+  Finds object and returns it.
+
+  Note that map still holds ownership of the object. Returned data can be changed.
+
+  \param map The map object
+  \param column_data column data to compare to using is_equal operation
+  \param index_column 0-based column number we are using as index
+
+  \returns Pointer to first object found, NULL if not.
+*/
+void ** map_find_by_column_data( map_t *map, const void *column_data, int index_column );
+
+#endif /* MAP_H */
Index: opensc-0.11.12/src/libopensc/dnie/map_helper.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/map_helper.c	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,333 @@
+/*!
+ * \file map.c
+ * \brief A map data type
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+*/
+
+#include "map_helper.h"
+#include <opensc/opensc.h>
+#include <opensc/pkcs15.h>
+#include <stdlib.h>
+#include <string.h>
+
+
+map_two_t * map_two_new( column_operation_free *index_free,
+			 column_operation_is_equal *index_is_equal,
+			 column_operation_free *mapped_free,
+			 column_operation_is_equal *mapped_is_equal)
+{
+  column_operations_t column_operations[2];
+
+  column_operations[0].free = index_free;
+  column_operations[0].is_equal = index_is_equal;
+  column_operations[1].free = mapped_free;
+  column_operations[1].is_equal = mapped_is_equal;
+
+  return map_new(2, column_operations);
+}
+
+void * map_two_find_mapped( map_two_t *map, const void *index )
+{
+  void **map_item = NULL;
+
+  map_item = map_find_by_column_data(map, index, 0);
+  if(map_item && map_item[1]) {
+    return map_item[1];
+  }
+  return NULL;
+}
+
+int map_two_set_item( map_two_t *map, const void *index, copy_constructor *index_copy_constructor, const void *mapped, copy_constructor *mapped_copy_constructor )
+{
+  int r = SC_SUCCESS;
+  void **map_item = NULL;
+  void *map_item_array[2] = {NULL, NULL};
+  void *temp_mapped = NULL;
+  void *temp = NULL;
+
+  if(mapped_copy_constructor) {
+    temp_mapped = mapped_copy_constructor(mapped);
+  } else {
+    temp_mapped = (void *)mapped;
+  }
+
+  map_item = map_find_by_column_data(map, index, 0);
+  if(map_item) {
+    /* replace mapped */
+    /* modifying map_item is modifying object */
+    temp = map_item[1];
+    map_item[1] = temp_mapped;
+    
+    /* we leave old data in temp_mapped_path so that it gets freed */
+    temp_mapped = temp;
+    temp = NULL;
+  } else {
+    /* we introduce a new item */
+    if(index_copy_constructor) {
+      temp = index_copy_constructor(index);
+    } else {
+      temp = (void *)index;
+    }
+
+    map_item_array[0] = temp;
+    map_item_array[1] = temp_mapped;
+    r = map_append_item(map, map_item_array);
+    if(r != SC_SUCCESS)
+      goto end;
+
+    /* avoid data being freed.. we transfered ownership to map */
+    temp = NULL;
+    temp_mapped = NULL;
+  }
+
+ end:
+  if(temp_mapped && map->column_operations && map->column_operations[1].free) {
+    map->column_operations[1].free(temp_mapped);
+    temp_mapped = NULL;
+  }
+  
+  if(temp && map->column_operations && map->column_operations[0].free) {
+    map->column_operations[0].free(temp);
+    temp_mapped = NULL;
+  }
+
+  return r;
+}
+
+
+
+
+map_path_to_path_t * map_path_to_path_new()
+{
+  return map_two_new(free,
+		     (int(*)(const void *, const void *))sc_compare_path,
+		     free,
+		     (int(*)(const void *, const void *))sc_compare_path);
+}
+
+int map_path_to_path_set_item( map_path_to_path_t *map, const sc_path_t *index_path, const sc_path_t *mapped_path )
+{
+  return map_two_set_item(map, index_path, (copy_constructor *)path_copy_constructor, mapped_path, (copy_constructor *)path_copy_constructor);
+}
+
+sc_path_t * map_path_to_path_find( map_path_to_path_t *map, const sc_path_t *path )
+{
+  return map_two_find_mapped(map, path);
+}
+
+
+int map_path_to_path_set_all_keys_paths( map_path_to_path_t *map, int opensc_key_reference, int card_key_reference, int is_st )
+{
+  int r = SC_SUCCESS;
+  sc_path_t opensc_path;
+  sc_path_t card_path;
+  
+  /* clear path */
+  memset(&opensc_path, 0, sizeof(opensc_path));
+  opensc_path.type = SC_PATH_TYPE_PATH;
+
+  memset(&card_path, 0, sizeof(card_path));
+  card_path.type = SC_PATH_TYPE_PATH;
+
+  
+  /*
+    Store card paths
+
+    card paths:
+    * INFINEON:
+     - 3F11//3F77 (Prk)
+     - 3F11//3F78 (Pbk)
+    
+    * ST:
+     - 3F11//01id (Prk & Pbk)
+  */
+  if(is_st) {
+    /* card path */
+    memcpy(&card_path.value, "\x3f\x00\x3f\x11\x01", 5);
+    card_path.value[5] = card_key_reference;
+    card_path.len = 6;
+
+    /* private key */
+    memcpy(&opensc_path.value, "\x3f\x00\x50\x15\x20", 5);
+    opensc_path.value[5] = opensc_key_reference;
+    opensc_path.len = 6;
+    r = map_path_to_path_set_item(map, &opensc_path, &card_path);
+    if(r != SC_SUCCESS)
+      goto end;
+
+    /* second private key version */
+    memcpy(&opensc_path.value, "\x3f\x00\x20", 3);
+    opensc_path.value[3] = opensc_key_reference;
+    opensc_path.len = 4;
+    r = map_path_to_path_set_item(map, &opensc_path, &card_path);
+    if(r != SC_SUCCESS)
+      goto end;
+
+    /* public key */
+    memcpy(&opensc_path.value, "\x3f\x00\x50\x15\x21", 5);
+    opensc_path.value[5] = opensc_key_reference;
+    opensc_path.len = 6;
+    r = map_path_to_path_set_item(map, &opensc_path, &card_path);
+    if(r != SC_SUCCESS)
+      goto end;
+
+    /* second public key version */
+    memcpy(&opensc_path.value, "\x3f\x00\x21", 3);
+    opensc_path.value[3] = opensc_key_reference;
+    opensc_path.len = 4;
+    r = map_path_to_path_set_item(map, &opensc_path, &card_path);
+    if(r != SC_SUCCESS)
+      goto end;
+  } else {
+    /* private key card path */
+    memcpy(&card_path.value, "\x3f\x00\x3f\x11\x3f\x77", 6);
+    card_path.len = 6;
+
+    /* private key */
+    memcpy(&opensc_path.value, "\x3f\x00\x50\x15\x20", 5);
+    opensc_path.value[5] = opensc_key_reference;
+    opensc_path.len = 6;
+    r = map_path_to_path_set_item(map, &opensc_path, &card_path);
+    if(r != SC_SUCCESS)
+      goto end;
+
+    /* second private key version */
+    memcpy(&opensc_path.value, "\x3f\x00\x20", 3);
+    opensc_path.value[3] = opensc_key_reference;
+    opensc_path.len = 4;
+    r = map_path_to_path_set_item(map, &opensc_path, &card_path);
+    if(r != SC_SUCCESS)
+      goto end;
+
+    /* public key card path */
+    memcpy(&card_path.value, "\x3f\x00\x3f\x11\x3f\x78", 6);
+    card_path.len = 6;
+
+    /* public key */
+    memcpy(&opensc_path.value, "\x3f\x00\x50\x15\x21", 5);
+    opensc_path.value[5] = opensc_key_reference;
+    opensc_path.len = 6;
+    r = map_path_to_path_set_item(map, &opensc_path, &card_path);
+    if(r != SC_SUCCESS)
+      goto end;
+
+    /* second public key version */
+    memcpy(&opensc_path.value, "\x3f\x00\x21", 3);
+    opensc_path.value[3] = opensc_key_reference;
+    opensc_path.len = 4;
+    r = map_path_to_path_set_item(map, &opensc_path, &card_path);
+    if(r != SC_SUCCESS)
+      goto end;
+  }
+
+ end:
+  return r;
+}
+
+map_id_to_id_t * map_id_to_id_new()
+{
+  return map_two_new(free,
+		     (int(*)(const void *, const void *))sc_pkcs15_compare_id,
+		     free,
+		     (int(*)(const void *, const void *))sc_pkcs15_compare_id);
+}
+
+/*!
+  Append new id to map.
+
+  \param map The map object
+  \param index_id path to index item
+  \param mapped_id mapped path of item
+  
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int map_id_to_id_set_item( map_path_to_path_t *map, const sc_pkcs15_id_t *index_id, const sc_pkcs15_id_t *mapped_id )
+{
+  return map_two_set_item(map, index_id, (copy_constructor *)id_copy_constructor, mapped_id, (copy_constructor *)id_copy_constructor);
+}
+
+map_path_to_id_t * map_path_to_id_new()
+{
+  return map_two_new(free,
+		     (int(*)(const void *, const void *))sc_compare_path,
+		     free,
+		     (int(*)(const void *, const void *))sc_pkcs15_compare_id);
+}
+
+int map_path_to_id_set_item( map_path_to_id_t *map, const sc_path_t *path, const sc_pkcs15_id_t *id )
+{
+  return map_two_set_item(map, path, (copy_constructor *)path_copy_constructor, id, (copy_constructor *)id_copy_constructor);
+}
+
+sc_pkcs15_id_t * map_path_to_id_find( map_path_to_id_t *map, const sc_path_t *path )
+{
+  return map_two_find_mapped(map, path);
+}
+
+map_id_to_der_t * map_id_to_der_new()
+{
+  return map_two_new(free,
+		     (int(*)(const void *, const void *))sc_pkcs15_compare_id,
+		     NULL, /* FIXME don't free obj->content sc_pkcs15_der_t ? */
+		     NULL /* can't find by der */);
+}
+
+int map_id_to_der_set_item( map_id_to_der_t *map, const sc_pkcs15_id_t *id, const sc_pkcs15_der_t *der )
+{
+  return map_two_set_item(map, id, (copy_constructor *)id_copy_constructor, der, (copy_constructor *)der_copy_constructor);
+}
+
+sc_pkcs15_der_t * map_id_to_der_find( map_path_to_path_t *map, const sc_pkcs15_id_t *id )
+{
+  return map_two_find_mapped(map, id);
+}
+
+sc_pkcs15_id_t * map_opensc_id_to_id_find( map_opensc_id_to_id_t *map, const sc_pkcs15_id_t *id )
+{
+  return map_two_find_mapped(map, id);
+}
+
+sc_path_t *path_copy_constructor( const sc_path_t *path )
+{
+  sc_path_t *result = NULL;
+  BINARY_COPY_CONSTRUCTOR(result,path,sizeof(sc_path_t));
+  return result;
+}
+
+sc_pkcs15_id_t *id_copy_constructor( const sc_pkcs15_id_t *id )
+{
+  sc_pkcs15_id_t *result = NULL;
+  BINARY_COPY_CONSTRUCTOR(result,id,sizeof(sc_pkcs15_id_t));
+  return result;
+}
+
+sc_pkcs15_der_t *der_copy_constructor( const sc_pkcs15_der_t *der )
+{
+  sc_pkcs15_der_t *result = NULL;
+
+  if(!der)
+    return NULL;
+
+  result = calloc(1, sizeof(sc_pkcs15_der_t));
+  if(!result)
+    return NULL;
+
+  sc_der_copy(result, der);
+  return result;
+}
Index: opensc-0.11.12/src/libopensc/dnie/map_helper.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/map_helper.h	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,240 @@
+/*!
+ * \file map_helper.h
+ * \brief Map helpers
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ */
+
+#ifndef MAP_HELPER_H
+#define MAP_HELPER_H
+
+
+#include "map.h"
+#include <opensc/opensc.h>
+#include <opensc/pkcs15.h>
+
+
+
+typedef void * copy_constructor( const void * );
+
+typedef map_t map_two_t;
+
+
+/*!
+  Creates a new map of 2 items (index, mapped)
+
+  \param index_free free operation on index
+  \param index_is_equal is_equal operation on index
+  \param mapped_free free operation on mapped
+  \param mapped_is_equal is_equal operation on mapped
+ */
+map_two_t * map_two_new( column_operation_free *index_free,
+			 column_operation_is_equal *index_is_equal,
+			 column_operation_free *mapped_free,
+			 column_operation_is_equal *mapped_is_equal);
+
+
+/*!
+  Finds mapped using index
+
+  \param map The map object
+  \param index The index
+ */
+void * map_two_find_mapped( map_two_t *map, const void *index );
+
+/*!
+  Append new item to map.
+
+  \param map The map object
+  \param index index object... transfers ownership
+  \param mapped_path mapped path of item
+  
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int map_two_set_item( map_two_t *map, const void *index, copy_constructor *index_copy_constructor, const void *mapped, copy_constructor *mapped_copy_constructor );
+
+
+
+
+typedef map_t map_path_to_path_t;
+
+/*!
+  Creates a new sc_path_t to sc_path_t map.
+  
+  \returns pointer to newly allocated structure and initialized.
+*/
+map_path_to_path_t * map_path_to_path_new();
+
+/*!
+  Append new path to map.
+
+  \param map The map object
+  \param index_path path to index item
+  \param mapped_path mapped path of item
+  
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int map_path_to_path_set_item( map_path_to_path_t *map, const sc_path_t *index_path, const sc_path_t *mapped_path );
+
+/*!
+  Finds mapped path and returns it.
+
+  Note that map still holds ownership of the object. Returned data can be changed.
+
+  \param map The map object
+  \param path Path used to index
+
+  \returns Pointer to first object found, NULL if not.
+*/
+sc_path_t * map_path_to_path_find( map_path_to_path_t *map, const sc_path_t *path );
+
+/*!
+  Append public and private key paths by opensc by key reference
+
+  \param map The map object
+  \param index_path path to index item
+  \param mapped_path mapped path of item
+  
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int map_path_to_path_set_all_keys_paths( map_path_to_path_t *map, int opensc_key_reference, int card_key_reference, int is_st );
+
+
+
+typedef map_t map_id_to_id_t;
+
+/*!
+  Creates a new sc_pkcs15_id_t to sc_pkcs15_id_t map
+  
+  \returns pointer to newly allocated structure and initialized.
+*/
+map_id_to_id_t * map_id_to_id_new();
+
+/*!
+  Append new id to map.
+
+  \param map The map object
+  \param index_id path to index item
+  \param mapped_id mapped path of item
+  
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int map_id_to_id_set_item( map_path_to_path_t *map, const sc_pkcs15_id_t *index_id, const sc_pkcs15_id_t *mapped_id );
+
+typedef map_t map_id_to_der_t;
+
+/*!
+  Creates a new sc_pkcs15_id_t to sc_pkcs15_der_t map
+  
+  \returns pointer to newly allocated structure and initialized.
+*/
+map_id_to_der_t * map_id_to_der_new();
+
+/*!
+  Append new id-der to map.
+
+  \param map The map object
+  \param id id of the item
+  \param der der of the item
+  
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int map_id_to_der_set_item( map_id_to_der_t *map, const sc_pkcs15_id_t *id, const sc_pkcs15_der_t *der );
+
+/*!
+  Finds mapped der and returns it.
+
+  Note that map still holds ownership of the object. Returned data can be changed.
+
+  \param map The map object
+  \param id id used to index
+
+  \returns Pointer to first object found, NULL if not.
+*/
+sc_pkcs15_der_t * map_id_to_der_find( map_path_to_path_t *map, const sc_pkcs15_id_t *id );
+
+typedef map_t map_opensc_id_to_id_t;
+
+/*!
+  Finds mapped id and returns it.
+
+  Note that map still holds ownership of the object. Returned data can be changed.
+
+  \param map The map object
+  \param id id used to index
+
+  \returns Pointer to first object found, NULL if not.
+*/
+sc_pkcs15_id_t * map_opensc_id_to_id_find( map_opensc_id_to_id_t *map, const sc_pkcs15_id_t *id );
+
+typedef map_t map_path_to_id_t;
+
+/*!
+  Creates a new sc_path_t to sc_pkcs15_id_t map
+  
+  \returns pointer to newly allocated structure and initialized.
+*/
+map_path_to_id_t * map_path_to_id_new();
+
+/*!
+  Append new path-id to map.
+
+  \param map The map object
+  \param path path of the item
+  \param id id of the item
+  
+  \returns SC_SUCCESS on success, error code otherwise
+*/
+int map_path_to_id_set_item( map_path_to_id_t *map, const sc_path_t *path, const sc_pkcs15_id_t *id );
+
+/*!
+  Finds mapped path and returns mapped id.
+
+  Note that map still holds ownership of the object. Returned data can be changed.
+
+  \param map The map object
+  \param path path used to index
+
+  \returns Pointer to first object found, NULL if not.
+*/
+sc_pkcs15_id_t * map_path_to_id_find( map_path_to_id_t *map, const sc_path_t *path );
+
+/* 
+   Helper copy constructors
+*/
+
+#define BINARY_COPY_CONSTRUCTOR(result,original,size)	\
+  if(original) {					\
+    (result) = malloc(size);				\
+    if(result) {					\
+      memcpy(result, original, size);			\
+    }							\
+  } else {						\
+    (result) = NULL;					\
+  }
+
+/*!
+  Path copy constructor
+*/
+sc_path_t *path_copy_constructor( const sc_path_t *path );
+
+/*!
+  id copy constructor
+*/
+sc_pkcs15_id_t *id_copy_constructor( const sc_pkcs15_id_t *id );
+
+/*!
+  Der copy constructor
+*/
+sc_pkcs15_der_t *der_copy_constructor( const sc_pkcs15_der_t *der );
+
+
+/*!
+  Free structures
+*/
+void sc_der_free( sc_pkcs15_der_t *der );
+
+
+
+#endif /* MAP_HELPER_H */
Index: opensc-0.11.12/src/libopensc/dnie/pkcs15_default.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/pkcs15_default.c	2010-11-17 19:14:03.000000000 +0000
@@ -0,0 +1,598 @@
+/*
+ * pkcs15_default.c: PKCS #15 general functions
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#include "pkcs15_default.h"
+#include <libopensc/log.h>
+
+/* DEFAULT ONE */
+static const struct sc_asn1_entry c_asn1_toki[] = {
+	{ "version",        SC_ASN1_INTEGER,      SC_ASN1_TAG_INTEGER, 0, NULL, NULL },
+	{ "serialNumber",   SC_ASN1_OCTET_STRING, SC_ASN1_TAG_OCTET_STRING, 0, NULL, NULL },
+	{ "manufacturerID", SC_ASN1_UTF8STRING,   SC_ASN1_TAG_UTF8STRING, SC_ASN1_OPTIONAL, NULL, NULL },
+	{ "label",	    SC_ASN1_UTF8STRING,   SC_ASN1_CTX | 0, SC_ASN1_OPTIONAL, NULL, NULL },
+        /* XXX the Taiwanese ID card erroneously uses explicit tagging */
+        { "label-tw",       SC_ASN1_STRUCT,       SC_ASN1_CTX | 0 | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },
+	{ "tokenflags",	    SC_ASN1_BIT_FIELD,   SC_ASN1_TAG_BIT_STRING, 0, NULL, NULL },
+	{ "seInfo",	    SC_ASN1_SEQUENCE,	  SC_ASN1_CONS | SC_ASN1_TAG_SEQUENCE, SC_ASN1_OPTIONAL, NULL, NULL },
+	{ "recordInfo",	    SC_ASN1_STRUCT,       SC_ASN1_CONS | SC_ASN1_CTX | 1, SC_ASN1_OPTIONAL, NULL, NULL },
+	{ "supportedAlgorithms", SC_ASN1_STRUCT,  SC_ASN1_CONS | SC_ASN1_CTX | 2, SC_ASN1_OPTIONAL, NULL, NULL },
+	{ "issuerId",       SC_ASN1_UTF8STRING,   SC_ASN1_CTX | 3, SC_ASN1_OPTIONAL, NULL, NULL },
+	{ "holderId",       SC_ASN1_UTF8STRING,   SC_ASN1_CTX | 4, SC_ASN1_OPTIONAL, NULL, NULL },
+	{ "lastUpdate",     SC_ASN1_GENERALIZEDTIME, SC_ASN1_CTX | 5, SC_ASN1_OPTIONAL, NULL, NULL },
+	{ "preferredLanguage", SC_ASN1_PRINTABLESTRING, SC_ASN1_TAG_PRINTABLESTRING, SC_ASN1_OPTIONAL, NULL, NULL }, 
+	{ NULL, 0, 0, 0, NULL, NULL }
+};
+		     
+/* MODIFIED ONE */ 
+const struct sc_asn1_entry c_asn1_toki_dnie[] = {
+  { "version",        SC_ASN1_INTEGER,      SC_ASN1_TAG_INTEGER, 0, NULL, NULL },
+  { "serialNumber",   SC_ASN1_OCTET_STRING, SC_ASN1_TAG_OCTET_STRING, 0, NULL, NULL },
+  { "manufacturerID", SC_ASN1_UTF8STRING,   SC_ASN1_TAG_UTF8STRING, SC_ASN1_OPTIONAL, NULL, NULL },
+  { "label",	    SC_ASN1_UTF8STRING,   SC_ASN1_TAG_UTF8STRING, SC_ASN1_OPTIONAL, NULL, NULL },
+  /* XXX the Taiwanese ID card erroneously uses explicit tagging */
+  { "label-tw",       SC_ASN1_STRUCT,       SC_ASN1_CTX | 0 | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },
+  { "tokenflags",	    SC_ASN1_BIT_FIELD,   SC_ASN1_TAG_BIT_STRING, 0, NULL, NULL },
+  { "seInfo",	    SC_ASN1_SEQUENCE,	  SC_ASN1_CONS | SC_ASN1_TAG_SEQUENCE, SC_ASN1_OPTIONAL, NULL, NULL },
+  { "recordInfo",	    SC_ASN1_STRUCT,       SC_ASN1_CONS | SC_ASN1_CTX | 1, SC_ASN1_OPTIONAL, NULL, NULL },
+  { "supportedAlgorithms", SC_ASN1_STRUCT,  SC_ASN1_CONS | SC_ASN1_CTX | 2, SC_ASN1_OPTIONAL, NULL, NULL },
+  { "issuerId",       SC_ASN1_UTF8STRING,   SC_ASN1_CTX | 3, SC_ASN1_OPTIONAL, NULL, NULL },
+  { "holderId",       SC_ASN1_UTF8STRING,   SC_ASN1_CTX | 4, SC_ASN1_OPTIONAL, NULL, NULL },
+  { "lastUpdate",     SC_ASN1_GENERALIZEDTIME, SC_ASN1_CTX | 5, SC_ASN1_OPTIONAL, NULL, NULL },
+  { "preferredLanguage", SC_ASN1_PRINTABLESTRING, SC_ASN1_TAG_PRINTABLESTRING, SC_ASN1_OPTIONAL, NULL, NULL }, 
+  { NULL, 0, 0, 0, NULL, NULL }
+};
+
+const struct sc_asn1_entry c_asn1_tokeninfo[] = {
+  { "TokenInfo", SC_ASN1_STRUCT, SC_ASN1_CONS | SC_ASN1_TAG_SEQUENCE, 0, NULL, NULL },
+  { NULL, 0, 0, 0, NULL, NULL }
+};
+
+
+int parse_card_tokeninfo(struct sc_pkcs15_card *card, const u8 * buf, size_t buflen)
+{
+  int r, bug=0;
+  u8 serial[128];
+  size_t i;
+  size_t serial_len = sizeof(serial);
+  u8 mnfid[SC_PKCS15_MAX_LABEL_SIZE];
+  size_t mnfid_len = sizeof(mnfid);
+  u8 label[SC_PKCS15_MAX_LABEL_SIZE];
+  size_t label_len = sizeof(label);
+  u8 last_update[32];
+  size_t lupdate_len = sizeof(last_update) - 1;
+  size_t flags_len = sizeof(card->flags);
+  struct sc_asn1_entry asn1_toki[13], asn1_toki_dnie[13], asn1_tokeninfo[3], asn1_tokeninfo_dnie[3];
+  u8 preferred_language[3];
+  u8 tmp_buff[300];
+  size_t lang_length = sizeof(preferred_language);
+
+  memset(last_update, 0, sizeof(last_update));
+  sc_copy_asn1_entry(c_asn1_toki, asn1_toki);
+  sc_copy_asn1_entry(c_asn1_tokeninfo, asn1_tokeninfo);
+  sc_format_asn1_entry(asn1_toki + 0, &card->version, NULL, 0);
+  sc_format_asn1_entry(asn1_toki + 1, serial, &serial_len, 0);
+  sc_format_asn1_entry(asn1_toki + 2, mnfid, &mnfid_len, 0);
+  sc_format_asn1_entry(asn1_toki + 3, label, &label_len, 0);
+  /* skip "label-tw" */
+  sc_format_asn1_entry(asn1_toki + 5, &card->flags, &flags_len, 0);
+  sc_format_asn1_entry(asn1_toki + 6, NULL, NULL, 0);
+  sc_format_asn1_entry(asn1_toki + 7, NULL, NULL, 0);
+  sc_format_asn1_entry(asn1_toki + 8, NULL, NULL, 0);
+  sc_format_asn1_entry(asn1_toki + 9, NULL, NULL, 0);
+  sc_format_asn1_entry(asn1_toki + 10, NULL, NULL, 0);
+  sc_format_asn1_entry(asn1_toki + 11, last_update, &lupdate_len, 0);
+  sc_format_asn1_entry(asn1_toki + 12, preferred_language, &lang_length, 0);
+  sc_format_asn1_entry(asn1_tokeninfo, asn1_toki, NULL, 0);
+
+  if (buf[1] == 0x2B) {    
+    /* patch to adapt the correct size to TokenInfo*/
+    memset(&tmp_buff, 0, sizeof(tmp_buff));
+    memcpy(&tmp_buff, buf, buflen);
+    tmp_buff[1] = 0x2C;
+    
+    r = sc_asn1_decode(card->card->ctx, asn1_tokeninfo, tmp_buff, buflen, NULL, NULL);
+  } else	
+    r = sc_asn1_decode(card->card->ctx, asn1_tokeninfo, buf, buflen, NULL, NULL);
+ 
+  if (r) {
+
+    bug = 1;
+        
+    sc_copy_asn1_entry(c_asn1_toki_dnie, asn1_toki_dnie);
+    sc_copy_asn1_entry(c_asn1_tokeninfo, asn1_tokeninfo_dnie);
+    sc_format_asn1_entry(asn1_toki_dnie + 0, &card->version, NULL, 0);
+    sc_format_asn1_entry(asn1_toki_dnie + 1, serial, &serial_len, 0);
+    sc_format_asn1_entry(asn1_toki_dnie + 2, mnfid, &mnfid_len, 0);
+    sc_format_asn1_entry(asn1_toki_dnie + 3, label, &label_len, 0);
+    /* skip "label-tw" */
+    sc_format_asn1_entry(asn1_toki_dnie + 5, &card->flags, &flags_len, 0);
+    sc_format_asn1_entry(asn1_toki_dnie + 6, NULL, NULL, 0);
+    sc_format_asn1_entry(asn1_toki_dnie + 7, NULL, NULL, 0);
+    sc_format_asn1_entry(asn1_toki_dnie + 8, NULL, NULL, 0);
+    sc_format_asn1_entry(asn1_toki_dnie + 9, NULL, NULL, 0);
+    sc_format_asn1_entry(asn1_toki_dnie + 10, NULL, NULL, 0);
+    sc_format_asn1_entry(asn1_toki_dnie + 11, last_update, &lupdate_len, 0);
+    sc_format_asn1_entry(asn1_toki_dnie + 12, preferred_language, &lang_length, 0);
+    sc_format_asn1_entry(asn1_tokeninfo_dnie, asn1_toki_dnie, NULL, 0);
+    
+    if (buf[1] == 0x2B)
+      r = sc_asn1_decode(card->card->ctx, asn1_tokeninfo_dnie, tmp_buff, buflen, NULL, NULL);
+    else
+      r = sc_asn1_decode(card->card->ctx, asn1_tokeninfo_dnie, buf, buflen, NULL, NULL);
+    if (r) {
+      sc_error(card->card->ctx,
+	       "ASN.1 parsing of EF(TokenInfo) failed: %s\n",
+	       sc_strerror(r));
+      goto err;
+    }
+  }
+
+  card->version += 1;
+  card->serial_number = (char *) malloc(serial_len * 2 + 1);
+  if (!card->serial_number) {
+    sc_error(card->card->ctx, "Memory allocation failed\n");
+    goto err;
+  }
+  card->serial_number[0] = 0;
+  for (i = 0; i < serial_len; i++) {
+    char byte[3];
+
+    sprintf(byte, "%02X", serial[i]);
+    strcat(card->serial_number, byte);
+  }
+  if (card->manufacturer_id == NULL) {
+    if (!bug) {
+      if (asn1_toki[2].flags & SC_ASN1_PRESENT)
+	card->manufacturer_id = strdup((char *) mnfid);
+      else
+	card->manufacturer_id = strdup("(unknown)");
+    } else {
+      if (asn1_toki_dnie[2].flags & SC_ASN1_PRESENT)
+	card->manufacturer_id = strdup((char *) mnfid);
+      else
+	card->manufacturer_id = strdup("(unknown)");
+    }
+  }
+  if (card->label == NULL) {
+    if (!bug) {
+      if (asn1_toki[3].flags & SC_ASN1_PRESENT)
+	card->label = strdup((char *) label);
+      else
+	card->label = strdup("(unknown)");
+    } else {
+      if (asn1_toki_dnie[3].flags & SC_ASN1_PRESENT)
+	card->label = strdup((char *) label);
+      else
+	card->label = strdup("(unknown)");
+    }
+  }
+  if (!bug) {
+    if (asn1_toki[11].flags & SC_ASN1_PRESENT)
+      card->last_update = strdup((char *)last_update);
+    if (asn1_toki[12].flags & SC_ASN1_PRESENT) {
+      preferred_language[2] = 0;
+      card->preferred_language = strdup((char *)preferred_language);
+    }
+  } else {
+    if (asn1_toki_dnie[11].flags & SC_ASN1_PRESENT)
+      card->last_update = strdup((char *)last_update);
+    if (asn1_toki_dnie[12].flags & SC_ASN1_PRESENT) {
+      preferred_language[2] = 0;
+      card->preferred_language = strdup((char *)preferred_language);
+    }
+  }
+  return SC_SUCCESS;
+ err:
+  if (card->serial_number == NULL)
+    card->serial_number = strdup("(unknown)");
+  if (card->manufacturer_id == NULL)
+    card->manufacturer_id = strdup("(unknown)");
+  return SC_SUCCESS;
+}
+
+
+static const struct sc_asn1_entry c_asn1_odf[] = {
+	{ "privateKeys",	 SC_ASN1_STRUCT, SC_ASN1_CTX | 0 | SC_ASN1_CONS, 0, NULL, NULL },
+	{ "publicKeys",		 SC_ASN1_STRUCT, SC_ASN1_CTX | 1 | SC_ASN1_CONS, 0, NULL, NULL },
+	{ "trustedPublicKeys",	 SC_ASN1_STRUCT, SC_ASN1_CTX | 2 | SC_ASN1_CONS, 0, NULL, NULL },
+	{ "certificates",	 SC_ASN1_STRUCT, SC_ASN1_CTX | 4 | SC_ASN1_CONS, 0, NULL, NULL },
+	{ "trustedCertificates", SC_ASN1_STRUCT, SC_ASN1_CTX | 5 | SC_ASN1_CONS, 0, NULL, NULL },
+	{ "usefulCertificates",  SC_ASN1_STRUCT, SC_ASN1_CTX | 6 | SC_ASN1_CONS, 0, NULL, NULL },
+	{ "dataObjects",	 SC_ASN1_STRUCT, SC_ASN1_CTX | 7 | SC_ASN1_CONS, 0, NULL, NULL },
+	{ "authObjects",	 SC_ASN1_STRUCT, SC_ASN1_CTX | 8 | SC_ASN1_CONS, 0, NULL, NULL },
+	{ NULL, 0, 0, 0, NULL, NULL }
+};
+
+static const unsigned int odf_indexes[] = {
+	SC_PKCS15_PRKDF,
+	SC_PKCS15_PUKDF,
+	SC_PKCS15_PUKDF_TRUSTED,
+	SC_PKCS15_CDF,
+	SC_PKCS15_CDF_TRUSTED,
+	SC_PKCS15_CDF_USEFUL,
+	SC_PKCS15_DODF,
+	SC_PKCS15_AODF,
+};
+
+static int parse_card_odf(struct sc_pkcs15_card *card, const u8 * buf, size_t buflen)
+{
+	const u8 *p = buf;
+	size_t left = buflen;
+	int r, i;
+	sc_path_t path;
+	struct sc_asn1_entry asn1_obj_or_path[] = {
+		{ "path", SC_ASN1_PATH, SC_ASN1_CONS | SC_ASN1_SEQUENCE, 0, &path, NULL },
+		{ NULL, 0, 0, 0, NULL, NULL }
+	};
+	struct sc_asn1_entry asn1_odf[9];
+	
+	sc_copy_asn1_entry(c_asn1_odf, asn1_odf);
+	for (i = 0; asn1_odf[i].name != NULL; i++)
+		sc_format_asn1_entry(asn1_odf + i, asn1_obj_or_path, NULL, 0);
+	while (left > 0) {
+		r = sc_asn1_decode_choice(card->card->ctx, asn1_odf, p, left, &p, &left);
+		if (r == SC_ERROR_ASN1_END_OF_CONTENTS)
+			break;
+		if (r < 0)
+			return r;
+		r = sc_pkcs15_add_df(card, odf_indexes[r], &path, NULL);
+		if (r)
+			return r;
+	}
+	return 0;
+}
+
+int parse_card_unusedspace( sc_pkcs15_card_t *p15card, const u8 * buf, size_t buflen )
+{
+  return sc_pkcs15_parse_unusedspace( buf, buflen, p15card );
+}
+
+int sc_pkcs15_get_card_objects(struct sc_pkcs15_card *p15card, unsigned int type,
+			       struct sc_pkcs15_object **ret, size_t ret_size)
+{
+  SC_FUNC_RETURN(p15card->card->ctx, 1, sc_pkcs15_get_card_objects_cond(p15card, type, NULL, NULL, ret, ret_size));
+}
+
+int sc_pkcs15_get_card_objects_cond(struct sc_pkcs15_card *p15card, unsigned int type,
+                               int (* func)(struct sc_pkcs15_object *, void *),
+                               void *func_arg,
+                               struct sc_pkcs15_object **ret, size_t ret_size)
+{
+  SC_FUNC_RETURN (p15card->card->ctx, 1, __sc_pkcs15_search_card_objects(p15card, 0, type,
+					 func, func_arg, ret, ret_size));
+}
+
+int __sc_pkcs15_search_card_objects(sc_pkcs15_card_t *p15card,
+			       unsigned int class_mask, unsigned int type,
+			       int (*func)(sc_pkcs15_object_t *, void *),
+			       void *func_arg,
+			       sc_pkcs15_object_t **ret, size_t ret_size)
+{
+  sc_debug(p15card->card->ctx, "Entering function __sc_pkcs15_search_card_objects\n");
+  sc_pkcs15_object_t *obj;
+        sc_pkcs15_df_t  *df;
+        unsigned int    df_mask = 0;
+        size_t          match_count = 0;
+        int             r = 0;
+
+        if (type)
+                class_mask |= SC_PKCS15_TYPE_TO_CLASS(type);
+
+        /* Make sure the class mask we have makes sense */
+        if (class_mask == 0
+         || (class_mask & ~(SC_PKCS15_SEARCH_CLASS_PRKEY |
+                            SC_PKCS15_SEARCH_CLASS_PUBKEY |
+                            SC_PKCS15_SEARCH_CLASS_CERT |
+                            SC_PKCS15_SEARCH_CLASS_DATA |
+                            SC_PKCS15_SEARCH_CLASS_AUTH))) {
+                return SC_ERROR_INVALID_ARGUMENTS;
+        }
+
+        if (class_mask & SC_PKCS15_SEARCH_CLASS_PRKEY)
+                df_mask |= (1 << SC_PKCS15_PRKDF);
+        if (class_mask & SC_PKCS15_SEARCH_CLASS_PUBKEY)
+                df_mask |= (1 << SC_PKCS15_PUKDF)
+                         | (1 << SC_PKCS15_PUKDF_TRUSTED);
+        if (class_mask & SC_PKCS15_SEARCH_CLASS_CERT)
+                df_mask |= (1 << SC_PKCS15_CDF)
+                         | (1 << SC_PKCS15_CDF_TRUSTED)
+                         | (1 << SC_PKCS15_CDF_USEFUL);
+        if (class_mask & SC_PKCS15_SEARCH_CLASS_DATA)
+                df_mask |= (1 << SC_PKCS15_DODF);
+        if (class_mask & SC_PKCS15_SEARCH_CLASS_AUTH)
+                df_mask |= (1 << SC_PKCS15_AODF);
+
+        /* Make sure all the DFs we want to search have been
+         * enumerated. */
+        for (df = p15card->df_list; df != NULL; df = df->next) {
+                if (!(df_mask & (1 << df->type)))
+                        continue;
+                if (df->enumerated)
+                        continue;
+                /* Enumerate the DF's, so p15card->obj_list is
+                 * populated. */
+                SC_TEST_RET(p15card->card->ctx, r, "DF parsing failed");
+                df->enumerated = 1;
+        }
+
+        /* And now loop over all objects */
+        for (obj = p15card->obj_list; obj != NULL; obj = obj->next) {
+                /* Check object type */
+                if (!(class_mask & SC_PKCS15_TYPE_TO_CLASS(obj->type)))
+                        continue;
+                if (type != 0
+                 && obj->type != type
+                 && (obj->type & SC_PKCS15_TYPE_CLASS_MASK) != type)
+                        continue;
+
+                /* Potential candidate, apply search function */
+                if (func != NULL && func(obj, func_arg) <= 0)
+                        continue;
+                /* Okay, we have a match. */
+                match_count++;
+                if (ret_size <= 0)
+                        continue;
+                ret[match_count-1] = obj;
+                if (ret_size <= match_count)
+                        break;
+        }
+	sc_debug(p15card->card->ctx, "Leaving function __sc_pkcs15_search_card_objects\n");
+        return match_count;
+}
+
+int sc_pkcs15_parse_card_df(struct sc_pkcs15_card *p15card,
+			    const unsigned int df_type,
+			    const u8 *buf,
+			    const size_t in_bufsize)
+{
+  sc_context_t            *ctx     = p15card->card->ctx;
+  int                      r       = SC_SUCCESS;
+  size_t                   bufsize = in_bufsize;
+  struct sc_pkcs15_object *obj     = NULL;
+
+  int (* func)(struct sc_pkcs15_card *, struct sc_pkcs15_object *,
+	       const u8 **nbuf, size_t *nbufsize) = NULL;
+  int (* func2)(struct sc_pkcs15_card *p15card, const u8 * buf, size_t buflen) = NULL;
+
+  if ( ctx->debug ) sc_debug( ctx, "Entering function sc_pkcs15_parse_card_df\n" );
+ 
+  switch (df_type) {
+  case SC_PKCS15_PRKDF:
+    func = sc_pkcs15_decode_prkdf_entry;
+    break;
+  case SC_PKCS15_PUKDF:
+    func = sc_pkcs15_decode_pukdf_entry;
+    break;
+  case SC_PKCS15_CDF:
+  case SC_PKCS15_CDF_TRUSTED:
+  case SC_PKCS15_CDF_USEFUL:
+    func = sc_pkcs15_decode_cdf_entry;
+    break;
+  case SC_PKCS15_DODF:
+    func = sc_pkcs15_decode_dodf_entry;
+    break;
+  case SC_PKCS15_AODF:
+    func = sc_pkcs15_decode_aodf_entry;
+    break;
+  }
+  if (func == NULL) {
+    switch (df_type) {
+    case SC_PKCS15_ODF:
+      func2 = parse_card_odf;
+      break;
+    case SC_PKCS15_TOKENINFO:
+      func2 = parse_card_tokeninfo;
+      break;
+    case SC_PKCS15_UNUSED:
+      func2 = parse_card_unusedspace;
+      break;
+    }
+    if (func2 == NULL) {
+      sc_error(ctx, "unknown DF type: %d\n", df_type);
+      r = SC_ERROR_INVALID_ARGUMENTS;
+      goto ret;
+    }
+    r = func2(p15card, buf, bufsize);
+    if (r!=SC_SUCCESS) {
+      sc_perror(ctx, r, "Error decoding DF entry");
+    }
+    goto ret;
+  }
+
+  do {
+    const u8 *oldp;
+    size_t obj_len;
+
+    obj = (struct sc_pkcs15_object *) calloc(1, sizeof(struct sc_pkcs15_object));
+    if (obj == NULL) {
+      r = SC_ERROR_OUT_OF_MEMORY;
+      goto ret;
+    }
+    oldp = buf;
+		
+    r = func(p15card, obj, &buf, &bufsize);
+    if (r) {
+      free(obj);
+      if (r == SC_ERROR_ASN1_END_OF_CONTENTS) {
+	r = 0;
+	break;
+      }
+      sc_perror(ctx, r, "Error decoding DF entry");
+      goto ret;
+    }
+
+    obj_len = buf - oldp;
+
+    obj->der.value = (u8 *) malloc(obj_len);
+    if (obj->der.value == NULL) {
+      r = SC_ERROR_OUT_OF_MEMORY;
+      goto ret;
+    }
+    memcpy(obj->der.value, oldp, obj_len);
+    obj->der.len = obj_len;
+
+    /* These objects are independent one another*/
+    obj->df = NULL;
+    r = sc_pkcs15_add_object(p15card, obj);
+    if (r) {
+      if (obj->data)
+	free(obj->data);
+      free(obj);
+      sc_perror(ctx, r, "Error adding object");
+      goto ret;
+    }
+  } while (bufsize && *buf != 0x00);
+
+ ret:
+  if (ctx->debug) sc_debug(ctx, "Leaving function sc_pkcs15_parse_card_df\n");
+  return r;
+}
+
+int sc_pkcs15_card_encode_df(sc_context_t *ctx,
+                             struct sc_pkcs15_card *p15card,
+                             struct sc_pkcs15_df *df,
+                             u8 **buf_out, size_t *bufsize_out)
+{
+  u8 *buf = NULL, *tmp = NULL;
+  size_t bufsize = 0, tmpsize;
+  const struct sc_pkcs15_object *obj;
+  int (* func)(sc_context_t *, const struct sc_pkcs15_object *nobj,
+               u8 **nbuf, size_t *nbufsize) = NULL;
+  int r = SC_SUCCESS;
+
+  if (p15card->card->ctx->debug) sc_debug(p15card->card->ctx, "Entering function sc_pkcs15_card_encode_df\n");
+
+  assert(p15card != NULL && p15card->magic == SC_PKCS15_CARD_MAGIC);
+  switch (df->type) {
+  case SC_PKCS15_PRKDF:
+    func = sc_pkcs15_encode_prkdf_entry;
+    break;
+  case SC_PKCS15_PUKDF:
+  case SC_PKCS15_PUKDF_TRUSTED:
+    func = sc_pkcs15_encode_pukdf_entry;
+    break;
+  case SC_PKCS15_CDF:
+  case SC_PKCS15_CDF_TRUSTED:
+  case SC_PKCS15_CDF_USEFUL:
+    func = sc_pkcs15_encode_cdf_entry;
+    break;
+  case SC_PKCS15_DODF:
+    func = sc_pkcs15_encode_dodf_entry;
+    break;
+  case SC_PKCS15_AODF:
+    func = sc_pkcs15_encode_aodf_entry;
+    break;
+  }
+  if (func == NULL) {
+    sc_error(ctx, "unknown DF type: %d\n", df->type);
+    *buf_out = NULL;
+    *bufsize_out = 0;
+    return 0;
+  }
+  for (obj = p15card->obj_list; obj != NULL; obj = obj->next) {
+    if (obj->df != df)
+      continue;
+    /* if we have a asn.1 codification, just use it! */
+    if(obj->der.len > 0) {
+      if (p15card->card->ctx->debug) sc_debug(p15card->card->ctx, "Reusing existing DER encoding\n");
+      
+      tmp = malloc(sizeof(u8)*obj->der.len);
+      if(!tmp) {
+	r = SC_ERROR_OUT_OF_MEMORY;
+	goto end;
+      }
+      memcpy(tmp, obj->der.value, obj->der.len);
+      tmpsize = obj->der.len;
+    } else {
+      r = func(ctx, obj, &tmp, &tmpsize);
+      if (r) {
+	goto end;
+      }
+    }
+    buf = (u8 *) realloc(buf, bufsize + tmpsize);
+    memcpy(buf + bufsize, tmp, tmpsize);
+    free(tmp);
+    tmp = NULL;
+    bufsize += tmpsize;
+  }
+  *buf_out = buf;
+  buf = NULL;
+  *bufsize_out = bufsize;
+    
+end:
+  if(tmp) {
+    free(tmp);
+    tmp = NULL;
+  }
+
+  if(buf) {
+    free(buf);
+    buf = NULL;
+  }
+
+  if (p15card->card->ctx->debug) sc_debug(p15card->card->ctx, "Leaving function sc_pkcs15_card_encode_df\n");
+
+  return r;
+}
+
+int sc_find_free_unusedspace( sc_pkcs15_card_t *p15card, const size_t size, 
+			      sc_pkcs15_unusedspace_t **out_unusedspace )
+{
+  int found=0, r = SC_SUCCESS;
+  sc_path_t us_df;
+  sc_pkcs15_unusedspace_t *temp_us=NULL;
+
+  assert(p15card != NULL && out_unusedspace!=NULL);
+
+  sc_debug(p15card->card->ctx, "Entering function sc_find_free_unusedspace\n");
+  
+  if (out_unusedspace && *out_unusedspace) {
+    free(out_unusedspace);
+    out_unusedspace=NULL;
+  }
+
+  sc_format_path("3F0050155033", &us_df);
+  /* This select file executes a parse unused space structure */
+  r = sc_select_file( p15card->card, &us_df, NULL);
+  if (r!=SC_SUCCESS)
+    goto sffu_err;
+  
+  for(temp_us=p15card->unusedspace_list; temp_us!=NULL && found==0; temp_us=temp_us->next) {
+    if(size<temp_us->path.count) {
+      if (found && temp_us->path.count>=(*out_unusedspace)->path.count) {
+	/* file is suitable but previously found was best */
+	continue;
+      }
+      /* we found it */
+      *out_unusedspace = temp_us;
+      found=1;
+    }
+  }
+
+ sffu_err:
+  sc_debug(p15card->card->ctx, "Leaving function sc_find_free_unusedspace\n");  
+  return r;
+}
+
+int get_ckaid_from_certificate( sc_card_t *card, const u8 *data, const size_t data_size, sc_pkcs15_id_t *card_ckaid ) {
+	sc_debug(card->ctx, "Function not implemented!");
+	return SC_ERROR_NOT_IMPLEMENTED;
+}
Index: opensc-0.11.12/src/libopensc/dnie/pkcs15_default.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/pkcs15_default.h	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,133 @@
+/*
+ * pkcs15_default.h: PKCS#15 default header file
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+
+#ifndef _PKCS15_DEFAULT_H
+#define _PKCS15_DEFAULT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#include <assert.h>
+#include <ltdl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <opensc/log.h>
+#include <opensc/opensc.h>
+#include <opensc/cardctl.h>
+#include <opensc/pkcs15.h>
+#include <pkcs15init/pkcs15-init.h>
+#include <opensc/asn1.h>
+#include <libopensc/internal.h>
+#include "pkcs15_standard.h"
+
+#define SC_ASN1_BIT_FIELD_3              132
+
+int get_ckaid_from_certificate( sc_card_t *card, const u8 *data, const size_t data_size, sc_pkcs15_id_t *card_ckaid );
+
+/* new functions from new pkcs15 cache structure */
+int sc_pkcs15_parse_card_df(struct sc_pkcs15_card *p15card,
+			    const unsigned int df_type,
+			    const u8 *buf,
+			    const size_t in_bufsize);
+
+int sc_find_free_unusedspace( sc_pkcs15_card_t *p15card, const size_t size, 
+			      sc_pkcs15_unusedspace_t **unused_space );
+
+  /* internal declaration */
+  int sc_pkcs15_get_card_objects_cond(struct sc_pkcs15_card *p15card, unsigned int type,
+				      int (* func)(struct sc_pkcs15_object *, void *),
+				      void *func_arg,
+				      struct sc_pkcs15_object **ret, size_t ret_size);
+  int __sc_pkcs15_search_card_objects(sc_pkcs15_card_t *p15card,
+				      unsigned int class_mask, unsigned int type,
+				      int (*func)(sc_pkcs15_object_t *, void *),
+				      void *func_arg,
+				      sc_pkcs15_object_t **ret, size_t ret_size);
+  
+  int sc_pkcs15_decode_aodf_entry(struct sc_pkcs15_card *p15card,
+					struct sc_pkcs15_object *obj,
+					const u8 ** buf, size_t *buflen);
+
+  int sc_pkcs15_decode_cdf_entry(struct sc_pkcs15_card *p15card,
+				       struct sc_pkcs15_object *obj,
+				       const u8 ** buf, size_t *buflen);
+
+  int sc_pkcs15_encode_cdf_entry(sc_context_t *ctx,
+				       const struct sc_pkcs15_object *obj,
+				       u8 **buf, size_t *bufsize);
+
+  int sc_pkcs15_decode_prkdf_entry(struct sc_pkcs15_card *p15card,
+					 struct sc_pkcs15_object *obj,
+					 const u8 ** buf, size_t *buflen);
+
+  int sc_pkcs15_encode_prkdf_entry(sc_context_t *ctx,
+					 const struct sc_pkcs15_object *obj,
+					 u8 **buf, size_t *buflen);
+
+  int sc_pkcs15_decode_pukdf_entry(struct sc_pkcs15_card *p15card,
+					 struct sc_pkcs15_object *obj,
+					 const u8 ** buf, size_t *buflen);
+
+  int sc_pkcs15_encode_pukdf_entry(sc_context_t *ctx,
+					 const struct sc_pkcs15_object *obj,
+					 u8 **buf, size_t *buflen);
+
+  int sc_asn1_decode(sc_context_t *ctx, struct sc_asn1_entry *asn1,
+			   const u8 *in, size_t len, const u8 **newp, size_t *len_left);
+
+  int sc_asn1_encode(sc_context_t *ctx, const struct sc_asn1_entry *asn1,
+			   u8 **ptr, size_t *size);
+
+  int sc_asn1_decode_choice(sc_context_t *ctx, struct sc_asn1_entry *asn1,
+				  const u8 *in, size_t len, const u8 **newp, size_t *len_left);
+
+  int sc_pkcs1_strip_02_padding(const u8 *data, size_t len, u8 *out,
+				size_t *out_len);
+
+  int sc_pkcs1_add_digest_info_prefix(unsigned int algorithm, const u8 *in,
+				      size_t in_len, u8 *out, size_t *out_len);
+
+  int sc_pkcs1_encode(sc_context_t *ctx, unsigned long flags,
+		      const u8 *in, size_t in_len, u8 *out, size_t *out_len, size_t mod_len);
+
+  int get_real_certificate_length( struct sc_pkcs15_card *p15card,
+				   struct sc_pkcs15_cert_info *cert_info );
+
+  int asn1_decode_path(sc_context_t *ctx, const u8 *in, size_t len,
+			     sc_path_t *path, int depth);
+
+  int sc_pkcs15_card_encode_df(sc_context_t *ctx,
+			       struct sc_pkcs15_card *p15card,
+			       struct sc_pkcs15_df *df,
+			       u8 **buf_out, size_t *bufsize_out);
+  int sc_pkcs15_encode_pubkey(sc_context_t *ctx,
+				    struct sc_pkcs15_pubkey *key,
+				    u8 **buf, size_t *len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PKCS15_DEFAULT_H */
Index: opensc-0.11.12/src/libopensc/dnie/pkcs15_standard.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/pkcs15_standard.c	2010-11-17 19:14:03.000000000 +0000
@@ -0,0 +1,350 @@
+/*
+ * pkcs15_standard.c: Functions dealing with standard PKCS#15 
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#include <string.h>
+#include "pkcs15_standard.h"
+#include <opensc/log.h>
+#include <assert.h>
+
+/**
+   This function is almost identical to sc_pkcs15_parse_df, but
+   it gets the data from a buffer, instead than from a file
+   
+   @param p15_df PKCS#15 df file
+   @param p15card Structure where objects are stored (also contains card and ctx)
+*/
+int sc_standard_pkcs15_parse_df(struct sc_pkcs15_card *p15card, 
+				sc_pkcs15_df_t *df,
+				u8 *buf,
+				size_t bufsize)
+				
+{
+  sc_context_t *ctx = p15card->card->ctx;
+  const u8 *p;
+  int r = SC_SUCCESS;
+  struct sc_pkcs15_object *obj = NULL;
+  int (* func)(struct sc_pkcs15_card *, struct sc_pkcs15_object *,
+	       const u8 **nbuf, size_t *nbufsize) = NULL;
+
+  switch (df->type) {
+  case SC_PKCS15_PRKDF:
+    func = sc_pkcs15_decode_prkdf_entry;
+    break;
+  case SC_PKCS15_PUKDF:
+    func = sc_pkcs15_decode_pukdf_entry;
+    break;
+  case SC_PKCS15_CDF:
+  case SC_PKCS15_CDF_TRUSTED:
+  case SC_PKCS15_CDF_USEFUL:
+    func = sc_pkcs15_decode_cdf_entry;
+    break;
+  case SC_PKCS15_DODF:
+    func = sc_pkcs15_decode_dodf_entry;
+    break;
+  case SC_PKCS15_AODF:
+    func = sc_pkcs15_decode_aodf_entry;
+    break;
+  }
+  
+  if (func == NULL) {
+    sc_error(ctx, "unknown DF type: %d\n", df->type);
+    return SC_ERROR_INVALID_ARGUMENTS;
+  }
+
+  p = buf;
+  while (bufsize && *p != 0x00) {
+    const u8 *oldp;
+    size_t obj_len;
+                
+    obj = (struct sc_pkcs15_object *) calloc(1, sizeof(struct sc_pkcs15_object));
+    if (obj == NULL) {
+      r = SC_ERROR_OUT_OF_MEMORY;
+      goto ret;
+    }
+    oldp = p;
+    r = func(p15card, obj, &p, &bufsize);
+    if (r) {
+      free(obj);
+      if (r == SC_ERROR_ASN1_END_OF_CONTENTS) {
+	r = 0;
+	break;
+      }
+      sc_error(ctx, r, "Error decoding DF entry");
+      goto ret;
+    }
+    obj_len = p - oldp;
+    
+    obj->der.value = (u8 *) malloc(obj_len);
+    if (obj->der.value == NULL) {
+      r = SC_ERROR_OUT_OF_MEMORY;
+      goto ret;
+    }
+    memcpy(obj->der.value, oldp, obj_len);
+    obj->der.len = obj_len;
+    
+    obj->df = df;
+    r = sc_pkcs15_add_object(p15card, obj);
+    if (r) {
+      if (obj->data)
+	free(obj->data);
+      free(obj);
+      sc_error(ctx, r, "Error adding object");
+      goto ret;
+    }
+  };
+ret:
+  return r;
+}
+
+/**
+   This function is similar to sc_pkcs15_encode_df, but
+   it encodes a list of PKCS#15 DF's objects of the same type
+   to an output buffer.
+   This function encodes any type of DF: ODF, TokenInfo, UnusedSpace 
+   and the default ones, DODF, AODF, CDF, PrKDF and PuKDF.
+   
+   @param ctx context
+   @param p15card structure where objects are stored
+   @param type of df objects stores on p15card
+   @param buf_out output buffer where encoded data is stored
+   @param bufsize_out output buffer length
+*/
+int sc_standard_pkcs15_encode_any_df(sc_context_t *ctx,
+				     struct sc_pkcs15_card *p15card,
+				     const unsigned int df_type,
+				     u8 **buf_out, size_t *bufsize_out)
+{
+  int (*func)(sc_context_t *ctx,
+	      struct sc_pkcs15_card *p15card,
+	      u8 **buf, size_t *buflen) = NULL;
+  int (* func2)(sc_context_t *ctx,
+		sc_pkcs15_tokeninfo_t *ti,
+		u8 **buf, size_t *buflen) = NULL;
+  int r = SC_SUCCESS;
+  
+  if (ctx->debug) sc_debug(ctx, "Entering function sc_standard_pkcs15_encode_df\n");
+ 
+  assert(p15card != NULL && p15card->magic == SC_PKCS15_CARD_MAGIC);
+
+  /* check buffers and free them if needed */
+  if(buf_out && *buf_out) {
+    free(*buf_out);
+    *buf_out = NULL;
+  }
+  
+  if(bufsize_out)
+    *bufsize_out = 0;
+
+  switch (df_type) {
+  case SC_PKCS15_ODF:
+    func = sc_pkcs15_encode_odf;
+    break;
+  case SC_PKCS15_UNUSED:
+    func = sc_pkcs15_encode_unusedspace;
+    break;
+  case SC_PKCS15_TOKENINFO:
+    func2 = sc_pkcs15_encode_tokeninfo;
+  }
+  if (func == NULL && func2 == NULL) {
+    if (ctx->debug) sc_debug(ctx, "Going to encode the other PKCS#15 DF\n");
+    /* decode the other PKCS#15 DF as usual */
+    r = sc_standard_pkcs15_encode_other_df( ctx, p15card, df_type, buf_out, bufsize_out );
+    goto sspead_out;
+  }
+
+  if (func2){
+    sc_pkcs15_tokeninfo_t tokeninfo;
+
+    /* create a temporary tokeninfo structure */
+    /* memset(&tokeninfo,0,sizeof(tokeninfo));*/ /* (from OpenSC-0.12.0 */
+    tokeninfo.version = p15card->version;
+    tokeninfo.flags = p15card->flags;
+    tokeninfo.label = p15card->label;
+    tokeninfo.serial_number = p15card->serial_number;
+    tokeninfo.manufacturer_id = p15card->manufacturer_id;
+    tokeninfo.last_update = p15card->last_update;
+    tokeninfo.preferred_language = p15card->preferred_language;
+
+    if (ctx->debug) sc_debug(ctx, "Going to encode TokenInfo PKCS#15 DF\n");
+    r = sc_pkcs15_encode_tokeninfo( ctx, &tokeninfo, buf_out, bufsize_out );
+    goto sspead_out;
+
+  }
+  /* decode ODF or UNUSED_SPACE PKCS#15 DF */
+  if (ctx->debug) sc_debug(ctx, "Going to encode ODF or UNUSED_SPACE PKCS#15 DF\n");
+  r = func( ctx, p15card, buf_out, bufsize_out );
+  
+ sspead_out:
+  if (ctx->debug) sc_debug(ctx, "Leaving function sc_standard_pkcs15_encode_df\n");
+  return r;
+}
+
+
+/**
+   This function is almost identical to sc_pkcs15_encode_df, but
+   it gets as a parameter a DF type instead of a df struct. 
+
+   That is because we do not have a real sc_pkcs15_df struct 
+   when calling this function and we only want to decode a list
+   of PKCS#15 DF objects of the same type to a buffer.
+
+   Another difference from the original function is that we
+   allocate memory directly to the output buffer instead of
+   creating a temporal one.
+   
+   @param ctx context
+   @param p15card structure where objects are stored
+   @param type of df objects stores on p15card
+   @param buf_out output buffer where encoded data is stored
+   @param bufsize_out output buffer length
+*/
+int sc_standard_pkcs15_encode_other_df(sc_context_t *ctx,
+				       struct sc_pkcs15_card *p15card,
+				       const unsigned int df_type,
+				       u8 **buf_out, size_t *bufsize_out)
+{
+  u8 *tmp = NULL;
+  size_t bufsize = 0, tmpsize;
+  const struct sc_pkcs15_object *obj;
+  int (* func)(sc_context_t *, const struct sc_pkcs15_object *nobj,
+	       u8 **nbuf, size_t *nbufsize) = NULL;
+  int r = SC_SUCCESS;
+
+  if (ctx->debug) sc_debug(ctx, "Entering function sc_standard_pkcs15_encode_other_df\n");
+
+  assert(p15card != NULL && p15card->magic == SC_PKCS15_CARD_MAGIC);
+
+  /* check buffers and free them if needed */
+  if(buf_out && *buf_out) {
+    free(*buf_out);
+    *buf_out = NULL;
+  }
+  
+  if(bufsize_out)
+    *bufsize_out = 0;
+
+  switch (df_type) {
+  case SC_PKCS15_PRKDF:
+    func = sc_pkcs15_encode_prkdf_entry;
+    break;
+  case SC_PKCS15_PUKDF:
+  case SC_PKCS15_PUKDF_TRUSTED:
+    func = sc_pkcs15_encode_pukdf_entry;
+    break;
+  case SC_PKCS15_CDF:
+  case SC_PKCS15_CDF_TRUSTED:
+  case SC_PKCS15_CDF_USEFUL:
+    func = sc_pkcs15_encode_cdf_entry;
+    break;
+  case SC_PKCS15_DODF:
+    func = sc_pkcs15_encode_dodf_entry;
+    break;
+  case SC_PKCS15_AODF:
+    func = sc_pkcs15_encode_aodf_entry;
+    break;
+  }
+  if (func == NULL) {
+    sc_error(ctx, "unknown DF type: %d\n", df_type);
+    *buf_out = NULL;
+    *bufsize_out = 0;
+    r = SC_ERROR_INVALID_ARGUMENTS;
+    goto sspeod_out;
+  }
+  for (obj = p15card->obj_list; obj != NULL; obj = obj->next) {
+    /* 
+       As each df object is independent one another and
+       struct p15card has only objects of the only one DF, 
+       we can comment the following instructions.
+       We do not have a correct df struct.
+
+    */
+    r = func(ctx, obj, &tmp, &tmpsize);
+    if (r) {
+      free(tmp);
+      free(*buf_out);
+      *buf_out = NULL;
+      goto sspeod_out;
+    }
+    *buf_out = (u8 *) realloc( *buf_out, bufsize + tmpsize);
+    memcpy((*buf_out) + bufsize, tmp, tmpsize);
+    free(tmp);
+    bufsize += tmpsize;
+  }
+  *bufsize_out = bufsize;
+ 
+ sspeod_out:
+  if (ctx->debug) sc_debug(ctx, "Leaving function sc_standard_pkcs15_encode_other_df\n");
+  return r;
+}
+
+
+/**
+   Parses standard PKCS#15 and returns the parsed objects
+   
+   @param card Card Context
+   @param p15_df structure with file to parse
+   @param df Unitialized df file used to parse structure
+   @param temp_p15card Pointer to a NULLified pointer to sc_pkcs15_card_t. A new sc_pkcs15_card will be malloced into this pointer
+*/
+int card_parse_standard_pkcs15( sc_card_t *card,
+				card_pkcs15_df_t *p15_df,
+				sc_pkcs15_df_t *df, 
+				sc_pkcs15_card_t **temp_p15card )
+{
+  int r = SC_SUCCESS;
+  
+  /* we init df type */
+  memset(df, 0, sizeof(*df));
+  df->type = p15_df->type;
+
+  /* we create a fake p15card structure */
+  *temp_p15card = sc_pkcs15_card_new();
+  if(!(*temp_p15card)) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto cpsp_end;
+  }
+
+  /*
+    All paths are hardcoded because we don't have access to
+    real sc_pkcs15_card_t structure to copy data.
+  */
+  if(((*temp_p15card)->file_app = sc_file_new()))
+    sc_format_path("3F005015", &(*temp_p15card)->file_app->path);
+  if(((*temp_p15card)->file_tokeninfo = sc_file_new()))
+    sc_format_path("3F0050155032", &(*temp_p15card)->file_tokeninfo->path);
+  if(((*temp_p15card)->file_odf = sc_file_new()))
+    sc_format_path("3F0050155031", &(*temp_p15card)->file_odf->path);
+
+  (*temp_p15card)->card = card;
+  
+  /* parse df */
+  r = sc_standard_pkcs15_parse_df((*temp_p15card), df, p15_df->data, p15_df->filled_len);
+
+  cpsp_end:
+  if(r != SC_SUCCESS) {
+    if(temp_p15card && *temp_p15card) {
+      sc_pkcs15_card_free(*temp_p15card);
+      *temp_p15card = NULL;
+    }
+  }
+
+  SC_FUNC_RETURN(card->ctx, 1, r);
+}
Index: opensc-0.11.12/src/libopensc/dnie/pkcs15_standard.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/pkcs15_standard.h	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,56 @@
+/*
+ * pkcs15_standard.h: Header for definitions related to parsing of
+ *                    standard PKCS#15 structures.
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+
+#ifndef _PKCS15_STANDARD_H
+#define _PKCS15_STANDARD_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "base_card.h"
+
+int card_parse_standard_pkcs15( sc_card_t *card,
+				card_pkcs15_df_t *p15_df,
+				sc_pkcs15_df_t *df, 
+				sc_pkcs15_card_t **temp_p15card );
+
+int sc_standard_pkcs15_parse_df(struct sc_pkcs15_card *p15card, 
+				sc_pkcs15_df_t *df,
+				u8 *buf,
+				size_t bufsize);
+  
+int sc_standard_pkcs15_encode_any_df(sc_context_t *ctx,
+				     struct sc_pkcs15_card *p15card,
+				       const unsigned int df_type,
+				     u8 **buf_out, size_t *bufsize_out);
+
+int sc_standard_pkcs15_encode_other_df(sc_context_t *ctx,
+				       struct sc_pkcs15_card *p15card,
+				       const unsigned int df_type,
+				       u8 **buf_out, size_t *bufsize_out);  
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PKCS15_STANDARD_H */
Index: opensc-0.11.12/src/libopensc/dnie/trusted_channel_card.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/trusted_channel_card.c	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,1228 @@
+/*
+ * trusted_channel_card.c: Support for trusted channel for the DNIe card
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#include <string.h>
+#include <stdlib.h>
+#include <openssl/sha.h>
+#include <openssl/rsa.h>
+#include <openssl/rand.h>
+#include <openssl/des.h>
+#include <libopensc/internal.h> 
+#include <opensc/opensc.h>
+#include <opensc/cardctl.h>
+#include <opensc/log.h>
+#include <opensc/asn1.h>
+#include "base_card.h"
+#include "card_helper.h"
+
+/* tags for secure channel data */
+#define TAG_PICG 0x87
+#define TAG_CC 0x8e
+#define TAG_LE 0x97
+#define TAG_SW 0x99
+
+
+/* use test keys */
+#define TEST_KEYS 0
+
+
+
+ /* Here go private and public keys */
+#include "keys.inc"
+
+
+/* function copied from ../pkcs15-cert.c */
+static int parse_x509_cert(sc_context_t *ctx, const u8 *buf, size_t buflen, struct sc_pkcs15_cert *cert)
+{
+        int r;
+        struct sc_algorithm_id pk_alg, sig_alg;
+        struct sc_pkcs15_pubkey pubkey;
+        sc_pkcs15_der_t pk = { NULL, 0 };
+        struct sc_asn1_entry asn1_version[] = {
+                { "version", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, 0, &cert->version, NULL },
+                { NULL, 0, 0, 0, NULL, NULL }
+        };
+        struct sc_asn1_entry asn1_pkinfo[] = {
+                { "algorithm",          SC_ASN1_ALGORITHM_ID,  SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, &pk_alg, NULL },
+                { "subjectPublicKey",   SC_ASN1_BIT_STRING_NI, SC_ASN1_TAG_BIT_STRING, SC_ASN1_ALLOC, &pk.value, &pk.len },
+                { NULL, 0, 0, 0, NULL, NULL }
+        };
+        struct sc_asn1_entry asn1_x509v3[] = {
+                { "certificatePolicies",        SC_ASN1_OCTET_STRING, SC_ASN1_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },
+                { "subjectKeyIdentifier",       SC_ASN1_OCTET_STRING, SC_ASN1_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },
+                { "crlDistributionPoints",      SC_ASN1_OCTET_STRING, SC_ASN1_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL | SC_ASN1_ALLOC, &cert->crl, &cert->crl_len },
+                { "authorityKeyIdentifier",     SC_ASN1_OCTET_STRING, SC_ASN1_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },
+                { "keyUsage",                   SC_ASN1_BOOLEAN, SC_ASN1_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },
+                { NULL, 0, 0, 0, NULL, NULL }
+        };
+        struct sc_asn1_entry asn1_extensions[] = {
+                { "x509v3",             SC_ASN1_STRUCT,    SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, asn1_x509v3, NULL },
+                { NULL, 0, 0, 0, NULL, NULL }
+        };
+        struct sc_asn1_entry asn1_tbscert[] = {
+                { "version",            SC_ASN1_STRUCT,    SC_ASN1_CTX | 0 | SC_ASN1_CONS, SC_ASN1_OPTIONAL, asn1_version, NULL },
+                { "serialNumber",       SC_ASN1_OCTET_STRING, SC_ASN1_TAG_INTEGER, SC_ASN1_ALLOC, &cert->serial, &cert->serial_len },
+                { "signature",          SC_ASN1_STRUCT,    SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },
+                { "issuer",             SC_ASN1_OCTET_STRING, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_ALLOC, &cert->issuer, &cert->issuer_len },
+                { "validity",           SC_ASN1_STRUCT,    SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },
+                { "subject",            SC_ASN1_OCTET_STRING, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_ALLOC, &cert->subject, &cert->subject_len },
+                { "subjectPublicKeyInfo",SC_ASN1_STRUCT,   SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, asn1_pkinfo, NULL },
+                { "extensions",         SC_ASN1_STRUCT,    SC_ASN1_CTX | 3 | SC_ASN1_CONS, SC_ASN1_OPTIONAL, asn1_extensions, NULL },
+                { NULL, 0, 0, 0, NULL, NULL }
+        };
+        struct sc_asn1_entry asn1_cert[] = {
+                { "tbsCertificate",     SC_ASN1_STRUCT,    SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, asn1_tbscert, NULL },
+                { "signatureAlgorithm", SC_ASN1_ALGORITHM_ID, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, &sig_alg, NULL },
+                { "signatureValue",     SC_ASN1_BIT_STRING, SC_ASN1_TAG_BIT_STRING, 0, NULL, NULL },
+                { NULL, 0, 0, 0, NULL, NULL }
+        };
+        const u8 *obj;
+        size_t objlen;
+
+        memset(cert, 0, sizeof(*cert));
+        obj = sc_asn1_verify_tag(ctx, buf, buflen, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS,
+                                 &objlen);
+        if (obj == NULL) {
+                sc_error(ctx, "X.509 certificate not found\n");
+                return SC_ERROR_INVALID_ASN1_OBJECT;
+        }
+        cert->data_len = objlen + (obj - buf);
+        r = sc_asn1_decode(ctx, asn1_cert, obj, objlen, NULL, NULL);
+        SC_TEST_RET(ctx, r, "ASN.1 parsing of certificate failed");
+
+        cert->version++;
+        
+        /* JAMC 02-11-2010 patches for opensc-0.12.x */
+        // cert->key = malloc(sizeof(struct sc_pkcs15_pubkey));
+        // if (cert->key == NULL) return SC_ERROR_OUT_OF_MEMORY;
+        // memcpy(cert->key, &pubkey, sizeof(struct sc_pkcs15_pubkey));
+        // cert->key->alg_id = malloc(sizeof(struct sc_algorithm_id));
+        // if (cert->key->alg_id == NULL) return SC_ERROR_OUT_OF_MEMORY;
+        // memcpy(cert->key->alg_id, &pk_alg, sizeof(struct sc_algorithm_id));
+        /* end patch */
+
+        cert->key.algorithm = pk_alg.algorithm;
+        pk.len >>= 3;   /* convert number of bits to bytes */
+        cert->key.data = pk;
+
+        r = sc_pkcs15_decode_pubkey(ctx, &cert->key, pk.value, pk.len);
+        if (r < 0)
+                free(pk.value);
+        sc_asn1_clear_algorithm_id(&pk_alg);
+        sc_asn1_clear_algorithm_id(&sig_alg);
+
+        return r;
+}
+
+static int card_extract_signature_data(sc_context_t *ctx,
+				       const u8* data,
+				       size_t data_length,
+				       const u8* ifd_data,
+				       u8* kicc)
+{
+  u8 to_be_hashed[74+32+32];
+  u8 digest[SHA_DIGEST_LENGTH];
+
+  if (ctx->debug) sc_debug(ctx, "Entering function card_compare_signature_data\n");
+
+  if (data_length != 128) {
+    if (ctx->debug) sc_debug(ctx, "data should be 128-byte long.\n");
+    return SC_ERROR_INVALID_CARD;
+  }
+  
+  if (data[0]!=0x6a || data[127]!=0xbc) {
+    if (ctx->debug) sc_debug(ctx, "data doesn't match 6A ... BC\n");
+    return SC_ERROR_INVALID_CARD;
+  }
+
+  memcpy(to_be_hashed, data+1, 74+32);
+  memcpy(to_be_hashed+74+32, ifd_data, 16);
+  SHA1(to_be_hashed, 74+32+16, digest);
+
+  if (memcmp(data+127-SHA_DIGEST_LENGTH, digest, SHA_DIGEST_LENGTH) != 0) {
+    if (ctx->debug) sc_debug(ctx, "hashes doesn't match\n");
+    return SC_ERROR_INVALID_CARD;
+  }
+
+  memcpy(kicc, data+1+74, 32);
+
+  if (ctx->debug) sc_debug(ctx, "card_compare_signature_data ok!\n");
+  return SC_SUCCESS;
+}
+
+static int card_verify_signature(sc_context_t *ctx,
+				 u8* signature,
+				 int signature_length,
+				 const u8* ifd_data,
+				 int ifd_data_length,
+				 RSA* ifd_private_key,
+				 RSA* icc_public_key,
+				 u8* kicc)
+{
+  int r = SC_SUCCESS;
+  u8 decrypted[CARD_SCHANNEL_KEYLEN_IN_BYTES];
+  int decrypted_length;
+  u8 encrypted[CARD_SCHANNEL_KEYLEN_IN_BYTES];
+  int encrypted_length;
+  u8 min_sig[CARD_SCHANNEL_KEYLEN_IN_BYTES];
+  int min_sig_length;
+  BIGNUM *min_sig_bignum = NULL;
+  BIGNUM *decrypted_bignum = NULL;
+
+
+  if (ctx->debug) sc_debug(ctx, "Entering function card_verify_signature\n");
+
+  if(signature_length != 128) {
+    if (ctx->debug) sc_debug(ctx, "Signature should be 128-byte long\n");
+    r = SC_ERROR_INVALID_CARD;
+  }
+
+  if(ifd_data_length != 0x10) {
+    if (ctx->debug) sc_debug(ctx, "ifd_data should be 0x10-byte long\n");
+    r = SC_ERROR_INVALID_CARD;
+  }
+
+  if ((decrypted_length = RSA_private_decrypt(signature_length,
+					      signature,
+					      decrypted,
+					      ifd_private_key,				   
+					      RSA_NO_PADDING)) <= 0) {
+    if (ctx->debug) sc_debug(ctx, "Error in decryption RSA routine.\n");
+    r = SC_ERROR_DECRYPT_FAILED;
+    goto dvs_end; /* to deallocate resources */
+  }
+  
+  if ((encrypted_length = RSA_public_encrypt(decrypted_length,
+					      decrypted,
+					      encrypted,
+					      icc_public_key,				   
+					      RSA_NO_PADDING)) <= 0) {
+    if (ctx->debug) sc_debug(ctx, "Error in encryption RSA routine.\n");
+    r = SC_ERROR_INVALID_CARD;
+    goto dvs_end; /* to deallocate resources */
+  }
+
+  r = card_extract_signature_data(ctx, encrypted, encrypted_length, ifd_data, kicc);
+  if (r != SC_SUCCESS) {
+    decrypted_bignum = BN_bin2bn(decrypted, decrypted_length, NULL);
+    min_sig_bignum = BN_new();
+    if(!decrypted_bignum || !min_sig_bignum) {
+      r = SC_ERROR_INVALID_CARD;
+      goto dvs_end; /* to deallocate resources */
+    }
+
+    if(!BN_sub(min_sig_bignum, icc_public_key->n, decrypted_bignum)) {
+      r = SC_ERROR_INVALID_CARD;
+      goto dvs_end; /* to deallocate resources */
+    }
+
+    if((min_sig_length = BN_bn2bin(min_sig_bignum, min_sig)) <= 0) {
+      if (ctx->debug) sc_debug(ctx, "Error in converting min_sig_bignum to min_sig.\n");
+      r= SC_ERROR_INVALID_CARD;
+      goto dvs_end; /* to deallocate resources */
+    }
+
+    if ((encrypted_length = RSA_public_encrypt(min_sig_length,
+					      min_sig,
+					      encrypted,
+					      icc_public_key,				   
+					      RSA_NO_PADDING)) == -1) {
+      if (ctx->debug) sc_debug(ctx, "Error in encryption RSA routine.\n");
+      r = SC_ERROR_INVALID_CARD;
+      goto dvs_end; /* to deallocate resources */
+    }
+ 
+    r = card_extract_signature_data(ctx, encrypted, encrypted_length, ifd_data, kicc);
+  }
+    
+ dvs_end:
+  if(min_sig_bignum)
+    BN_free(min_sig_bignum);
+  if(decrypted_bignum)
+    BN_free(decrypted_bignum);
+ 
+  if (ctx->debug) sc_debug(ctx,"Leaving function card_verify_signature 0x%X\n", r);
+
+  return r;
+}
+
+static int card_sign_authentication_data(sc_context_t *ctx,
+					 const sc_serial_number_t *serial_number,
+					 const u8 *challenge,
+					 RSA* ifd_private_key,
+					 RSA* icc_public_key,
+					 u8 *kifd, /* 32-byte long  buffer that this function will fill */
+					 u8 *signature /* 128-byte long buffer with signature used in external authenticate */
+					 )
+{
+  int r = SC_SUCCESS;
+  u8 decrypted[128];
+  u8 to_be_signed[128];
+  u8 min_sig[128];
+  u8 rnd[74];
+  u8 to_be_hashed[74+32+8+8];
+  u8 digest[SHA_DIGEST_LENGTH];
+  int decrypted_length;
+  int encrypted_length;
+  int min_sig_length;
+  BIGNUM *decrypted_bignum = NULL;
+  BIGNUM *min_sig_bignum = NULL;
+  BIGNUM *sub_bignum = NULL;
+
+
+  if (ctx->debug) sc_debug(ctx, "Entering function card_prepare_authenticate_data\n");
+
+  /* I: PREPARE DATA TO BE SIGNED */
+  
+  /* 1: 6A */
+  to_be_signed[0] = 0x6a;
+  
+  /* 2: pRND */
+  RAND_bytes(rnd, sizeof(rnd));
+  memcpy(to_be_signed+1, rnd, sizeof(rnd));
+
+  /* 3: kIFD */
+  RAND_bytes(kifd, 32);
+  memcpy(to_be_signed+1+sizeof(rnd), kifd, 32);
+
+  /* 4: hash */
+  memcpy(to_be_hashed, rnd, 74);
+  memcpy(to_be_hashed+74, kifd, 32);
+  memcpy(to_be_hashed+74+32, challenge, 8);
+  to_be_hashed[74+32+8] = 0; /* algorithm expects 8 byte serial number, so we prepend a 0 */
+  memcpy(to_be_hashed+74+32+8+1, serial_number->value, 7);
+  SHA1(to_be_hashed, 74+32+16, digest);
+    
+  memcpy(to_be_signed+1+sizeof(rnd)+32, digest, sizeof(digest));
+
+  /* 5: BC */
+  to_be_signed[127] = 0xbc;
+
+
+  /* II: GENERATE SIGNATURE */
+  if ((decrypted_length = RSA_private_decrypt(sizeof(to_be_signed),
+					      to_be_signed,
+					      decrypted,
+					      ifd_private_key,				   
+					      RSA_NO_PADDING)) <= 0) {
+    if (ctx->debug) sc_debug(ctx, "Error in decryption RSA routine.\n");
+    r = SC_ERROR_DECRYPT_FAILED;
+    goto dsad_end; /* to deallocate resources */
+  }
+
+  decrypted_bignum = BN_bin2bn(decrypted, decrypted_length, NULL);
+  sub_bignum = BN_new();
+  if(!decrypted_bignum || !sub_bignum) {
+    r = SC_ERROR_INVALID_CARD;
+    goto dsad_end; /* to deallocate resources */
+  }
+
+  if(!BN_sub(sub_bignum, ifd_private_key->n, decrypted_bignum)) {
+    if (ctx->debug) sc_debug(ctx, "Error in calculating sub_bignum.\n");
+    r = SC_ERROR_INVALID_CARD;
+    goto dsad_end; /* to deallocate resources */
+  }
+
+  if(BN_cmp(decrypted_bignum, sub_bignum) < 0) {
+    min_sig_bignum = decrypted_bignum;
+  } else {
+    min_sig_bignum = sub_bignum;
+  }
+
+  if(BN_num_bytes(min_sig_bignum) > sizeof(min_sig)) {
+    if (ctx->debug) sc_debug(ctx,"Error in min_sig... it's too big.\n");
+    goto dsad_end; /* to deallocate resources */
+  }
+  
+  if((min_sig_length = BN_bn2bin(min_sig_bignum, min_sig)) <= 0) {
+    if (ctx->debug) sc_debug(ctx,"Error in converting min_sig_bignum to min_sig.\n");
+    r= SC_ERROR_INVALID_CARD;
+    goto dsad_end; /* to deallocate resources */
+  }
+
+  if ((encrypted_length = RSA_public_encrypt(min_sig_length,
+					     min_sig,
+					     signature,
+					     icc_public_key,				   
+					     RSA_NO_PADDING)) <= 0) {
+    if (ctx->debug) sc_debug(ctx, "Error in encryption RSA routine.\n");
+    r = SC_ERROR_INVALID_CARD;
+    goto dsad_end; /* to deallocate resources */
+  }
+    
+ dsad_end:
+  /* zero all buffers */
+  memset(decrypted, 0, sizeof(decrypted));
+  memset(to_be_signed, 0, sizeof(to_be_signed));
+  memset(min_sig, 0, sizeof(min_sig));
+  memset(rnd, 0, sizeof(rnd));
+  memset(to_be_hashed, 0, sizeof(to_be_hashed));
+  memset(digest, 0, sizeof(digest));
+
+  /* deallocate BIGNUMs */
+  /* min_sig_bignum is just a weak pointer. don't deallocate it! */
+  if(sub_bignum)
+    BN_free(sub_bignum);
+  if(decrypted_bignum)
+    BN_free(decrypted_bignum);
+  
+  if (ctx->debug) sc_debug(ctx,"Leaving function card_prepare_authenticate_data 0x%X\n", r);
+  
+  return r;
+}
+
+static void card_compute_hashed_key(sc_context_t *ctx,
+				    const u8 *kseed, /* 32-byte long buffer */
+				    const u8 *counter, /* 4-byte long buffer */
+				    u8 *key /* 16-byte long buffer */
+				    )
+{
+  u8 data[32+4];
+  u8 digest[SHA_DIGEST_LENGTH];
+  if (ctx->debug) sc_debug(ctx, "Entering function card_compute_hashed_key\n");
+
+  memcpy(data, kseed, 32);
+  memcpy(data+32, counter, 4);
+  SHA1(data, 32+4, digest);
+
+  /* the key is the 16 first bytes of the digest */
+  memcpy(key, digest, 16);
+  
+  if (ctx->debug) sc_debug(ctx, "Leaving function card_compute_hashed_key\n");
+}
+
+static int card_compute_session_keys(sc_context_t *ctx,
+				     const u8 *kicc, /* 32-byte long buffer */
+				     const u8 *kifd, /* 32-byte long buffer */
+				     const u8 *rndicc, /* 8-byte long buffer */
+				     const u8 *rndifd, /* 8-byte long buffer */
+				     u8 *kenc, /* 16-byte long buffer */
+				     u8 *kmac, /* 16-byte long buffer */
+				     u8 *ssc) /* 8-byte long buffer */
+{
+  int r = SC_SUCCESS;
+  u8 kseed[32];
+  int ii;
+  static const u8 counter_kenc[] = {0,0,0,1};
+  static const u8 counter_kmac[] = {0,0,0,2};
+
+  if (ctx->debug) sc_debug(ctx,"Entering function card_compute_session_keys\n");
+
+  /* calculate kseed */
+  for(ii=0; ii<sizeof(kseed); ii++)
+    kseed[ii] = kicc[ii] ^ kifd[ii];
+  
+  /* calculate kenc */
+  card_compute_hashed_key(ctx, kseed, counter_kenc, kenc);
+
+  /* calculate kmac */
+  card_compute_hashed_key(ctx, kseed, counter_kmac, kmac);
+
+  /* calculate ssc */
+  memcpy(ssc, rndicc+4, 4);
+  memcpy(ssc+4, rndifd+4, 4);
+
+  if (ctx->debug) sc_debug(ctx, "Leaving function card_compute_session_keys 0x%X\n", r);
+  return r;
+}
+
+static void card_calculate_mac(sc_context_t *ctx,
+			       const u8 *data,
+			       int data_length,
+			       const u8 *key, /* 16-byte buffer */
+			       u8 *ssc, /* 8-byte long buffer containing ssc */
+			       u8 *mac /* 4-byte long buffer containing MAC */
+			      )
+{
+  int ii, jj;
+  DES_key_schedule k1, k2;
+  u8 buffer[8];
+  
+  /* preconditions */
+  assert((data_length%8) == 0); /* data must be padded */
+
+  /* prepare encryption keys */
+  DES_set_key_unchecked((const_DES_cblock *)key, &k1);
+  DES_set_key_unchecked((const_DES_cblock *)(key+8), &k2);
+
+  /* calculate ssc */
+  for(ii=7; ii>=0; ii--) {
+    ssc[ii]++;
+    if(ssc[ii])
+      break; /* stop if no carry */
+  }
+
+  /* first block inits with ssc */
+  memcpy(buffer, ssc, 8);
+
+  /* 
+     for each block we encrypt input, xor with
+     data block and feed output to next iteration
+  */
+  for(ii=0; ii<data_length; ii+=8) {
+    DES_ecb_encrypt((const_DES_cblock *)buffer, (DES_cblock *)buffer, &k1, DES_ENCRYPT);
+    for(jj=0; jj<8; jj++)
+      buffer[jj] ^= data[ii+jj];
+  }
+  
+  /* final 3DES */
+  DES_ecb2_encrypt((const_DES_cblock *)buffer, (DES_cblock *)buffer, &k1, &k2, DES_ENCRYPT);
+
+  /* copy to output */
+  memcpy(mac, buffer, 4);
+}
+
+/*
+  buffer must have room for at least 8 bytes more
+  new length will be returned in len
+*/
+static void card_add_7816_padding( u8 *buffer, size_t *len )
+{
+  int zeroes;
+  buffer[(*len)++] = 0x80;
+  zeroes = (8-((*len)%8))%8;
+  if(zeroes)
+    memset(buffer+(*len), 0, zeroes);
+  (*len)+=zeroes;
+}
+
+static int card_add_tlv( u8 tag, u8* buffer, size_t* length )
+{
+  u8 header[4];
+  size_t header_length = 0;
+  
+  header[header_length++] = tag;
+  if(*length < 0x80) {
+    header[header_length++] = *length;
+  } else if(*length < 0x100) {
+    header[header_length++] = 0x81;
+    header[header_length++] = *length;
+  } else if(*length < 0x10000) {
+    header[header_length++] = 0x82;
+    header[header_length++] = ((*length)>>8)&0xff;
+    header[header_length++] = (*length)&0xff;
+  } else {
+    return SC_ERROR_INTERNAL;
+  }
+
+  memmove(buffer+header_length, buffer, *length);
+  memcpy(buffer, header, header_length);
+  *length += header_length;
+
+  return SC_SUCCESS;
+}
+
+int card_prepare_secure_tx(struct sc_card *card,
+				  const sc_apdu_t *orig_apdu,
+				  sc_apdu_t *secure_apdu
+				  )
+{
+  u8 mac_data[1024];
+  size_t mac_data_length = 0;
+  u8 temp[1024];
+  u8 encrypted[1024];
+  u8 tlv_le[3];
+  size_t temp_length, encrypted_length;
+  static const u8 header_padding[] = {0x80, 0x00, 0x00, 0x00};
+  DES_cblock iv = {0,0,0,0,0,0,0,0};
+  DES_key_schedule k1, k2;
+  
+
+  if (card->ctx->debug) sc_debug(card->ctx, "Entering function card_prepare_secure_tx\n");
+  
+  secure_apdu->cse = SC_APDU_CASE_3_SHORT;
+  secure_apdu->cla = orig_apdu->cla | 0x0c; /* flag this message is secured */
+  secure_apdu->ins = orig_apdu->ins;
+  secure_apdu->p1 = orig_apdu->p1;
+  secure_apdu->p2 = orig_apdu->p2;
+  secure_apdu->lc = 0;
+  secure_apdu->le = 0;
+
+  /* prepare mac */
+  mac_data[mac_data_length++] = secure_apdu->cla;
+  mac_data[mac_data_length++] = secure_apdu->ins;
+  mac_data[mac_data_length++] = secure_apdu->p1;
+  mac_data[mac_data_length++] = secure_apdu->p2;
+  
+  memcpy(mac_data+mac_data_length, header_padding, sizeof(header_padding));
+  mac_data_length += sizeof(header_padding);
+
+  if(orig_apdu->lc>0) {
+    /* copy data */
+    memcpy(temp, orig_apdu->data, orig_apdu->lc);
+    temp_length = orig_apdu->lc;
+ 
+    /* pad data using 7816 padding */
+    card_add_7816_padding(temp, &temp_length);
+
+    /* prepare keys */
+    DES_set_key_unchecked((const_DES_cblock *)(DRVDATA(card)->kenc), &k1);
+    DES_set_key_unchecked((const_DES_cblock *)(DRVDATA(card)->kenc+8), &k2);
+
+    /* add info about padding in encrypted buffer */
+    encrypted[0] = 1;
+    
+    if (card->ctx->debug) sc_debug(card->ctx, "temp_length = 0x%X\n", temp_length);
+    /* encrypt using 3DES CBC */
+    DES_ede3_cbc_encrypt(temp,
+			 &encrypted[1],
+			 temp_length,
+			 &k1,
+			 &k2,
+			 &k1,
+			 &iv,
+			 DES_ENCRYPT);
+    encrypted_length = temp_length+1; /* length is increased in 1 for the padding info byte */
+    
+    if(card_add_tlv(TAG_PICG, encrypted, &encrypted_length) != SC_SUCCESS) {
+      if (card->ctx->debug) sc_debug(card->ctx, "Error while adding tlv to encrypted data\n");
+      return SC_ERROR_INTERNAL;
+    }
+
+    /* copy tlv encrypted data to data to calculate mac */
+    memcpy(mac_data+mac_data_length, encrypted, encrypted_length);
+    mac_data_length += encrypted_length;
+
+    /* copy tlv encrypted data to destination */
+    memcpy((u8 *)secure_apdu->data, /* this can be modified since it's created
+				       as a static variable so we un-const it */
+	   encrypted,
+	   encrypted_length);
+    secure_apdu->lc += encrypted_length;
+  }
+
+  if((orig_apdu->le>0) && (orig_apdu->le<=0x100)) {
+    /* code TLV */
+    tlv_le[0] = TAG_LE;
+    tlv_le[1] = 1;
+    tlv_le[2] = orig_apdu->le;
+    
+    memcpy(mac_data+mac_data_length, tlv_le, sizeof(tlv_le));
+    mac_data_length += sizeof(tlv_le);
+
+    /* copy tlv le data to destination */
+    memcpy((u8 *)secure_apdu->data+secure_apdu->lc, /* this can be modified since it's created
+						       as a static variable so we un-const it */
+	   tlv_le, 
+	   sizeof(tlv_le));
+    secure_apdu->lc += sizeof(tlv_le);
+  }
+
+  if((orig_apdu->lc>0) ||
+     ((orig_apdu->le>0) && (orig_apdu->le<=0x100))) {
+    card_add_7816_padding(mac_data, &mac_data_length);
+  }  
+
+  /* calculate and append mac */
+  /* secure_apdu->data can be modified since it's created
+     as a static variable so we un-const it */
+  ((u8 *)secure_apdu->data)[secure_apdu->lc++] = TAG_CC; /* tag */
+  ((u8 *)secure_apdu->data)[secure_apdu->lc++] = 4; /* length */
+  card_calculate_mac(card->ctx,
+		     mac_data, 
+		     mac_data_length, 
+		     DRVDATA(card)->kmac, 
+		     DRVDATA(card)->ssc,
+		     (u8 *)&secure_apdu->data[secure_apdu->lc]); /* this can be modified since it's created
+								    as a static variable so we un-const it */
+  
+  /* mac is 4-byte long */
+  secure_apdu->lc += 4;
+
+  /* update datalen */
+  secure_apdu->datalen = secure_apdu->lc;
+
+  if (card->ctx->debug) sc_debug(card->ctx, "Leaving function card_prepare_secure_tx\n");
+  return SC_SUCCESS;
+}			  
+
+
+ 
+static int card_decode_next_tlv(sc_context_t *ctx,
+				const u8 *buffer,
+				size_t buffer_length,
+				u8 *tag,
+				size_t *length,
+				const u8 **value,
+				const u8 **next_pos
+				)
+{
+  if(buffer_length<2) {
+    if (ctx->debug) sc_debug(ctx, "Expecting at least 2 bytes: returning SC_ERROR_INVALID_DATA\n");
+    return SC_ERROR_INVALID_DATA;
+  }
+
+  /* get tag */
+  *tag = buffer[0];
+
+  if(buffer[1]<0x80) {
+    *length = buffer[1]&0x7f;
+    *value = buffer+2;
+  } else if(buffer[1]==0x80) {
+    *length = 0;
+    *value = buffer+2;
+  } else if(buffer[1]==0x81) {
+    *length = buffer[2];
+    *value = buffer+3;
+  } else if(buffer[1]==0x82) {
+    *length = ((size_t)buffer[2]<<8)|buffer[3];
+    *value = buffer+4;
+  } else {
+    if (ctx->debug) sc_debug(ctx, "Invalid length byte 0x%X\n", buffer[1]);
+    return SC_ERROR_INVALID_DATA;
+  }
+
+  /* update next_pos */
+  *next_pos = *value + *length;
+  
+  return SC_SUCCESS;
+}				
+
+/*
+  this function updates apdu->resp, apdu->resplen, apdu->sw1 and apdu->sw2
+  decoding and checking data from secure_apdu
+*/
+
+static int card_parse_secure_rx(struct sc_card *card,
+				const sc_apdu_t *secure_apdu,
+				sc_apdu_t *apdu
+				)
+{
+  int r = SC_SUCCESS;
+  const u8 *p = secure_apdu->resp;
+  const u8 *pf = secure_apdu->resp + secure_apdu->resplen;
+  u8 tag;
+  size_t length;
+  const u8 *value = NULL;
+  DES_cblock iv = {0,0,0,0,0,0,0,0};
+  DES_key_schedule k1, k2;
+  int ii;
+  int tags_checked = 0;
+  u8 temp[1024];
+  size_t temp_length;
+  u8 mac[4];
+  int resplen = apdu->resplen;
+
+
+  /* init apdu->resplen */
+  apdu->resplen = 0;
+
+  if (card->ctx->debug) sc_debug(card->ctx, "Entering function card_parse_secure_rx\n");
+  while(p<pf) {
+    if((r = card_decode_next_tlv(card->ctx, p, pf-p, &tag, &length, &value, &p)) != SC_SUCCESS) {
+      if (card->ctx->debug) sc_debug(card->ctx, "Error in card_decode_next_tlv. Returning 0x%X\n", r);
+      return r;
+    }
+
+    switch(tag) {
+    case TAG_PICG:
+      /* gets encrypted data and inserts it in apdu->resp if present...
+	 also updates apdu->resplen */
+      if(!apdu->resp) {
+	apdu->resplen = 0;
+      } else {
+	if((length<9) || (length>512) || ((length-1)%8)!=0) {
+	  /* minimmum message is pad info byte plus 1 block (8 bytes) */
+	  /* second comparison protects from buffer overflows */
+	  /* third comparison assures that data is pad info
+	     byte plus result of a 3DES CBC (multiple of 8) */
+	  if (card->ctx->debug) sc_debug(card->ctx, "ERROR: Invalid PIGC length\n");
+	  return SC_ERROR_INVALID_DATA;
+	}
+	if(value[0]!=1) {
+	  /* pad info byte MUST be 1 */
+	  if (card->ctx->debug) sc_debug(card->ctx, "ERROR: Invalid pad info byte\n");
+	  return SC_ERROR_INVALID_DATA;
+	}
+	/* prepare keys */
+	DES_set_key_unchecked((const_DES_cblock *)(DRVDATA(card)->kenc), &k1);
+	DES_set_key_unchecked((const_DES_cblock *)(DRVDATA(card)->kenc+8), &k2);
+	
+	/* decrypt using 3DES CBC */
+	DES_ede3_cbc_encrypt(value+1,
+			     temp,
+			     length-1,
+			     &k1,
+			     &k2, 
+			     &k1,
+			     &iv, 
+			     DES_DECRYPT);
+	
+	/* a pad info byte has to be substracted from length */
+	length--;
+
+	if(length<8) {
+	  if (card->ctx->debug) sc_debug(card->ctx, "ERROR: Invalid length. Can't have a proper padding\n");
+	  return SC_ERROR_INVALID_DATA;
+	}
+
+	/* substract 0 in padding. */
+	for(ii=0; (temp[--length] == 0)&&(ii<8); ii++); /* do nothing inside the for */
+	
+	if(ii>7) {
+	  if (card->ctx->debug) sc_debug(card->ctx, "ERROR: Invalid padding (too much 0)\n");
+	  /* at least 8 bytes needed to check the padding */
+	  return SC_ERROR_INVALID_DATA;
+	}
+
+	/* assure last byte from padding is a 0x80.
+	   No decrement needed here, we are comparing the same byte that ended the for,
+	   which is already excluded from data! */
+	if(temp[length] != 0x80) {
+	  if (card->ctx->debug) sc_debug(card->ctx, "ERROR: Invalid padding (0x80 missing)\n");
+	  return SC_ERROR_INVALID_DATA;
+	}
+
+	if(length>resplen) {
+	  if (card->ctx->debug) sc_debug(card->ctx, "ERROR: Buffer too small\n");
+	  return SC_ERROR_INVALID_DATA;
+	}
+	
+	memcpy(apdu->resp, temp, length);
+	resplen = length;
+	apdu->resplen = length;
+
+	tags_checked |= 1; /* flag we checked TAG_PIGC */
+      }
+      break;
+
+    case TAG_SW:
+      /* we process sw data and set apdu->sw1 and apdu->sw2 accordingly */
+      if(length!=2) {
+	/* we expect 2 bytes: sw1 and sw2 */
+	if (card->ctx->debug) sc_debug(card->ctx, "ERROR: Invalid TAG_SW length\n");
+	return SC_ERROR_INVALID_DATA;
+      }
+      apdu->sw1 = value[0];
+      apdu->sw2 = value[1];
+
+      tags_checked |= 2; /* flag we checked TAG_SW */
+      break;
+
+    case TAG_CC:
+      /* we check mac */
+
+      if(length!=4) {
+	/* we expect 4 bytes*/
+	if (card->ctx->debug) sc_debug(card->ctx, "ERROR: Invalid TAG_CC length\n");
+	return SC_ERROR_INVALID_DATA;
+      }
+
+      /* we compute mac usign data from secure_apdu->resp to value-1(for the tag)-1(the length)
+	 which is the data before TAG_CC
+      */
+
+      /* calculate length (cc value) - (cc tag) - (cc length byte) */
+      temp_length = value-1-1-secure_apdu->resp;
+      if(temp_length>(sizeof(temp)-8)) {
+	/* too long for temp. protect from buffer overflows. This can't happen */
+	/* we leave 8 extra bytes to make room for padding */
+	if (card->ctx->debug) sc_debug(card->ctx,"ERROR: Too much data to calculate mac\n");
+	return SC_ERROR_INVALID_DATA;
+      }
+      
+      /* copy data to calculate mac */
+      memcpy(temp, secure_apdu->resp, temp_length);
+      card_add_7816_padding(temp, &temp_length);
+      /* calculate mac */
+      card_calculate_mac(card->ctx,
+			 temp, 
+			 temp_length, 
+			 DRVDATA(card)->kmac, 
+			 DRVDATA(card)->ssc,
+			 mac);
+      
+      /* check mac */
+      if(memcmp(value, mac, sizeof(mac)) != 0) {
+	if (card->ctx->debug) sc_debug(card->ctx,"ERROR: macs don't match\n");
+	return SC_ERROR_INVALID_DATA;
+      }
+      tags_checked |= 4; /* flag we checked TAG_CC */
+      break;
+     
+    }
+  }
+
+  if((tags_checked&0x6) != 0x6) {
+    /* at least TAG_SW and TAG_CC compulsory */
+    if (card->ctx->debug) sc_debug(card->ctx, "ERROR: missing TAG_SW or TAG_CC\n");
+    //We check if the error is the typical securityd error: 69 88 or 69 87
+    if (secure_apdu->sw1 == 0x69 && (secure_apdu->sw2 == 0x88 || secure_apdu->sw2 == 0x87) && DRVDATA(card)->trusted_channel_err < 10){
+        card_card_create_secure_channel(card);
+        DRVDATA(card)->trusted_channel_err = DRVDATA(card)->trusted_channel_err + 1;
+    }
+
+    return SC_ERROR_INVALID_DATA;
+  }
+  
+  if (card->ctx->debug) sc_debug(card->ctx, "Leaving function card_parse_secure_rx\n");
+  return SC_SUCCESS;
+}
+
+
+int card_assure_secure_channel(struct sc_card *card)
+{
+  if(!card->drv_data)
+    return SC_ERROR_INTERNAL;
+
+  /* we create secure channel if it hasn't been created */
+  if(((struct card_priv_data *) card->drv_data)->secure_channel_state == secure_channel_not_created){
+    return card_card_create_secure_channel(card);
+}
+  /* if secure channel is being created or created we just return */
+  return SC_SUCCESS;  
+}
+
+int card_card_create_secure_channel(struct sc_card *card)
+{
+  int r = SC_SUCCESS;
+  sc_serial_number_t serial;
+  struct sc_pkcs15_cert cert;
+  struct sc_file *file = NULL;
+  struct sc_path path;
+  u8 *buffer=NULL;
+  size_t buflen=0;
+  RSA *icc_public_key = NULL;
+  RSA *ifd_private_key = NULL;
+  u8 kicc[32];
+  u8 kifd[32];
+  u8 rndicc[8];
+  u8 rndifd[8];
+  static const u8 select_ca_root_data[]={0x83,0x02,0x02,0x0F};
+#if TEST_KEYS
+  static const u8 select_key_verification_data[]={0x83,0x08,0x65,0x73,0x54,0x43,0x41,0x60,0x00,0x05};
+  static const u8 select_two_keys_data[]={0x84, 0x02, 0x02, 0x1F, 0x83, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88};                   
+
+#else /* TEST KEYS */
+  static const u8 select_key_verification_data[]={0x83,0x08,0x65,0x73,0x53,0x44,0x49,0x60,0x00,0x06};
+  static const u8 select_two_keys_data[]={0x84,0x02,0x02,0x1F,0x83,0x0C,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x01};
+#endif /* TEST KEYS */
+
+#if TEST_KEYS
+  static const u8 ifd_serial_data[] = {0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88};
+#else /* TEST_KEYS */
+  static const u8 ifd_serial_data[] = {0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x01};
+#endif /* TEST_KEYS */
+  u8 bufferrnd[0x10];
+  u8 signature[128];
+  sc_apdu_t apdu;
+
+  if (card->ctx->debug) sc_debug(card->ctx, "Entering function card_card_create_secure_channel\n");
+
+  /* reset card */
+  (void) sc_reset(card);
+
+  /* flag secure channel as being created */
+  ((struct card_priv_data *) card->drv_data)->secure_channel_state = secure_channel_creating;
+  
+  /* initialize serial number from the card */
+  memset(&serial, 0, sizeof(serial));
+  if((r = card_get_serialnr(card, &serial)) != SC_SUCCESS)
+    goto dccsc_end; 
+
+  /* Stage 2: we invert order */
+  
+  /* step H: read icc certificate */
+  if (card->ctx->debug) sc_debug(card->ctx, "Entering Step H\n");
+  sc_format_path("3F00601F", &path);
+  
+  r = card_helper_read_file( card, &path, &buffer, &buflen);
+  if (r!=SC_SUCCESS && r!=buflen)
+    goto dccsc_end; /* this goto lets the function clean up */
+
+  if((r = parse_x509_cert(card->ctx, buffer, buflen, &cert)) != SC_SUCCESS)
+    goto dccsc_end; /* this goto lets the function clean up */
+  
+  if(file) {
+    sc_file_free(file);
+    file = NULL;
+  }
+
+  icc_public_key = RSA_new();
+  if(!icc_public_key)
+    goto dccsc_end; /* this goto lets the function clean up */
+
+  icc_public_key->n = BN_bin2bn(cert.key.u.rsa.modulus.data, 
+				cert.key.u.rsa.modulus.len,
+				icc_public_key->n);
+  icc_public_key->e = BN_bin2bn(cert.key.u.rsa.exponent.data,
+				cert.key.u.rsa.exponent.len, 
+				icc_public_key->e);
+
+  ifd_private_key = RSA_new();
+  if(!ifd_private_key)
+    goto dccsc_end; /* this goto lets the function clean up */
+
+  ifd_private_key->n = BN_bin2bn(ifd_modulus, sizeof(ifd_modulus), ifd_private_key->n);
+  ifd_private_key->e = BN_bin2bn(ifd_public_exponent, sizeof(ifd_public_exponent), ifd_private_key->e);
+  ifd_private_key->d = BN_bin2bn(ifd_private_exponent, sizeof(ifd_private_exponent), ifd_private_key->d);
+
+  if (card->ctx->debug) sc_debug(card->ctx, "Leaving Step H\n");
+
+  /* Stage 1 */
+
+  /* Step A: */
+  /* Step B: Select CA Root public key on smart card*/
+  if (card->ctx->debug) sc_debug(card->ctx, "Entering Step B\n");
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 
+                                              0x22,/*Manage Security Environment*/
+                                              0x81,
+                                              0xB6);
+  apdu.lc=sizeof(select_ca_root_data);
+  apdu.data=select_ca_root_data;
+  apdu.datalen=sizeof(select_ca_root_data);
+  
+  r = card_transmit_apdu(card,&apdu);
+
+  SC_TEST_RET(card->ctx,  r, "Card returned error");
+
+  if (card->ctx->debug) sc_debug(card->ctx, "Leaving Step B\n");
+
+  /* Step C: Verify the certificate of a CA's public key C_CV.CA.CS_AUT */
+  if (card->ctx->debug) sc_debug(card->ctx, "Entering Step C\n");
+
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 
+                                              0x2A,/*Perform Security Operation*/
+                                              0x00,
+                                              0xAE);/*Verify Certificate*/
+  apdu.lc=sizeof(C_CV_CA_CS_AUT_cert);
+  apdu.data=C_CV_CA_CS_AUT_cert;
+  apdu.datalen=sizeof(C_CV_CA_CS_AUT_cert);
+
+  r = card_transmit_apdu(card,&apdu);
+  SC_TEST_RET(card->ctx,  r, "Card returned error");
+
+  if (card->ctx->debug) sc_debug(card->ctx, "Leaving Step C\n");
+
+  /* Step D: Select key verification*/
+  
+  if (card->ctx->debug) sc_debug(card->ctx, "Entering Step D\n");
+
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 
+                                              0x22,/*Manage Security Environment*/
+                                              0x81,/*Set for verfication*/
+                                              0xB6);/*DST*/
+  apdu.lc=sizeof(select_key_verification_data);
+  apdu.data=select_key_verification_data;
+  apdu.datalen=sizeof(select_key_verification_data);
+  
+  r = card_transmit_apdu(card,&apdu);
+  SC_TEST_RET(card->ctx,  r, "Card returned error");
+
+  if (card->ctx->debug) sc_debug(card->ctx, "Leaving Step D\n");
+
+  /* Step E: Verify CA Certificate*/
+
+  if (card->ctx->debug) sc_debug(card->ctx,"Entering Step E\n");
+
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 
+                                              0x2A,/*Perform Security Operation*/
+                                              0x00,
+                                              0xAE);/*Verify Certificate*/
+  apdu.lc=sizeof(C_CV_IFDuser_AUT_cert);
+  apdu.data=C_CV_IFDuser_AUT_cert;
+  apdu.datalen=sizeof(C_CV_IFDuser_AUT_cert);
+
+  r = card_transmit_apdu(card,&apdu);
+  SC_TEST_RET(card->ctx,  r, "Card returned error");
+
+  if (card->ctx->debug) sc_debug(card->ctx,"Leaving Step E\n");
+  
+  /* Stage 3 */
+
+  /* Step I: Select two keys for verification */
+
+  if (card->ctx->debug) sc_debug(card->ctx,"Entering Step I\n");
+
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 
+                                              0x22, /*Manage Security Environment*/
+                                              0xC1, /*Set for internal and external verfication*/
+                                              0xA4);/*AUT*/
+  apdu.lc=sizeof(select_two_keys_data);
+  apdu.data=select_two_keys_data;
+  apdu.datalen=sizeof(select_two_keys_data);
+  
+  r = card_transmit_apdu(card,&apdu);
+  SC_TEST_RET(card->ctx,  r, "Card returned error");
+
+  if (card->ctx->debug) sc_debug(card->ctx, "Leaving Step I\n");
+
+  /* Step J: Internal Authenticate*/
+
+  if (card->ctx->debug) sc_debug(card->ctx,"Entering Step J\n");
+
+  RAND_bytes(bufferrnd, 8); /*data is 8 bytes of random data */
+  memcpy(rndifd,bufferrnd,8);
+  memcpy(bufferrnd+8,ifd_serial_data,8);
+  
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 
+                                              0x88, /*Internal Authenticate*/
+                                              0x00, /*Set for verfication*/
+                                              0x00);/*DST*/
+  apdu.lc=sizeof(bufferrnd);
+  apdu.resp=signature;
+  apdu.resplen=sizeof(signature);
+  apdu.le=sizeof(signature);
+  apdu.data=bufferrnd;
+  apdu.datalen=sizeof(bufferrnd);
+  
+  r = card_transmit_apdu(card,&apdu);
+  SC_TEST_RET(card->ctx,  r, "Card returned error"); 
+  
+  if((r = card_verify_signature(card->ctx,
+                                signature, 
+				sizeof(signature), 
+				bufferrnd, 
+				sizeof(bufferrnd),
+				ifd_private_key,
+				icc_public_key,
+				kicc) ) != SC_SUCCESS) {
+    if (card->ctx->debug) sc_debug(card->ctx, "card_verify_signature failed");
+    goto dccsc_end;
+  }
+  
+   if (card->ctx->debug) sc_debug(card->ctx, "Leaving Step I\n");
+
+  /* Stage 4 */
+  /* Step K Get challenge*/
+
+  if (card->ctx->debug) sc_debug(card->ctx, "Entering Step K\n");
+
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 
+                                              0x84, /*Get Challenge*/
+                                              0x00, 
+                                              0x00);
+  apdu.resp=rndicc;
+  apdu.resplen=sizeof(rndicc);
+  apdu.le=sizeof(rndicc);
+  
+  r = card_transmit_apdu(card,&apdu);
+  SC_TEST_RET(card->ctx,  r, "Card returned error");
+  if (apdu.resplen <= sizeof(rndicc)){
+    memcpy(rndicc,apdu.resp,apdu.resplen);
+  }
+
+  if (card->ctx->debug) sc_debug(card->ctx, "Leaving Step I\n");
+
+  /* Step L External Authenticate*/
+
+  if (card->ctx->debug) sc_debug(card->ctx,"Entering Step L\n");
+
+  if ((r = card_sign_authentication_data(card->ctx,
+                                           &serial,
+                                            rndicc,
+                                   ifd_private_key,
+                                    icc_public_key,
+                                              kifd,
+                                         signature)) != SC_SUCCESS){
+    if (card->ctx->debug) sc_debug(card->ctx, "card_sign_authentication_data failed");
+    goto dccsc_end;
+  }
+
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 
+                                              0x82, /*External Authenticate*/
+                                              0x00, 
+                                              0x00);
+  apdu.lc=sizeof(signature);
+  apdu.data=signature;
+  apdu.datalen=sizeof(signature);
+  apdu.le=0;
+  apdu.resplen=0;
+  apdu.resp=NULL;
+  
+  r = card_transmit_apdu(card,&apdu);
+  SC_TEST_RET(card->ctx,  r, "Card returned error"); 
+
+  if((r=card_compute_session_keys(card->ctx, 
+				  kicc,
+				  kifd,
+				  rndicc,
+				  rndifd,
+				  DRVDATA(card)->kenc,
+				  DRVDATA(card)->kmac,
+				  DRVDATA(card)->ssc
+				  )) != SC_SUCCESS) {
+    if (card->ctx->debug) sc_debug(card->ctx, "card_compute_session_keys failed!");
+    goto dccsc_end;
+  }
+
+  if (card->ctx->debug) sc_debug(card->ctx,"Leaving Step L\n");
+
+ dccsc_end:
+  if(buffer) {
+    free(buffer);
+    buffer = NULL;
+  }    
+  if(icc_public_key) {
+    RSA_free(icc_public_key);
+    icc_public_key = NULL;
+  }
+  if(ifd_private_key) {
+    RSA_free(ifd_private_key);
+    ifd_private_key = NULL;
+  }
+  if(file) {
+    sc_file_free(file);
+    file = NULL;
+  }
+  if(r == SC_SUCCESS) {
+    /* flag secure channel as created */
+    ((struct card_priv_data *) card->drv_data)->secure_channel_state = secure_channel_created;
+  } else {
+    /* flag secure channel as NOT created */
+    ((struct card_priv_data *) card->drv_data)->secure_channel_state = secure_channel_not_created;
+  }
+
+  if (card->ctx->debug) sc_debug(card->ctx, "Leaving function card_card_create_secure_channel with errorcode 0x%X\n", r);
+  return r;
+}
+
+int card_secure_transmit(sc_card_t *card, sc_apdu_t *tx) 
+{
+  int r=0;
+  sc_apdu_t secure_tx;
+  u8 txbuf[1024], rxbuf[1024];
+  
+  /* card_prepare_secure_tx will fill secure_tx, we just prepare buffers here */
+  memset(&secure_tx, 0, sizeof(secure_tx));
+  secure_tx.data = txbuf;
+  secure_tx.datalen = sizeof(txbuf);
+  secure_tx.resp = rxbuf;
+  secure_tx.resplen = sizeof(rxbuf);
+
+  /* prepare secure channel transmission */
+  r = card_prepare_secure_tx(card, tx, &secure_tx);
+  if (r!=SC_SUCCESS)
+    return r;
+
+  /* envelope data and transmit */
+  r = card_envelope_transmit(card, &secure_tx);
+  if (r!=SC_SUCCESS)
+    return r;
+
+  /* retrieve secure channel reception bytes */
+  r = card_parse_secure_rx(card, &secure_tx, tx);
+  if (r!=SC_SUCCESS)
+    return r;
+
+  return r;
+}
+
Index: opensc-0.11.12/src/libopensc/dnie/util.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/util.c	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,265 @@
+/*
+ * util.c: Auxiliary functions
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+*/
+
+#include <stdlib.h>
+#include <string.h>
+#include "util.h"
+#include <opensc/opensc.h>
+#include <assert.h>
+
+#define SC_COPY_TO_FRONT 0
+#define SC_COPY_TO_BACK  1
+
+void ulong2lebytes(u8 *buf, unsigned long x)
+{
+    buf[0] = (u8) (x & 0xff);
+    buf[1] = (u8) ((x >> 8) & 0xff);
+    buf[2] = (u8) ((x >> 16) & 0xff);
+    buf[3] = (u8) ((x >> 24) & 0xff);
+}
+
+void ushort2lebytes(u8 *buf, unsigned short x)
+{
+    buf[0] = (u8) (x & 0xff);
+    buf[1] = (u8) ((x >> 8) & 0xff);
+}
+
+unsigned long lebytes2ulong(const u8 *buf)
+{
+  return (unsigned long) (buf[3] << 24 | buf[2] << 16 | buf[1] << 8 | buf[0]);  
+}
+
+unsigned short lebytes2ushort(const u8 *buf)
+{
+    return (unsigned short) (buf[0] << 24 | buf[1] << 16);
+}
+
+/*
+  Function definition
+  
+  @param buf buffer with some data that will be increased in datalen
+             with data of buffer data
+  @param buflen length of buf buffer
+  @param data buffer with data to copy to buf
+  @param  datalen length of data buffer
+
+  @return SC_SUCCESS on exit, SC_ERROR_OUT_OF_MEMORY whether we get an
+          error allocating memory
+ */
+static int data2buf(u8 **buf, size_t *buflen, const u8 *data, const size_t datalen, int to_where)
+{
+  u8  *temp = NULL;
+
+  if (!buf)
+    return SC_ERROR_OUT_OF_MEMORY;
+  
+  if (*buflen>0) {
+    temp = (u8 *) malloc(*buflen);
+    if (!temp)
+      return SC_ERROR_OUT_OF_MEMORY;
+    memcpy( temp, *buf, *buflen);
+  }
+
+  *buf = realloc( *buf, *buflen+datalen );
+  if (!*buf)
+    return SC_ERROR_OUT_OF_MEMORY;
+
+  switch (to_where) {
+  case SC_COPY_TO_FRONT:
+    memcpy( *buf, data, datalen );
+    memcpy( *buf+datalen, temp, *buflen );
+    break;
+  case SC_COPY_TO_BACK:
+    memcpy( *buf, temp, *buflen );
+    memcpy( *buf+*buflen, data, datalen );
+    break;
+  default:
+    return SC_ERROR_INVALID_ARGUMENTS;
+  }
+  *buflen += datalen;
+
+  if(temp)
+    free(temp);
+  return SC_SUCCESS;
+}
+
+/*
+  Function definition
+  
+  @param buf buffer with some data that will be increased in datalen
+             with data of buffer data
+  @param buflen length of buf buffer
+  @param data buffer with data to copy to buf
+  @param  datalen length of data buffer
+
+  @return SC_SUCCESS on exit, SC_ERROR_OUT_OF_MEMORY whether we get an
+          error allocating memory
+ */
+int push_front_data2buf(u8 **buf, size_t *buflen, const u8 *data, const size_t datalen)
+{
+  return data2buf(buf, buflen, data, datalen, SC_COPY_TO_FRONT);
+}
+
+/*
+  Function definition
+  
+  @param buf buffer with some data that will be increased in datalen
+             with data of buffer data
+  @param buflen length of buf buffer
+  @param data buffer with data to copy to buf
+  @param  datalen length of data buffer
+
+  @return SC_SUCCESS on exit, SC_ERROR_OUT_OF_MEMORY whether we get an
+          error allocating memory
+ */
+int push_back_data2buf(u8 **buf, size_t *buflen, const u8 *data, const size_t datalen)
+{
+  return data2buf(buf, buflen, data, datalen, SC_COPY_TO_BACK);
+}
+
+/*
+  Function definition
+  
+  @param void pointer to a  buffer
+  @param length of buffer
+ */
+void free_struct( void *ptr, size_t length )
+{
+  if (ptr) {
+    memset( ptr, 0, length );
+    free( ptr );
+    ptr=NULL;
+  }
+}
+
+int sc_path_set_dnie(sc_path_t *path, int type, unsigned char *id, size_t id_len,
+		int idx, int count)
+{
+  if (path == NULL || id == NULL || id_len == 0 || id_len > SC_MAX_PATH_SIZE)
+    return SC_ERROR_INVALID_ARGUMENTS;
+  memcpy(path->value, id, id_len);
+  path->len   = id_len;
+  path->type  = type;
+  path->index = idx;
+  path->count = count;
+
+  return SC_SUCCESS;
+}
+
+int compute_tlv_value_len( const tlv_t *tlv )
+{
+  size_t valuelen=0;
+  unsigned int ii=0;
+
+  assert(tlv!=NULL && tlv->length!=NULL);
+  
+  valuelen = tlv->length[0];
+  for(ii=1; tlv->nlen>ii; ii++)    
+    valuelen = tlv->length[ii] | (valuelen << 8); 
+  
+  return valuelen;
+}
+
+int tlv2buf( const tlv_t *tlv, u8 **buf)
+{
+  size_t valuelen=0, total=0, offset=0;
+  int r=SC_SUCCESS;
+
+  assert(tlv!=NULL && buf!=NULL && tlv->value!=NULL && tlv->length!=NULL);
+
+  if(*buf) {
+    free(*buf);
+    *buf=NULL;
+  }
+  
+  valuelen = compute_tlv_value_len( tlv );    
+  total = 1+tlv->nlen+valuelen;
+  *buf = calloc(1, total);
+  if(!*buf) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto end;
+  }
+
+  *buf[offset++] = tlv->tag;
+  memcpy(*buf+offset, tlv->length, tlv->nlen);
+  offset+=tlv->nlen;
+  memcpy(*buf+offset, tlv->value, valuelen);
+
+  end:
+    if (r == SC_SUCCESS)
+      return total;
+    else
+      return r;
+}
+
+int buf2tlv(const u8 tag, const u8 *data, const size_t len, tlv_t *tlv)
+{
+  int r = SC_SUCCESS;
+
+  assert(data!=NULL && len>0 && tlv!=NULL);
+
+  tlv->tag = tag;
+  
+  if (len<=0x00FF) {
+    tlv->nlen=0x01;
+    tlv->length = calloc(1, tlv->nlen);
+    if (!tlv->length) {
+      r = SC_ERROR_OUT_OF_MEMORY;
+      goto end;
+    }
+    tlv->length[0] = (u8) len;
+  } else if (len<=0xFFFF) {
+    tlv->nlen=0x03;
+    tlv->length = calloc(1, tlv->nlen);
+    if (!tlv->length) {
+      r = SC_ERROR_OUT_OF_MEMORY;
+      goto end;
+    }
+    tlv->length[0] = 0x00;
+    tlv->length[1] = 0x00FF & (len>>8);
+    tlv->length[2] = 0x00FF & len;
+  } else {
+    r = SC_ERROR_INVALID_DATA;
+    goto end;
+  }
+
+  tlv->value = calloc(1, len);
+  if (!tlv->value) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto end;
+  }
+  memcpy(tlv->value, data, len);
+
+ end:
+  return r;
+}
+
+void free_tlv( tlv_t *tlv )
+{
+  assert(tlv!=NULL);
+  
+  free(tlv->length);
+  tlv->length = NULL;
+  free(tlv->value);
+  tlv->value = NULL;
+  
+  memset(tlv, 0, sizeof(struct tlv));
+}
Index: opensc-0.11.12/src/libopensc/dnie/util.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/util.h	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,76 @@
+/*
+ * util.h: Auxiliary functions
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+*/
+
+#ifndef _UTIL_H
+#define _UTIL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <opensc/types.h>
+#include "base_cardctl.h"
+
+  void ulong2lebytes(u8 *buf, unsigned long x);
+  void ushort2lebytes(u8 *buf, unsigned short x);
+  unsigned long lebytes2ulong(const u8 *buf);
+  unsigned short lebytes2ushort(const u8 *buf);
+  int push_front_data2buf(u8 **buf, size_t *buflen, const u8 *data, const size_t datalen);
+  int push_back_data2buf(u8 **buf, size_t *buflen, const u8 *data, const size_t datalen);
+  void free_struct( void *ptr, size_t length );
+  int sc_path_set_dnie(sc_path_t *path, int type, unsigned char *id, size_t id_len,
+		  int idx, int count);
+  /*
+    Parse a tlv and gets a buffer from all its components
+    computing the tlv value length.
+
+    \param[in] tlv structure containing all tlv data
+    \param[out] buf buffer containing all tlv data parsed
+
+    \return number of all tlv bytes if success, or error otherwise
+   */
+  int tlv2buf(const tlv_t *tlv, u8 **buf);
+
+  /*
+    Builds a tlv computing a tlv correct length (dnie mode) and filling its parameters.
+    Allocates necessary internal tlv buffers. Need to be freed on external function.
+
+    \param[in] tag byte corresponding to a tag of tlv struct
+    \param[in] data data to be copied to tlv
+    \param[in] len length of data buffer
+    \param[out] tlv structure to be filled
+
+    returns SC_SUCCESS on succes, error otherwise
+  */
+  int buf2tlv(const u8 tag, const u8 *data, const size_t len, tlv_t *tlv);
+
+  /*
+    Frees memory from tlv length and tlv value buffers
+
+    \param[in] tlv structure tlv to be freed
+   */
+  void free_tlv( tlv_t *tlv );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _UTIL_H */
Index: opensc-0.11.12/src/libopensc/dnie/virtual_fs.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/virtual_fs.c	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,397 @@
+/*!
+ * \file virtual_fs.c
+ * \brief Card virtual filesystem
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#include "virtual_fs.h"
+#include <stdlib.h>
+#include <string.h>
+
+virtual_file_t * virtual_file_new()
+{
+  /* calloc already zeroes memory */
+  return calloc(1, sizeof(virtual_file_t));
+}
+
+void virtual_file_free( virtual_file_t *virtual_file )
+{
+  if(virtual_file) {
+    if(virtual_file->data) {
+      memset(virtual_file->data, 0, virtual_file->data_size);
+      free(virtual_file->data);
+      virtual_file->data = NULL;
+    }
+    memset(virtual_file, 0, sizeof(virtual_file_t));
+    free(virtual_file);
+    virtual_file = NULL;
+  }
+}
+
+int virtual_file_data_update( virtual_file_t *virtual_file, int offset, const unsigned char *data, int data_length )
+{
+  unsigned char *temp_data = NULL;
+  int temp_data_size;
+
+  if(!virtual_file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  if(data_length==0) /* do nothing */
+    return SC_SUCCESS;
+			
+  if(!data)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  /* correct if data_size is not ok */
+  if(!virtual_file->data)
+    virtual_file->data_size = 0;
+
+  /* check if we have enough room for the data */
+  if(virtual_file->data_size<(data_length+offset)) {
+    /* we need more room */
+    temp_data_size = data_length+offset;
+    temp_data = calloc(1, temp_data_size);
+    if(!temp_data)
+      return SC_ERROR_OUT_OF_MEMORY;
+
+    /* copy old data */
+    if(virtual_file->data_size > 0)
+      memcpy(temp_data, virtual_file->data, virtual_file->data_size);
+    
+    /* free old buffer */
+    if(virtual_file->data)
+      free(virtual_file->data);
+
+    /* set new buffer */
+    virtual_file->data = temp_data;
+    virtual_file->data_size = temp_data_size;
+  }
+
+  /* we have enough room now, copy data */
+  if(data_length > 0) {
+    memcpy(virtual_file->data+offset, data, data_length);
+
+    /* flag as not synchronized */
+    virtual_file->virtual_fs_to_card.sync_state = virtual_file_sync_state_sync_pending;
+  }
+
+  return SC_SUCCESS;
+}
+
+int virtual_file_data_read( virtual_file_t *virtual_file, int offset, unsigned char *data, int data_length )
+{
+  if(!virtual_file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  if(data_length==0) /* do nothing */
+    return SC_SUCCESS;
+			
+  if(!data)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  /* correct if data_size is not ok */
+  if(!virtual_file->data)
+    virtual_file->data_size = 0;
+  
+  /* check if request is not out of bounds */
+  if(virtual_file->data_size<(data_length+offset))
+    return SC_ERROR_WRONG_LENGTH;
+
+  /* copy data */
+  if(data_length > 0)
+    memcpy(data, virtual_file->data+offset, data_length);
+
+  return SC_SUCCESS;
+}
+
+int virtual_file_data_zero( virtual_file_t *virtual_file, int data_size )
+{
+  if(!virtual_file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  if(data_size == 0) {
+    if(virtual_file->data) {
+      free(virtual_file->data);
+      virtual_file->data = NULL;
+    }
+    virtual_file->data_size = data_size;
+    return SC_SUCCESS;
+  }
+
+  if((virtual_file->data_size == data_size) && virtual_file->data) {
+    /* we already have a suitable buffer */
+    memset(virtual_file->data, 0, virtual_file->data_size); 
+    return SC_SUCCESS;
+  }
+
+  if(virtual_file->data) {
+    /* free existing buffer */
+    memset(virtual_file->data, 0, virtual_file->data_size); 
+    free(virtual_file->data);
+    virtual_file->data = NULL;
+  }
+
+  /* set to 0 to have a coherent state if anything fails */
+  virtual_file->data_size = 0;
+
+  /* allocate new zeroed buffer */
+  virtual_file->data = calloc(1, data_size);
+  if(!virtual_file->data)
+    return SC_ERROR_OUT_OF_MEMORY;
+  
+  /* set correct size */
+  virtual_file->data_size = data_size;
+  
+  return SC_SUCCESS;
+}
+
+int virtual_file_data_synchronize( virtual_file_t *virtual_file, sc_card_t *card, virtual_file_sync_type_t sync_type, virtual_fs_t *virtual_fs )
+{
+  int r = SC_SUCCESS;
+
+  if(!virtual_file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  virtual_file_sync_t *sync = NULL;
+
+  if(sync_type == virtual_file_sync_type_card_to_virtual_fs)
+    sync = &virtual_file->card_to_virtual_fs;
+  else
+    sync = &virtual_file->virtual_fs_to_card;
+  
+  /* we only synchronized if the same type of synchronization as the object type was request */
+  if(!sync->sync_callback)
+    return SC_SUCCESS;
+
+  if(sync->sync_state == virtual_file_sync_state_sync_pending) {
+    r = sync->sync_callback(card, virtual_file, virtual_fs);
+    if(r == SC_SUCCESS)
+      sync->sync_state = virtual_file_sync_state_synced;
+    if(r == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
+      r = SC_SUCCESS;
+  }
+
+  /* no synchronization needed */
+  return r;
+}
+
+int virtual_file_export_file( virtual_file_t *virtual_file, sc_file_t *file )
+{
+  if(!virtual_file || !file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+  
+  if(virtual_file->is_ef) {
+    file->type = SC_FILE_TYPE_WORKING_EF;
+    file->ef_structure = SC_FILE_EF_TRANSPARENT;
+    file->size = virtual_file->data_size;
+  } else {
+    file->type = SC_FILE_TYPE_DF;
+  }
+
+  memcpy(&file->path, &virtual_file->path, sizeof(virtual_file->path));
+  return SC_SUCCESS;
+}
+  
+virtual_file_list_item_t * virtual_file_list_item_new()
+{
+  /* calloc already zeroes memory */
+  return calloc(1, sizeof(virtual_file_list_item_t));
+}
+
+void virtual_file_list_item_free( virtual_file_list_item_t *virtual_file_list_item )
+{
+  if(virtual_file_list_item) {
+    if(virtual_file_list_item->virtual_file) {
+      virtual_file_free(virtual_file_list_item->virtual_file);
+      virtual_file_list_item->virtual_file = NULL;
+    }
+    memset(virtual_file_list_item, 0, sizeof(virtual_file_list_item_t));
+    free(virtual_file_list_item);
+    virtual_file_list_item = NULL;
+  }
+}
+
+virtual_fs_t * virtual_fs_new()
+{
+  /* calloc already zeroes memory */
+  return calloc(1, sizeof(virtual_fs_t));
+}
+
+void virtual_fs_free( virtual_fs_t *virtual_fs )
+{
+  if(virtual_fs) {
+    if(virtual_fs->list) {
+      virtual_file_list_item_free(virtual_fs->list);
+      virtual_fs->list = NULL;
+    }
+    memset(virtual_fs, 0, sizeof(virtual_fs_t));
+    free(virtual_fs);
+    virtual_fs = NULL;
+  }
+}
+
+int virtual_fs_append( virtual_fs_t *virtual_fs, virtual_file_t *virtual_file )
+{
+  virtual_file_list_item_t *virtual_file_list_item = NULL;
+
+  if(!virtual_fs || !virtual_file)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  virtual_file_list_item = virtual_file_list_item_new();
+  if(!virtual_file_list_item)
+    return SC_ERROR_OUT_OF_MEMORY;
+
+  virtual_file_list_item->virtual_file = virtual_file;
+  virtual_file_list_item->next = virtual_fs->list;
+  virtual_fs->list = virtual_file_list_item;
+
+  return SC_SUCCESS;
+}
+
+virtual_file_t * virtual_fs_find_by_path( virtual_fs_t *virtual_fs, const sc_path_t *path )
+{
+  virtual_file_list_item_t *virtual_file_list_item = NULL;
+
+  if(!virtual_fs || !path )
+    return NULL;
+
+  virtual_file_list_item = virtual_fs->list;
+  while(virtual_file_list_item) {
+    if(virtual_file_list_item->virtual_file && sc_compare_path(&virtual_file_list_item->virtual_file->path, path)) {
+      /* we found it! */
+      return virtual_file_list_item->virtual_file;
+    }
+    /* iterate through the list */
+    virtual_file_list_item = virtual_file_list_item->next;
+  }
+
+  /* we didn't find the virtual_file */
+  return NULL;
+}
+
+int virtual_fs_get_data_by_path( virtual_fs_t *virtual_fs, const sc_path_t *path, u8 **buffer, int *length )
+{
+  int r = SC_SUCCESS;
+  virtual_file_t *virtual_file = NULL;
+
+  if(!virtual_fs || !path || !buffer || *buffer || !length)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  virtual_file = virtual_fs_find_by_path(virtual_fs, path);
+  if(!virtual_file) {
+    r = SC_ERROR_OBJECT_NOT_FOUND;
+    goto end;
+  }
+
+  if(!virtual_file->is_ef) {
+    /* file must be an ef */
+    r = SC_ERROR_INVALID_ARGUMENTS;
+    goto end;
+  }
+
+  *length = virtual_file->data_size;
+
+  if(*length > 0) {
+    if(!virtual_file->data) {
+      r = SC_ERROR_INTERNAL;
+      goto end;
+    }
+
+    *buffer = malloc(*length);
+    if(!*buffer) {
+      r = SC_ERROR_OUT_OF_MEMORY;
+      goto end;
+    }
+
+    memcpy(*buffer, virtual_file->data, *length);
+  }
+  
+ end:
+  return r;
+}
+
+int virtual_fs_append_new_virtual_file( virtual_fs_t *virtual_fs, 
+					const sc_path_t *path,
+					const unsigned char *data,
+					int data_length,
+					int file_size,
+					int is_ef,
+					virtual_file_sync_state_t card_to_virtual_fs_sync_state,
+					virtual_file_sync_callback *card_to_virtual_fs_sync_callback,
+					virtual_file_sync_state_t virtual_fs_to_card_sync_state,
+					virtual_file_sync_callback *virtual_fs_to_card_sync_callback
+				      )
+{
+  int r = SC_SUCCESS;
+  virtual_file_t *virtual_file = NULL;
+
+  if(!virtual_fs || !path)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  if(file_size < data_length)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  /* create new virtual_file */
+  virtual_file = virtual_file_new();
+  if(!virtual_file) {
+    r = SC_ERROR_OUT_OF_MEMORY;
+    goto end;
+  }
+
+  /* copy data */
+  if(file_size > data_length) {
+    r = virtual_file_data_zero(virtual_file, file_size);
+    if(r != SC_SUCCESS)
+      goto end;
+  }
+
+  if(data_length>0 && data!=NULL) {
+    r = virtual_file_data_update(virtual_file, 0, data, data_length);
+    if(r != SC_SUCCESS)
+      goto end;
+  }
+
+  /* copy all remaining fields */
+  memcpy(&virtual_file->path, path, sizeof(virtual_file->path));
+  virtual_file->is_ef = is_ef;
+  virtual_file->card_to_virtual_fs.sync_state = card_to_virtual_fs_sync_state;
+  virtual_file->card_to_virtual_fs.sync_callback = card_to_virtual_fs_sync_callback;
+  virtual_file->virtual_fs_to_card.sync_state = virtual_fs_to_card_sync_state;
+  virtual_file->virtual_fs_to_card.sync_callback = virtual_fs_to_card_sync_callback;
+
+  /* append file to virtual_fs */
+  r = virtual_fs_append(virtual_fs, virtual_file);
+  if(r != SC_SUCCESS)
+    goto end;
+
+  /* we don't have ownership of virtual_file now,
+     so we don't need to free it */
+  virtual_file = NULL;
+  
+
+ end:
+  if(r != SC_SUCCESS) {
+    if(virtual_file) {
+      virtual_file_free(virtual_file);
+      virtual_file = NULL;
+    }
+  }
+    
+  return r;
+}
Index: opensc-0.11.12/src/libopensc/dnie/virtual_fs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/virtual_fs.h	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,285 @@
+/*!
+ * \file virtual_fs.h
+ * \brief Card virtual filesystem
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#ifndef VIRTUAL_FS_H
+#define VIRTUAL_FS_H
+
+
+/* include for sc_card_t and sc_path_t definitions */
+#include <opensc/opensc.h>
+
+/*!
+  Kind of synchronization for the file.
+*/
+typedef enum _virtual_file_sync_type_t {
+  virtual_file_sync_type_card_to_virtual_fs = 0,   /*!< this file will be synchronized from the card to the virtual fs */
+  virtual_file_sync_type_virtual_fs_to_card    /*!< this file will be synchronized from the virtual fs to the card */
+} virtual_file_sync_type_t;
+
+
+
+/*!
+  File synchronization state
+*/
+typedef enum _virtual_file_sync_state_t {
+  virtual_file_sync_state_unknown = 0,    /*!< unknown synchronization state (also possible if file doesn't admit synchronization) */
+  virtual_file_sync_state_synced,         /*!< file is in sync */
+  virtual_file_sync_state_sync_pending    /*!< file synchronization pending */
+} virtual_file_sync_state_t;
+
+/*
+  Forward declaration of struct _virtual_file_t because
+  we need it in virtual_file_sync_callback.
+*/
+struct _virtual_file_t;
+  
+/*
+  Forward declaration of struct _virtual_fs_t because
+  we need it in virtual_file_sync_callback.
+*/
+struct _virtual_fs_t;
+
+/*!
+  Synchronization callback
+*/
+typedef int virtual_file_sync_callback( sc_card_t *card, struct _virtual_file_t *virtual_file, struct _virtual_fs_t *virtual_fs );
+
+/*!
+  This structure holds synchronization info in one direction
+*/
+typedef struct _virtual_file_sync_t
+{
+  virtual_file_sync_state_t sync_state;      /*!< synchronization state */
+  virtual_file_sync_callback *sync_callback; /*!< synchronization callback */
+} virtual_file_sync_t;
+
+/*!
+  This structure holds a virtual file.
+*/
+typedef struct _virtual_file_t {
+  sc_path_t path;      /*!< Absolute path of the file */
+  unsigned char *data; /*!< Data of the file */
+  int data_size;       /*!< Size of the data in the file */
+  int is_ef;           /*!< 1 if file is an ef, 0 if a df */
+
+  /* synchronization fields */
+  virtual_file_sync_t card_to_virtual_fs; /*!< card to virtual_fs (read) synchronization */
+  virtual_file_sync_t virtual_fs_to_card; /*!< virtual_fs to card (write) synchronization */
+} virtual_file_t;
+
+/*!
+  Single-linked list of virtual_file
+ */
+typedef struct _virtual_file_list_item_t {
+  virtual_file_t *virtual_file;              /*!< virtual_file pointer (data) */
+  struct _virtual_file_list_item_t *next;    /*!< pointer to next item in list */
+} virtual_file_list_item_t;
+
+/*!
+  Virtual filesystem
+*/
+typedef struct _virtual_fs_t {
+  virtual_file_list_item_t *list;            /*!< list of virtual_file */
+} virtual_fs_t;
+
+
+/*!
+  Returns a new virtual_file_t structure
+
+  \returns pointer to newly allocated (and zeroed) structure.
+ */
+virtual_file_t * virtual_file_new();
+
+/*!
+  Frees structure and members.
+  
+  \param virtual_file pointer to the structure to be freed.
+*/
+void virtual_file_free( virtual_file_t *virtual_file );
+
+/*!
+  Update data in file. It handles automatic reallocation of internal
+  buffer if running out of space.
+
+  \param virtual_file virtual_file
+  \param offset offset in virtual_file data buffer where to copy data
+  \param data data buffer to copy
+  \param data_length length of data to copy
+
+  \returns SC_SUCCESS on success, error code otherwise
+ */
+int virtual_file_data_update( virtual_file_t *virtual_file, int offset, const unsigned char *data, int data_length );
+
+/*!
+  Read data from virtual file. 
+
+  \param virtual_file virtual_file
+  \param offset offset in virtual_file data buffer where to copy data from
+  \param data data buffer to copy
+  \param data_length length of data to copy
+
+  \returns SC_SUCCESS on succes, error code otherwise
+ */
+int virtual_file_data_read( virtual_file_t *virtual_file, int offset, unsigned char *data, int data_length );
+
+/*!
+  Create a data buffer with specified number of zeroes
+
+  \param virtual_file virtual_file
+  \param data_size length of newly allocated buffer
+*/
+int virtual_file_data_zero( virtual_file_t *virtual_file, int data_size );
+ 
+/*!
+  Synchronize data in file if needed. This function checks if
+  synchronization is needed and calls function to perform it.
+
+  Synchronization might need inclusion of new files into
+  virtual_fs as a side effect (for instance: new certificate data
+  files).
+
+  \param virtual_file virtual_file
+  \param card sc_card_t pointer that will be passed to synchronization function.
+  \param sync_type sync type we need... the function will only synchronizate if the virtual_file has the same sync_type
+  \param virtual_fs virtual_fs pointer where to add new virtual_file objects if needed
+
+  \returns SC_SUCCESS on succes, error code otherwise
+ */
+int virtual_file_data_synchronize( virtual_file_t *virtual_file, sc_card_t *card, virtual_file_sync_type_t sync_type, virtual_fs_t *virtual_fs );
+
+/*!
+  Create a sc_file_t structure from a virtual_file
+  
+  \param virtual_file a virtual file structure
+  \param file output struct where to generate file data
+ */
+int virtual_file_export_file( virtual_file_t *virtual_file, sc_file_t *file );
+
+/*!
+  Returns a new virtual_file_list_item_t structure
+
+  \returns pointer to newly allocated (and zeroed) structure.
+*/
+virtual_file_list_item_t * virtual_file_list_item_new();
+
+/*!
+  Frees structure and members.
+  
+  \param virtual_file_list_item pointer to the structure to be freed.
+*/
+void virtual_file_list_item_free( virtual_file_list_item_t *virtual_file_list_item );
+
+/*!
+  Creates a new virtual filesystem
+
+  \returns pointer to newly allocated (and zeroed) structure.
+*/
+virtual_fs_t * virtual_fs_new();
+
+/*!
+  Frees structure and members.
+  
+  \param virtual_fs pointer to the structure to be freed.
+*/
+void virtual_fs_free( virtual_fs_t *virtual_fs );
+
+/*!
+  Appends virtual_file to virtual_fs and transfers ownership
+  of the virtual_file system structure to the virtual_fs.
+
+  virtual_fs will deallocate memory on its destruction in
+  virtual_fs_free(), so virtual_file must be created on the
+  heap using a call to virtual_file_new().
+  
+  This operation is a O(1) since we append from the beginning
+  in a single-linked list.
+
+  \param virtual_fs virtual_fs where virtual_file will be appended.
+  \param virtual_file virtual_file_t pointer to append.
+
+  \returns SC_SUCCESS on succes, error code otherwise
+*/
+int virtual_fs_append( virtual_fs_t *virtual_fs, virtual_file_t *virtual_file );
+
+
+/*!
+  Finds a file using a path and returns a pointer to the virtual_file.
+
+  This is a O(n) operation since virtual_fs uses a single-linked list
+  internally.
+  
+  Note: Ownership of virtual_file still belongs to virtual_fs. Users
+  can't free the object.
+  
+  \param virtual_fs filesystem
+  \param path path to search in virtual_file
+
+  \returns pointer to the virtual_file if found, NULL otherwise.
+*/
+virtual_file_t * virtual_fs_find_by_path( virtual_fs_t *virtual_fs, const sc_path_t *path );
+
+
+/*!
+  Finds a ef file using a path and returns its data (allocating memory).
+
+  It uses virtual_fs_find_by_path() to find file
+  
+  \param virtual_fs filesystem
+  \param path path to search in virtual_file
+  \param buffer Pointer to a malloced memory with the data. User is responsible of freeing it.
+  \param length Output length of buffer data.
+
+  \returns pointer to the virtual_file if found, NULL otherwise.
+*/
+int virtual_fs_get_data_by_path( virtual_fs_t *virtual_fs, const sc_path_t *path, u8 **buffer, int *length );
+
+/*!
+  Helper routine that creates a new virtual file, fills it and appends it to
+  the virtual_fs.
+
+  \param path Absolute path of the file. Can't be NULL.
+  \param data Initial data of the file.
+  \param data_length Length of data
+  \param file_size Size of the file. If it doesn't match data_size it fills the file with zeroes till it reaches file_size
+  \param is_ef 1 if file is ef, 0 if df.
+  \param sync_type type of synchronization
+  \param sync_state state of synchronization
+  \param sync_callback callback to synchronize file
+
+  \returns SC_SUCCESS on succes, error code otherwise
+*/
+int virtual_fs_append_new_virtual_file( virtual_fs_t *virtual_fs, 
+					const sc_path_t *path,
+					const unsigned char *data,
+					int data_length,
+					int file_size,
+					int is_ef,
+					virtual_file_sync_state_t card_to_virtual_fs_sync_state,
+					virtual_file_sync_callback *card_to_virtual_fs_sync_callback,
+					virtual_file_sync_state_t virtual_fs_to_card_sync_state,
+					virtual_file_sync_callback *virtual_fs_to_card_sync_callback
+					);
+
+
+
+#endif /* VIRTUAL_FS_H */
+
Index: opensc-0.11.12/src/libopensc/dnie/virtual_pkcs15_fs.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/virtual_pkcs15_fs.c	2010-11-17 19:14:03.000000000 +0000
@@ -0,0 +1,85 @@
+/*!
+ * \file virtual_pkcs15_fs.c
+ * \brief Card virtual PKCS#15 filesystem
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#include "virtual_pkcs15_fs.h"
+#include "card_sync.h"
+
+/* type definitions */
+/* struct to initialize virtual files in virtual_pkcs15_fs_init */
+struct _virtual_file_initializer {
+  const char *path_string;
+  const unsigned char *data;
+  int data_length;
+  int file_size;
+  int is_ef;
+  virtual_file_sync_state_t card_to_virtual_fs_sync_state;
+  virtual_file_sync_callback *card_to_virtual_fs_sync_callback;
+  virtual_file_sync_state_t virtual_fs_to_card_sync_state;
+  virtual_file_sync_callback *virtual_fs_to_card_sync_callback;
+};
+
+/* PKCS#15 filesystem */
+int virtual_pkcs15_fs_init( virtual_fs_t *virtual_fs )
+{
+  int ii;
+  int r = SC_SUCCESS;
+  sc_path_t path;
+  
+  static const struct _virtual_file_initializer files[] = {
+    {"3F00", NULL, 0, 0, 0, virtual_file_sync_state_unknown, NULL, virtual_file_sync_state_unknown, NULL}, /* df mf */
+    {"3F003F11", NULL, 0, 0, 0 /* df */, virtual_file_sync_state_unknown, NULL, virtual_file_sync_state_unknown, NULL}, /* df ICC.Crypto */
+    {"3F006061", NULL, 0, 0, 0 /* df */, virtual_file_sync_state_unknown, NULL, virtual_file_sync_state_unknown, NULL}, /* df certs */
+    {"3F006081", NULL, 0, 0, 0 /* df */, virtual_file_sync_state_unknown, NULL, virtual_file_sync_state_unknown, NULL}, /* df certs */
+    {"3F005015", NULL, 0, 0, 0 /* df */, virtual_file_sync_state_unknown, NULL, virtual_file_sync_state_unknown, NULL},
+    {"3F0050155031", NULL, 0, 0x1000, 1, virtual_file_sync_state_sync_pending, card_sync_card_to_virtual_fs_odf_callback, virtual_file_sync_state_unknown, NULL}, /* ef odf */
+    {"3F0050155032", NULL, 0, 0x1000, 1, virtual_file_sync_state_sync_pending, card_sync_card_to_virtual_fs_tokeninfo_callback, virtual_file_sync_state_unknown, NULL}, /* ef tokeninfo */
+    {"3F0050156000", NULL, 0, 0x1000, 1, virtual_file_sync_state_sync_pending, card_sync_card_to_virtual_fs_aodf_callback, virtual_file_sync_state_unknown, NULL}, /* ef aodf */
+    {"3F0050156001", NULL, 0, 0x4000, 1, virtual_file_sync_state_sync_pending, card_sync_card_to_virtual_fs_prkdf_callback, virtual_file_sync_state_unknown, NULL}, /* ef prkdf */
+    {"3F0050156002", NULL, 0, 0x4000, 1, virtual_file_sync_state_sync_pending, card_sync_card_to_virtual_fs_pukdf_callback, virtual_file_sync_state_unknown, NULL}, /* ef pukdf */
+    {"3F0050156004", NULL, 0, 0x4000, 1, virtual_file_sync_state_sync_pending, card_sync_card_to_virtual_fs_cdf_callback, virtual_file_sync_state_unknown, NULL}, /* ef cdf */
+    {"3F0050156005", NULL, 0, 0x4000, 1, virtual_file_sync_state_sync_pending, card_sync_card_to_virtual_fs_dodf_callback, virtual_file_sync_state_unknown, NULL}, /* ef dodf */
+    {"3F006031", NULL, 0, 0, 0 /* df */, virtual_file_sync_state_unknown, NULL, virtual_file_sync_state_unknown, NULL},
+    {NULL, NULL, 0, 0, 0, virtual_file_sync_state_unknown, NULL, virtual_file_sync_state_unknown, NULL} /* terminal item. first null flags end */
+  };
+
+  if(!virtual_fs)
+    return SC_ERROR_INVALID_ARGUMENTS;
+
+  for(ii=0; files[ii].path_string != NULL ; ii++) {
+    sc_format_path(files[ii].path_string, &path);
+    r = virtual_fs_append_new_virtual_file(virtual_fs, 
+					   &path,
+					   files[ii].data,
+					   files[ii].data_length,
+					   files[ii].file_size,
+					   files[ii].is_ef,
+					   files[ii].card_to_virtual_fs_sync_state,
+					   files[ii].card_to_virtual_fs_sync_callback,
+					   files[ii].virtual_fs_to_card_sync_state,
+					   files[ii].virtual_fs_to_card_sync_callback
+					   );
+    if(r != SC_SUCCESS)
+      break;
+  }
+
+  return r;
+}
Index: opensc-0.11.12/src/libopensc/dnie/virtual_pkcs15_fs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ opensc-0.11.12/src/libopensc/dnie/virtual_pkcs15_fs.h	2010-11-17 19:14:02.000000000 +0000
@@ -0,0 +1,42 @@
+/*!
+ * \file virtual_pkcs15_fs.h
+ * \brief Card virtual PKCS#15 filesystem
+ *
+ * Copyright (C) 2006-2010 Dirección General de la Policía y de la Guardia Civil
+ *
+ * This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ */
+
+#ifndef VIRTUAL_PKCS15_FS_H
+#define VIRTUAL_PKCS15_FS_H
+
+
+/* include for all virtual_* definitions */
+#include "virtual_fs.h"
+
+
+/*!
+  Creates all files needed in PKCS#15 operation
+  
+  \param virtual_fs Virtual filesystem where the files will be created.
+
+  \returns SC_SUCCESS on succes, error code otherwise
+*/
+int virtual_pkcs15_fs_init( virtual_fs_t *virtual_fs );
+
+
+#endif /* VIRTUAL_PKCS15_FS_H */
+
